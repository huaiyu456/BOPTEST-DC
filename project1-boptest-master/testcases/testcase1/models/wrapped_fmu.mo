within ;
model wrapped_fmu
extends fmuIcon;
// Model automatically generated by Dymola from FMI model description
public
encapsulated package importedFMUTypes
  type Modelica_Blocks_Types_InitPID = enumeration(NoInit "No initialization (start values are used as guess values with fixed=false)",
        SteadyState
          "Steady state initialization (derivatives of states are zero)",
        InitialState "Initialization with initial states",
        InitialOutput
          "Initialization with initial outputs (and steady state of the states if possible)",

        DoNotUse_InitialIntegratorState
          "Do not use, only for backward compatibility (initialize only integrator state)");
  type Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs =
        enumeration(                                                                  None "Not used for KPI",
        AirZoneTemperature "Air zone temperature",
        RadiativeZoneTemperature "Radiative zone temperature",
        OperativeZoneTemperature "Operative zone temperature",
        RelativeHumidity "Relative humidity",
        CO2Concentration "CO2 concentration",
        ElectricPower "Electric power from grid",
        DistrictHeatingPower "Thermal power from district heating",
        GasPower "Thermal power from natural gas",
        BiomassPower "Thermal power from biomass",
        SolarThermalPower "Thermal power from solar thermal",
        FreshWaterFlowRate "FreshWaterFlowRate");
end importedFMUTypes;
  parameter Boolean _block_jacobian_check = false;
  parameter Real _block_jacobian_check_tol = 1.0E-6;
  parameter Integer _block_solver_experimental_mode = 0;
  parameter Boolean _block_solver_profiling = false;
  parameter Integer _cs_experimental_mode = 0;
  parameter Real _cs_rel_tol = 1.0E-6;
  parameter Integer _cs_solver = 0;
  parameter Real _cs_step_size = 0.001;
  parameter Boolean _enforce_bounds = true;
  parameter Real _events_default_tol = 1.0E-10;
  parameter Real _events_tol_factor = 1.0E-4;
  parameter Integer _iteration_variable_scaling = 1;
  parameter Integer _log_level = 3;
  parameter Integer _nle_active_bounds_mode = 0;
  parameter Boolean _nle_brent_ignore_error = false;
  parameter Integer _nle_jacobian_calculation_mode = 0;
  parameter Real _nle_jacobian_finite_difference_delta = 1.490116119384766E-8;
  parameter Integer _nle_jacobian_update_mode = 2;
  parameter Boolean _nle_solver_check_jac_cond = false;
  parameter Real _nle_solver_default_tol = 1.0E-10;
  parameter Integer _nle_solver_exit_criterion = 3;
  parameter Integer _nle_solver_max_iter = 100;
  parameter Integer _nle_solver_max_iter_no_jacobian = 10;
  parameter Real _nle_solver_max_residual_scaling_factor = 1.0E10;
  parameter Real _nle_solver_min_residual_scaling_factor = 1.0E-10;
  parameter Real _nle_solver_min_tol = 1.0E-12;
  parameter Real _nle_solver_regularization_tolerance = -1.0;
  parameter Real _nle_solver_step_limit_factor = 10.0;
  parameter Real _nle_solver_tol_factor = 1.0E-4;
  parameter Boolean _nle_solver_use_last_integrator_step = true;
  parameter Boolean _nle_solver_use_nominals_as_fallback = true;
  parameter Boolean _rescale_after_singular_jac = true;
  parameter Boolean _rescale_each_step = false;
  parameter Integer _residual_equation_scaling = 1;
  parameter Boolean _runtime_log_to_file = false;
  parameter Real _time_events_default_tol = 2.220446049250313E-14;
  parameter Boolean _use_Brent_in_1d = true;
  parameter Boolean _use_jacobian_equilibration = false;
  parameter Boolean _use_newton_for_brent = true;
protected
  record 'mod_rec'
  protected
    record CO2RooAir_rec
      constant importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs KPIs = importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs.CO2Concentration "Tag with the type of signal for the calculation of the KPIs";
      constant Boolean boptestRead = true "Protected parameter, used by tools to search for read block in models";
      parameter String description = "Zone air CO2 concentration" "Description of the signal being read";
      Real u "Connector of Real input signal";
      Real y "Connector of Real output signal";
      parameter String zone = "1" "Zone designation, required if KPIs is AirZoneTemperature,      RadiativeZoneTemperature, OperativeZoneTemperature, RelativeHumidity,      or CO2Concentration";
    end CO2RooAir_rec;
  public
    CO2RooAir_rec CO2RooAir annotation(Dialog);
  protected
    record PHea_rec
      constant importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs KPIs = importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs.GasPower "Tag with the type of signal for the calculation of the KPIs";
      constant Boolean boptestRead = true "Protected parameter, used by tools to search for read block in models";
      parameter String description = "Heater power" "Description of the signal being read";
      Real u "Connector of Real input signal";
      Real y(unit = "W") "Connector of Real output signal";
    end PHea_rec;
  public
    PHea_rec PHea annotation(Dialog);
  protected
    record TRooAir_rec
      constant importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs KPIs = importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs.AirZoneTemperature "Tag with the type of signal for the calculation of the KPIs";
      constant Boolean boptestRead = true "Protected parameter, used by tools to search for read block in models";
      parameter String description = "Zone air temperature" "Description of the signal being read";
      Real u "Connector of Real input signal";
      Real y(unit = "K") "Connector of Real output signal";
      parameter String zone = "1" "Zone designation, required if KPIs is AirZoneTemperature,      RadiativeZoneTemperature, OperativeZoneTemperature, RelativeHumidity,      or CO2Concentration";
    end TRooAir_rec;
  public
    TRooAir_rec TRooAir annotation(Dialog);
  protected
    record 'abs_rec'
      constant Boolean generateEvent = false "Choose whether events shall be generated";
      Real u "Connector of Real input signal";
      Real y "Connector of Real output signal";
    end 'abs_rec';
  public
    'abs_rec' 'abs';
  protected
    record cap_rec
      parameter Real C(unit = "J/K", quantity = "HeatCapacity") = 1000000.0 "Heat capacity of element (= cp*m)";
      parameter Real _T_start = 293.15
      annotation(Dialog(tab = "Initial", group = "Approximate"));
      Real T(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0.0,start = _T_start, fixed=false) "Temperature of element";
      Real _T_der;
      parameter Real _der_T_start = 0.0
      annotation(Dialog(tab = "Initial", group = "Approximate"));
      Real der_T(unit = "K/s", quantity = "TemperatureSlope",start = _der_T_start, fixed=false) "Time derivative of temperature (= der(T))";
    protected
      record port_rec
        Real Q_flow(unit = "W", quantity = "Power") "Heat flow rate (positive if flowing from outside into the component)";
        Real T(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0.0) "Port temperature";
      end port_rec;
    public
      port_rec port;
    end cap_rec;
  public
    cap_rec cap annotation(Dialog);
  protected
    record con_rec
      parameter Real Nd(min = 1.0E-13) = 10.0 "The higher Nd, the more ideal the derivative block";
      parameter Real Ni(min = 1.0E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
      parameter Real Td(unit = "s", quantity = "Time", min = 0) = 0.1 "Time constant of Derivative block";
      parameter Real Ti(unit = "s", quantity = "Time", min = 1.0E-60) = 0.5 "Time constant of Integrator block";
      Real controlError "Control error (set point - measurement)";
      constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.P "Type of controller";
      constant importedFMUTypes.Modelica_Blocks_Types_InitPID initType = importedFMUTypes.Modelica_Blocks_Types_InitPID.DoNotUse_InitialIntegratorState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
      parameter Real k(unit = "1", min = 0) = 2000.0 "Gain of controller";
      constant Boolean limitsAtInit = true "= false, if limits are ignored during initialization";
      constant Boolean strict = false "= true, if strict limits with noEvent(..)";
      Real u_m "Connector of measurement input signal";
      Real u_s "Connector of setpoint input signal";
      constant Real unitTime(unit = "s", quantity = "Time") = 1.0;
      parameter Real wd(min = 0) = 0.0 "Set-point weight for Derivative block (0..1)";
      constant Boolean with_D = false;
      constant Boolean with_I = false;
      parameter Real wp(min = 0) = 1.0 "Set-point weight for Proportional block (0..1)";
      parameter Real xd_start = 0.0 "Initial or guess value for state of derivative block";
      parameter Real xi_start = 0.0 "Initial or guess value value for integrator output (= integrator state)";
      Real y(min = -10000, max = 10000) "Connector of actuator output signal";
      constant Real yMax = 100000.0 "Upper limit of output";
      constant Real yMin = 0.0 "Lower limit of output";
      constant Real y_start = 0.0 "Initial value of output";
    protected
      record Dzero_rec
        parameter Real k = 0.0 "Constant output value";
        parameter Real y(fixed=false) "Connector of Real output signal";
      end Dzero_rec;
    public
      Dzero_rec Dzero annotation(Dialog);
    protected
      record Izero_rec
        parameter Real k = 0.0 "Constant output value";
        parameter Real y(fixed=false) "Connector of Real output signal";
      end Izero_rec;
    public
      Izero_rec Izero annotation(Dialog);
    protected
      record P_rec
        parameter Real k(unit = "1") = 1.0 "Gain value multiplied with input signal";
        Real u "Input signal connector";
        Real y "Output signal connector";
      end P_rec;
    public
      P_rec P annotation(Dialog);
    protected
      record addP_rec
        parameter Real k1(fixed=false) "Gain of upper input";
        parameter Real k2 = -1.0 "Gain of lower input";
        Real u1 "Connector of Real input signal 1";
        Real u2 "Connector of Real input signal 2";
        Real y "Connector of Real output signal";
      end addP_rec;
    public
      addP_rec addP annotation(Dialog);
    protected
      record addPID_rec
        parameter Real k1 = 1.0 "Gain of upper input";
        parameter Real k2 = 1.0 "Gain of middle input";
        parameter Real k3 = 1.0 "Gain of lower input";
        Real u1 "Connector 1 of Real input signals";
        parameter Real u2(fixed=false) "Connector 2 of Real input signals";
        parameter Real u3(fixed=false) "Connector 3 of Real input signals";
        Real y "Connector of Real output signals";
      end addPID_rec;
    public
      addPID_rec addPID annotation(Dialog);
    protected
      record gainPID_rec
        parameter Real k(unit = "1", fixed=false) "Gain value multiplied with input signal";
        Real u "Input signal connector";
        Real y "Output signal connector";
      end gainPID_rec;
    public
      gainPID_rec gainPID;
    protected
      record limiter_rec
        constant Boolean limitsAtInit = true "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)";
        constant Boolean strict = false "= true, if strict limits with noEvent(..)";
        Real u "Connector of Real input signal";
        parameter Real uMax = 100000.0 "Upper limits of input signals";
        parameter Real uMin = 0.0 "Lower limits of input signals";
        Real y "Connector of Real output signal";
      end limiter_rec;
    public
      limiter_rec limiter annotation(Dialog);
    end con_rec;
  public
    con_rec con annotation(Dialog);
  protected
    record conCO2_rec
      parameter Real amplitude = 250.0 "Amplitude of sine wave";
      parameter Real freqHz(unit = "s-1", quantity = "Frequency") = 1.1574074074074073E-5 "Frequency of sine wave";
      parameter Real offset = 750.0 "Offset of output signal";
      parameter Real phase(unit = "1", displayUnit = "deg", quantity = "Angle") = 0.0 "Phase of sine wave";
      parameter Real startTime(unit = "s", quantity = "Time") = 0.0 "Output = offset for time < startTime";
      Real y "Connector of Real output signal";
    end conCO2_rec;
  public
    conCO2_rec conCO2 annotation(Dialog);
  protected
    record eff_rec
      parameter Real k(unit = "1") = 1.0101010101010102 "Gain value multiplied with input signal";
      Real u "Input signal connector";
      Real y "Output signal connector";
    end eff_rec;
  public
    eff_rec eff annotation(Dialog);
  protected
    record oveAct_rec
      constant Boolean boptestOverwrite = true "Protected parameter, used by tools to search for overwrite block in models";
      parameter String description = "Heater thermal power" "Description of the signal being overwritten";
      Real u(unit = "W", min = -10000, max = 10000) "Connector of Real input signal";
      Real y "Connector of Real output signal";
    protected
      record activate_rec
        Boolean y "Value of Boolean output";
      end activate_rec;
    public
      activate_rec activate;
    protected
      record swi_rec
        Real u1 "Connector of first Real input signal";
        Boolean u2 "Connector of Boolean input signal";
        Real u3 "Connector of second Real input signal";
        Real y "Connector of Real output signal";
      end swi_rec;
    public
      swi_rec swi;
    protected
      record uExt_rec
        Real y "Value of Real output";
      end uExt_rec;
    public
      uExt_rec uExt;
    end oveAct_rec;
  public
    oveAct_rec oveAct annotation(Dialog);
  protected
    record preHeat_rec
      Real Q_flow(unit = "W");
      parameter Real T_ref(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0.0) = 293.15 "Reference temperature";
      parameter Real alpha(unit = "1/K", quantity = "LinearTemperatureCoefficient") = 0.0 "Temperature coefficient of heat flow rate";
    protected
      record port_rec
        Real Q_flow(unit = "W", quantity = "Power") "Heat flow rate (positive if flowing from outside into the component)";
        Real T(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0.0) "Port temperature";
      end port_rec;
    public
      port_rec port;
    end preHeat_rec;
  public
    preHeat_rec preHeat annotation(Dialog);
  protected
    record preTOut_rec
      Real T(unit = "K");
    protected
      record port_rec
        Real Q_flow(unit = "W", quantity = "Power") "Heat flow rate (positive if flowing from outside into the component)";
        parameter Real _T_start = 288.15
        annotation(Dialog(tab = "Initial", group = "Approximate"));
        Real T(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0.0,start = _T_start, fixed=false) "Port temperature";
      end port_rec;
    public
      port_rec port annotation(Dialog);
    end preTOut_rec;
  public
    preTOut_rec preTOut annotation(Dialog);
  protected
    record res_rec
      Real Q_flow(unit = "W", quantity = "Power") "Heat flow rate from port_a -> port_b";
      parameter Real R(unit = "K/W", quantity = "ThermalResistance") = 0.01 "Constant thermal resistance of material";
      Real dT(unit = "K", quantity = "ThermodynamicTemperature") "port_a.T - port_b.T";
    protected
      record port_a_rec
        Real Q_flow(unit = "W", quantity = "Power") "Heat flow rate (positive if flowing from outside into the component)";
        Real T(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0.0) "Port temperature";
      end port_a_rec;
    public
      port_a_rec port_a;
    protected
      record port_b_rec
        Real Q_flow(unit = "W", quantity = "Power") "Heat flow rate (positive if flowing from outside into the component)";
        Real T(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0.0) "Port temperature";
      end port_b_rec;
    public
      port_b_rec port_b;
    end res_rec;
  public
    res_rec res annotation(Dialog);
  protected
    record senTZone_rec
      Real T(unit = "K") "Absolute temperature as output signal";
    protected
      record port_rec
        constant Real Q_flow(unit = "W", quantity = "Power") = 0.0 "Heat flow rate (positive if flowing from outside into the component)";
        Real T(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0.0) "Port temperature";
      end port_rec;
    public
      port_rec port;
    end senTZone_rec;
  public
    senTZone_rec senTZone;
  protected
    record set_rec
      parameter Real height = 2.0 "Height of step";
      parameter Real offset = 293.15 "Offset of output signal y";
      parameter Real startTime(unit = "s", quantity = "Time") = 86400.0 "Output y = offset for time < startTime";
      Real y "Connector of Real output signal";
    end set_rec;
  public
    set_rec set annotation(Dialog);
  protected
    record souTOut_rec
      parameter Real amplitude = 10.0 "Amplitude of sine wave";
      parameter Real freqHz(unit = "s-1", quantity = "Frequency") = 1.1574074074074073E-5 "Frequency of sine wave";
      parameter Real offset = 293.15 "Offset of output signal";
      parameter Real phase(unit = "1", displayUnit = "deg", quantity = "Angle") = 0.0 "Phase of sine wave";
      parameter Real startTime(unit = "s", quantity = "Time") = 0.0 "Output = offset for time < startTime";
      Real y "Connector of Real output signal";
    end souTOut_rec;
  public
    souTOut_rec souTOut annotation(Dialog);
  end 'mod_rec';
public
  'mod_rec' 'mod' annotation(Dialog);
  parameter Boolean _oveAct_activate_start = false
  annotation (Dialog( group="Start values for inputs "));
protected
  Boolean _oveAct_activate_old;
public
  Modelica.Blocks.Interfaces.BooleanInput oveAct_activate(start = _oveAct_activate_start) "Activation for Heater thermal power"
  annotation (Placement(transformation(extent={{-124,14},{-84,54}})));
  parameter Real _oveAct_u_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _oveAct_u_old;
public
  Modelica.Blocks.Interfaces.RealInput oveAct_u(unit = "W", min = -10000.0, max = 10000.0, start = _oveAct_u_start) "Heater thermal power"
  annotation (Placement(transformation(extent={{-124,-53},{-84,-13}})));
  Modelica.Blocks.Interfaces.RealOutput CO2RooAir_y "Zone air CO2 concentration"
  annotation (Placement(transformation(extent={{100,40},{140,80}})));
  Modelica.Blocks.Interfaces.RealOutput PHea_y(unit = "W") "Heater power"
  annotation (Placement(transformation(extent={{100,0},{140,40}})));
  Modelica.Blocks.Interfaces.RealOutput TRooAir_y(unit = "K") "Zone air temperature"
  annotation (Placement(transformation(extent={{100,-40},{140,0}})));
  Modelica.Blocks.Interfaces.RealOutput oveAct_y(unit = "W") "Heater thermal power"
  annotation (Placement(transformation(extent={{100,-80},{140,-40}})));
public
  parameter String fmi_instanceName="wrapped_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  parameter Boolean fmi_InputTime=false
  "Time point of input used when calling doStep."
  annotation (Evaluate=true,Dialog(tab="FMI", group="Input Handling"),choices(choice= false "StepEnd", choice= true "StepStart"));
  parameter Boolean fmi_UsePreOnInputSignals=true
  annotation (Evaluate=true,Dialog(tab="FMI", group="Input Handling"));
  parameter Real fmi_StartTime = 0.0
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_StopTime = 1.0
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_NumberOfSteps = 500
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_CommunicationStepSize=(fmi_StopTime-fmi_StartTime)/fmi_NumberOfSteps
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Integer stepSizeScaleFactor = 1 "Number of doSteps called between two CommunicationStepSize"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Boolean fmi_forceShutDownAtStopTime=false
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Boolean fmi_setTol=false "Set the tolerance fmi_rTol in fmi2SetupExperiment, if false fmu defautl tolerence will be used."
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_rTol=1e-6 "Relative tolerance for the internal solver of the fmu"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter String fmi_resourceLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://wrapped_fmu/Resources/Library/FMU/wrapped/resources")
  annotation (Dialog(tab="FMI", group="Instantiation"));
protected
  fmi_Functions.fmiModel fmi;
  Boolean fmi_exitInit(start=false,fixed=true);
  Boolean fmi_flip(start=false,fixed=true);
  parameter Real fmi_rdum(start=0,fixed=false);
  parameter Integer fmi_idum(start=0,fixed=false);
  Boolean fmi_StepOK;
  parameter Real zeroOffset = 0;
  parameter Real myTimeStart(fixed=false);
  record 'Internal '
    Real CO2RooAir_y;
    Real PHea_y;
    Real TRooAir_y;
    Real oveAct_y;
  end 'Internal ';
  'Internal ' internal;
Real RealVariables[21];
Real RealDependentParameters[4];
Boolean BooleanVariables[1];
package fmi_Functions
    class fmiModel
      extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        input String resourceLocation;
        output fmiModel fmi;
        external"C" fmi = wrapped83691741253950941_fmiInstantiateModel2(instanceName, loggingOn, resourceLocation)
        annotation(Include="
#ifndef wrapped83691741253950941_Instantiate_C
#define wrapped83691741253950941_Instantiate_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void wrapped83691741253950941Logger(fmi2ComponentEnvironment componentEnvironment, fmi2String instanceName, fmi2Status status,
  fmi2String category, fmi2String message, ...) {
  char msg[4096];
  char buf[4096];
  va_list ap;
  int len;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len < 4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmi2Fatal:
      ModelicaMessage(\"[fmi2Fatal]: \");
      break;
    case fmi2Error:
      ModelicaMessage(\"[fmi2Error]: \");
      break;
    case fmi2Discard:
      ModelicaMessage(\"[fmi2Discard]: \");
      break;
    case fmi2Warning:
      ModelicaMessage(\"[fmi2Warning]: \");
      break;
    case fmi2OK:
      ModelicaMessage(\"[fmi2OK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * wrapped83691741253950941_fmiInstantiateModel2(const char*instanceName, fmi2Boolean loggingOn, fmi2String resourceLocation) {
  static fmi2CallbackFunctions funcs = {&wrapped83691741253950941Logger, &calloc, &free, NULL, NULL};
  struct dy_fmi2Extended* res;
  res = calloc(1, sizeof(struct dy_fmi2Extended));
  if (res!=0) {
#ifdef _WIN32
    if (!(res->hInst=LoadLibraryW(L\"wrapped.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (wrapped.dll) failed!\");
#else
    if (!(res->hInst=LoadLibrary(\"wrapped.so\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (wrapped.so) failed!\");
#endif
      return 0;
    }
    if (!(res->dyFmiInstantiate=(fmi2InstantiateFunc)GetProcAddress(res->hInst,\"fmi2Instantiate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Instantiate!\");
      return 0;
    }
    if (!(res->dyFmiFreeInstance=(fmi2FreeInstanceFunc)GetProcAddress(res->hInst,\"fmi2FreeInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeInstance!\");
      return 0;
    }
    if (!(res->dyFmiSetupExperiment=(fmi2SetupExperimentFunc)GetProcAddress(res->hInst,\"fmi2SetupExperiment\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetupExperiment!\");
      return 0;
    }
    if (!(res->dyFmiEnterInitializationMode=(fmi2EnterInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2EnterInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiExitInitializationMode=(fmi2ExitInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2ExitInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2ExitInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmi2TerminateFunc)GetProcAddress(res->hInst,\"fmi2Terminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Terminate!\");
      return 0;
    }
    if (!(res->dyFmiReset=(fmi2ResetFunc)GetProcAddress(res->hInst,\"fmi2Reset\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Reset!\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmi2SetRealFunc)GetProcAddress(res->hInst,\"fmi2SetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmi2GetRealFunc)GetProcAddress(res->hInst,\"fmi2GetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmi2SetIntegerFunc)GetProcAddress(res->hInst,\"fmi2SetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmi2GetIntegerFunc)GetProcAddress(res->hInst,\"fmi2GetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmi2SetBooleanFunc)GetProcAddress(res->hInst,\"fmi2SetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmi2GetBooleanFunc)GetProcAddress(res->hInst,\"fmi2GetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmi2SetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmi2SetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetDebugLogging!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmi2SetStringFunc)GetProcAddress(res->hInst,\"fmi2SetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmi2GetStringFunc)GetProcAddress(res->hInst,\"fmi2GetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetString!\");
      return 0;
    }
    if(!(res->dyFmiDoStep=(fmi2DoStepFunc)GetProcAddress(res->hInst,\"fmi2DoStep\"))){
      ModelicaError(\"GetProcAddress failed for fmi2DoStep!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiDoStep\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiGetBooleanStatus=(fmi2GetBooleanStatusFunc)GetProcAddress(res->hInst,\"fmi2GetBooleanStatus\"))){
      ModelicaError(\"GetProcAddress failed for fmi2GetBooleanStatus!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiGetBooleanStatus\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiGetRealStatus=(fmi2GetRealStatusFunc)GetProcAddress(res->hInst,\"fmi2GetRealStatus\"))){
      ModelicaError(\"GetProcAddress failed for fmi2GetRealStatus!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiGetRealStatus\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    res->m=res->dyFmiInstantiate(instanceName, fmi2CoSimulation, \"8fd36fc91c7ea4b125f3aab950e94af1\",resourceLocation, &funcs, fmi2False, loggingOn);
    res->der = calloc(0,sizeof(double));
    res->out = calloc(4,sizeof(double));
    if (!res->m || !res->der && 0 || !res->out && 4 ) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {
      /*static const char* funcCalls = \"FunctionCalls\";*/
      /*res->dyFmiSetDebugLogging(res->m,fmi2True,1,&funcCalls);*/
      res->dyTriggered=0;
      res->dyTime=res->dyLastTime=-1e37;
      res->discreteInputChanged=1;
      res->currentMode=dyfmi2InstantiationMode;
      res->dyLastStepTime=0;
      res->dyFMUstate=NULL;
    }
  }
  return res;
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
        annotation (__Dymola_doNotLinkSharedObject=true,
            __Dymola_CriticalRegion="wrapped");
      end constructor;

      function destructor "Release storage of FMI model"
          extends Modelica.Icons.Function;
          input fmiModel fmi;
          external"C"
                     wrapped83691741253950941_fmiFreeModelInstance2(fmi)
          annotation (Include="
#ifndef wrapped83691741253950941_Free_C
#define wrapped83691741253950941_Free_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void wrapped83691741253950941_fmiFreeModelInstance2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    /*a->dyFmiSetDebugLogging(a->m,fmi2True,0,NULL);*/
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeInstance(a->m);
    FreeLibrary(a->hInst);
    free(a->der);a->der=0;
    free(a->out);a->out=0;
    free(a);
  }
}
#endif",       Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
        annotation(__Dymola_doNotLinkSharedObject=true,__Dymola_CriticalRegion = "wrapped");
      end destructor;
    end fmiModel;

    function  fmiDoStep
    input fmiModel fmi;
    input Real currentTime;
    input Real stepSize;
    input Real preAvailable;
    output Boolean stepOK;
    output Real postAvailable=preAvailable;
    external"C" stepOK= wrapped83691741253950941_fmiDoStep2(fmi, currentTime, stepSize)
      annotation (Include="
#ifndef wrapped83691741253950941_DoStep_C
#define wrapped83691741253950941_DoStep_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double wrapped83691741253950941_fmiDoStep2(void*m, double currentTime, double stepSize) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  fmi2Boolean value=fmi2False;
  if (a) {
    status=a->dyFmiDoStep(a->m, currentTime, stepSize, fmi2True);
    if(status==fmi2Discard){
      status = a->dyFmiGetBooleanStatus(a->m, fmi2Terminated, &value);
      if(value==fmi2True){
        double tt = 0;
        char s[64] = {0};
        fmi2Status stat2 = fmi2Error;
        stat2 = a->dyFmiGetRealStatus(a->m, fmi2LastSuccessfulTime, &tt);
#if defined(_MSC_VER) && _MSC_VER >= 1200
        if(stat2 == fmi2OK && _snprintf(s, sizeof(s)/sizeof(*s), \"Terminate signaled by the FMU at time %g\", tt) > 0){
#else
        if(stat2 == fmi2OK && snprintf(s, sizeof(s)/sizeof(*s), \"Terminate signaled by the FMU at time %g\", tt) > 0){
#endif
			terminate(s);
        }else{
          terminate(\"Terminate signaled by the FMU\");
        }
      }
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning){    ModelicaFormatError(\"The call of fmi2DoStep(%f, %f) failed in FMU\\r\\nNote: setting fmi_loggingOn in the FMU component may produce more information from the FMU.\",currentTime, stepSize);  }  return 1.0;
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiDoStep;

    function fmiReset
      input fmiModel fmi;
      output Boolean resetOK;
      external"C" resetOK = wrapped83691741253950941_fmiReset2(fmi)
      annotation (Include="
#ifndef wrapped83691741253950941_Reset_C
#define wrapped83691741253950941_Reset_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double wrapped83691741253950941_fmiReset2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiReset(a->m);
    a->currentMode=dyfmi2InstantiationMode;
    a->cpDer = 1;
    a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiReset failed\");
    return 1.0;
  }
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiReset;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef wrapped83691741253950941_GetReal_C
#define wrapped83691741253950941_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiGetReal;

    function fmiGetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real preAvailable;
      output Real vals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef wrapped83691741253950941_GetReal_C
#define wrapped83691741253950941_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiGetRealwf;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      external"C"
                 wrapped83691741253950941_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals)
        annotation (Include="
#ifndef wrapped83691741253950941_SetReal_C
#define wrapped83691741253950941_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    a->cpDer = 1;
    a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      input Real preAvailable;
      output Real postAvailable=preAvailable;
      external"C"
                 wrapped83691741253950941_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals)
        annotation (Include="
#ifndef wrapped83691741253950941_SetReal_C
#define wrapped83691741253950941_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    a->cpDer = 1;
    a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealwf;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef wrapped83691741253950941_GetInteger_C
#define wrapped83691741253950941_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiGetInteger;

    function fmiGetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Integer vals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef wrapped83691741253950941_GetInteger_C
#define wrapped83691741253950941_GetInteger_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void wrapped83691741253950941_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiGetIntegerwf;

    function fmiSetInteger
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals)
      annotation (Include="
#ifndef wrapped83691741253950941_SetInteger_C
#define wrapped83691741253950941_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed in SetInteger\");
      for( i = 0; i < nrefs; ++i){
        if(oldVals[i] != vals[i]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
      a->cpDer = 1;
      a->cpOut = 1;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiSetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
      input Integer preAvailable;
      output Integer postAvailable=preAvailable;
      external"C" wrapped83691741253950941_fmiSetInteger2wf(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef wrapped83691741253950941_SetIntegerwf_C
#define wrapped83691741253950941_SetIntegerwf_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiSetInteger2wf(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
      a->cpDer = 1;
      a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetIntegerwf;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals)
        annotation (Include="
#ifndef wrapped83691741253950941_GetBoolean_C
#define wrapped83691741253950941_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiGetBoolean;

    function fmiGetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Boolean vals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals)
        annotation (Include="
#ifndef wrapped83691741253950941_GetBoolean_C
#define wrapped83691741253950941_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiGetBooleanwf;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals)
        annotation (Include="
#ifndef wrapped83691741253950941_SetBoolean_C
#define wrapped83691741253950941_SetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals, int* dummy, int* oldVals) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(oldVals));
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed in SetBoolean\");
      for(j=nr-1;j>=0;j--){
        oldVals[j]=((fmi2Boolean*)(oldVals))[j];
        if(oldVals[j] != dummy[j]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
      a->cpDer = 1;
      a->cpOut = 1;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetString
      input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef wrapped83691741253950941_SetString_C
#define wrapped83691741253950941_SetString_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiSetString2(void*m, const int*refs, size_t nrefs,const fmi2String vals[]) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    a->discreteInputChanged = fmi2True;
    a->cpDer = 1;
    a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetString failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiSetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
      input Integer preAvailable;
      output Integer postAvailable=preAvailable;
    protected
      Boolean dummy[size(refs, 1)];
      external"C" wrapped83691741253950941_fmiSetBoolean2wf(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy)
        annotation (Include="
#ifndef wrapped83691741253950941_SetBooleanwf_C
#define wrapped83691741253950941_SetBooleanwf_C 1
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiSetBoolean2wf(void*m, const int* refs, size_t nr, const int* vals, int* dummy) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
      a->cpDer = 1;
      a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetBooleanwf;

    function GetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1]);
      annotation(LateInline=true);
    end GetRealVariable;

    function GetRealVariable2
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Integer outputIndex;
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetOutput(fmi,outputIndex);
      annotation(LateInline=true);
    end GetRealVariable2;

    function GetRealDerVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Integer outputIndex;
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetDerivatives2(fmi,outputIndex);
      annotation(LateInline=true);
    end GetRealDerVariable;

    function fmiEnterSlaveInitializationMode
      input fmiModel fmi;
      input Boolean setTolerance;
      input Real relativeTolerance;
      input Real tStart;
      input Boolean forceShutDownAtTStop;
      input Real tStop;
      input Real preAvailable;
      output Real postAvailable = preAvailable;
      external"C" wrapped83691741253950941_fmiEnterSlaveInitializationMode2(fmi, setTolerance, relativeTolerance, tStart, forceShutDownAtTStop, tStop)
      annotation (Include="
#ifndef wrapped83691741253950941_fmiEnterSlaveInitializationMode_C
#define wrapped83691741253950941_fmiEnterSlaveInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiEnterSlaveInitializationMode2(void*m, int setTolerance, double relativeTolerance, double tStart, int forceShutDownAtTStop, double tStop) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode==dyfmi2InstantiationMode){
      status=a->dyFmiSetupExperiment(a->m, setTolerance, relativeTolerance, tStart, forceShutDownAtTStop, tStop);
      status=a->dyFmiEnterInitializationMode(a->m);
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->currentMode=dyfmi2InitializationMode;
    }else{
      status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"InitializeSlave failed\");
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiEnterSlaveInitializationMode;

    function fmiExitSlaveInitializationMode
      input fmiModel fmi;
      input Real preAvailable;
      output Real postAvailable = preAvailable;
      external"C" wrapped83691741253950941_fmiExitSlaveInitializationMode2(fmi)
      annotation (Include="
#ifndef wrapped83691741253950941_fmiExitSlaveInitializationMode_C
#define wrapped83691741253950941_fmiExitSlaveInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void wrapped83691741253950941_fmiExitSlaveInitializationMode2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode==dyfmi2InitializationMode){
      status=a->dyFmiExitInitializationMode(a->m);
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->currentMode = dyfmi2EventMode;
    }else{status = fmi2OK;}
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiExitModelInitialization failed!\");
  return;
}
#endif", Library="wrapped", LibraryDirectory="modelica://wrapped_fmu/Resources/Library/FMU/wrapped/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="wrapped",
        __Dymola_LockExternalObject=true);
    end fmiExitSlaveInitializationMode;
end fmi_Functions;
initial equation
equation
  when initial() then
    fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_resourceLocation);
  end when;
initial algorithm
  fmi_Functions.fmiSetReal(fmi, {38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 2, 18, 17, 14, 13, 12, 16, 15, 20, 19, 28, 29, 22, 21, 23, 24, 25, 26, 27, 33, 34, 36, 35, 37, 32, 30, 31, 3, 9, 10, 11, 4, 5, 7, 6, 8}, {_block_jacobian_check_tol, _cs_rel_tol, _cs_step_size, _events_default_tol, _events_tol_factor, _nle_jacobian_finite_difference_delta, _nle_solver_default_tol, _nle_solver_max_residual_scaling_factor, _nle_solver_min_residual_scaling_factor, _nle_solver_min_tol, _nle_solver_regularization_tolerance, _nle_solver_step_limit_factor, _nle_solver_tol_factor, _time_events_default_tol, 'mod'.cap.C, 'mod'.con.Nd, 'mod'.con.Ni, 'mod'.con.Td, 'mod'.con.Ti, 'mod'.con.k, 'mod'.con.wd, 'mod'.con.wp, 'mod'.con.xd_start, 'mod'.con.xi_start, 'mod'.con.Dzero.k, 'mod'.con.Izero.k, 'mod'.con.P.k, 'mod'.con.addP.k2, 'mod'.con.addPID.k1, 'mod'.con.addPID.k2, 'mod'.con.addPID.k3, 'mod'.con.limiter.uMax, 'mod'.con.limiter.uMin, 'mod'.conCO2.amplitude, 'mod'.conCO2.freqHz, 'mod'.conCO2.offset, 'mod'.conCO2.phase, 'mod'.conCO2.startTime, 'mod'.eff.k, 'mod'.preHeat.T_ref, 'mod'.preHeat.alpha, 'mod'.res.R, 'mod'.set.height, 'mod'.set.offset, 'mod'.set.startTime, 'mod'.souTOut.amplitude, 'mod'.souTOut.freqHz, 'mod'.souTOut.offset, 'mod'.souTOut.phase, 'mod'.souTOut.startTime});
  fmi_Functions.fmiSetInteger(fmi, {268435513, 268435514, 268435515, 268435516, 268435517, 268435518, 268435519, 268435520, 268435521, 268435522, 268435523, 268435524}, {_block_solver_experimental_mode, _cs_experimental_mode, _cs_solver, _iteration_variable_scaling, _log_level, _nle_active_bounds_mode, _nle_jacobian_calculation_mode, _nle_jacobian_update_mode, _nle_solver_exit_criterion, _nle_solver_max_iter, _nle_solver_max_iter_no_jacobian, _residual_equation_scaling});
  fmi_Functions.fmiSetBoolean(fmi, {536870986, 536870987, 536870988, 536870989, 536870990, 536870991, 536870992, 536870993, 536870994, 536870995, 536870996, 536870997, 536870998}, {_block_jacobian_check, _block_solver_profiling, _enforce_bounds, _nle_brent_ignore_error, _nle_solver_check_jac_cond, _nle_solver_use_last_integrator_step, _nle_solver_use_nominals_as_fallback, _rescale_after_singular_jac, _rescale_each_step, _runtime_log_to_file, _use_Brent_in_1d, _use_jacobian_equilibration, _use_newton_for_brent});
  fmi_Functions.fmiSetString(fmi, {805306372, 805306373, 805306371, 805306369, 805306370, 805306368}, {'mod'.CO2RooAir.description, 'mod'.CO2RooAir.zone, 'mod'.PHea.description, 'mod'.TRooAir.description, 'mod'.TRooAir.zone, 'mod'.oveAct.description});
  fmi_Functions.fmiSetReal(fmi, {90, 96, 100}, {'mod'.cap._T_start, 'mod'.cap._der_T_start, 'mod'.preTOut.port._T_start});
    fmi_Functions.fmiEnterSlaveInitializationMode(fmi, fmi_setTol, fmi_rTol, fmi_StartTime, fmi_forceShutDownAtStopTime, fmi_StopTime, 1);
  fmi_rdum := 1;
  fmi_idum := 1;
  myTimeStart :=time;
    fmi_Functions.fmiSetBoolean(fmi, {536871029}, {_oveAct_activate_start});
    fmi_Functions.fmiSetReal(fmi, {91}, {_oveAct_u_start});
algorithm
assert(fmi_CommunicationStepSize > 0.0,"The parameter fmi_CommunicationStepSize has an invalid value, please set a positive value larger than 0.0");
  when {initial(), sample(fmi_StartTime, fmi_CommunicationStepSize)} then
    if fmi_InputTime then
      fmi_Functions.fmiSetBoolean(fmi, {536871029}, {_oveAct_activate_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetBoolean(fmi, {536871029}, {pre(oveAct_activate)});
      else
        fmi_Functions.fmiSetBoolean(fmi, {536871029}, {oveAct_activate});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {91}, {_oveAct_u_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(fmi, {91}, {pre(oveAct_u)});
      else
        fmi_Functions.fmiSetReal(fmi, {91}, {oveAct_u});
      end if;
    end if;
      if fmi_rdum > 0  and fmi_idum > 0 and not fmi_exitInit and not initial() then
        fmi_Functions.fmiExitSlaveInitializationMode(fmi, 1);
        fmi_exitInit:=true;
      end if;
    if time>=fmi_CommunicationStepSize +fmi_StartTime then
      for stepSizeIndex in 1:stepSizeScaleFactor loop
        fmi_StepOK :=fmi_Functions.fmiDoStep(
          fmi,
          time + (stepSizeIndex - 1 - stepSizeScaleFactor)*
            fmi_CommunicationStepSize/stepSizeScaleFactor,
          fmi_CommunicationStepSize/stepSizeScaleFactor,
          1);
      end for;
      fmi_flip :=not pre(fmi_flip);
    end if;
    if not initial() then
  internal.CO2RooAir_y :=fmi_Functions.fmiGetRealScalar(fmi, 92);
  internal.PHea_y :=fmi_Functions.fmiGetRealScalar(fmi, 93);
  internal.TRooAir_y :=fmi_Functions.fmiGetRealScalar(fmi, 94);
  internal.oveAct_y :=fmi_Functions.fmiGetRealScalar(fmi, 95);
    end if;
RealVariables :=fmi_Functions.fmiGetReal(fmi, {113,111,112,90,89,96,97,101,106,
      107,102,103,105,104,110,108,109,134217826,100,98,99});
BooleanVariables :=fmi_Functions.fmiGetBoolean(fmi, {536871028});
  end when;
  when {pre(fmi_flip), not pre(fmi_flip)} then
    _oveAct_activate_old := pre(oveAct_activate);
    _oveAct_u_old := pre(oveAct_u);
  end when;
equation
  if initial() then
    CO2RooAir_y = fmi_Functions.GetRealVariable(fmi,myTimeStart, {'mod'.conCO2.amplitude, 'mod'.conCO2.freqHz, 'mod'.conCO2.offset, 'mod'.conCO2.phase, 'mod'.conCO2.startTime}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {33, 34, 36, 35, 37}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {92});
  else
    CO2RooAir_y = internal.CO2RooAir_y;
  end if;
  if initial() then
    PHea_y = fmi_Functions.GetRealVariable(fmi,myTimeStart, {'mod'.con.Dzero.k, 'mod'.con.Izero.k, 'mod'.con.P.k, 'mod'.con.addP.k2, 'mod'.con.addPID.k1, 'mod'.con.addPID.k2, 'mod'.con.addPID.k3, 'mod'.con.k, 'mod'.con.limiter.uMax, 'mod'.con.limiter.uMin, 'mod'.con.wp, 'mod'.eff.k, 'mod'.set.height, 'mod'.set.offset, 'mod'.set.startTime, oveAct_u}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {oveAct_activate}, fill(0,0), {28, 29, 22, 21, 23, 24, 25, 12, 26, 27, 15, 32, 9, 10, 11, 91}, fill(0,0), fill(0,0), {536871029}, fill(0,0), {93});
  else
    PHea_y = internal.PHea_y;
  end if;
  if initial() then
    TRooAir_y = fmi_Functions.GetRealVariable(fmi,myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {94});
  else
    TRooAir_y = internal.TRooAir_y;
  end if;
  if initial() then
    oveAct_y = fmi_Functions.GetRealVariable(fmi,myTimeStart, {'mod'.con.Dzero.k, 'mod'.con.Izero.k, 'mod'.con.P.k, 'mod'.con.addP.k2, 'mod'.con.addPID.k1, 'mod'.con.addPID.k2, 'mod'.con.addPID.k3, 'mod'.con.k, 'mod'.con.limiter.uMax, 'mod'.con.limiter.uMin, 'mod'.con.wp, 'mod'.set.height, 'mod'.set.offset, 'mod'.set.startTime, oveAct_u}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {oveAct_activate}, fill(0,0), {28, 29, 22, 21, 23, 24, 25, 12, 26, 27, 15, 9, 10, 11, 91}, fill(0,0), fill(0,0), {536871029}, fill(0,0), {95});
  else
    oveAct_y = internal.oveAct_y;
  end if;
initial equation
RealDependentParameters = fmi_Functions.fmiGetRealwf(fmi, {55, 56, 53, 54},fmi_rdum);
equation
  'mod'.CO2RooAir.u = RealVariables[1];
  'mod'.PHea.u = RealVariables[2];
  'mod'.'abs'.u = RealVariables[3];
  'mod'.cap.T = RealVariables[4];
  'mod'.cap._T_der = RealVariables[5];
  'mod'.cap.der_T = RealVariables[6];
  'mod'.cap.port.Q_flow = RealVariables[7];
  'mod'.con.controlError = RealVariables[8];
  'mod'.con.u_s = RealVariables[9];
  'mod'.con.y = RealVariables[10];
  'mod'.con.P.u = RealVariables[11];
  'mod'.con.P.y = RealVariables[12];
  'mod'.con.addPID.y = RealVariables[13];
  'mod'.con.gainPID.y = RealVariables[14];
  'mod'.eff.u = RealVariables[15];
  'mod'.oveAct.swi.u1 = RealVariables[16];
  'mod'.preHeat.port.Q_flow = RealVariables[17];
  'mod'.preTOut.port.Q_flow = RealVariables[18];
  'mod'.preTOut.port.T = RealVariables[19];
  'mod'.res.Q_flow = RealVariables[20];
  'mod'.res.dT = RealVariables[21];
  'mod'.con.Dzero.y = RealDependentParameters[1];
  'mod'.con.Izero.y = RealDependentParameters[2];
  'mod'.con.addP.k1 = RealDependentParameters[3];
  'mod'.con.gainPID.k = RealDependentParameters[4];
  'mod'.oveAct.activate.y = BooleanVariables[1];
//alias Declarations
initial equation
  'mod'.con.addPID.u2 = 'mod'.con.Dzero.y;
  'mod'.con.addPID.u3 = 'mod'.con.Izero.y;
equation
  'mod'.preTOut.T = 'mod'.preTOut.port.T;
  'mod'.res.port_a.T = 'mod'.preTOut.port.T;
  'mod'.souTOut.y = 'mod'.preTOut.port.T;
  'mod'.con.addP.y = 'mod'.con.P.u;
  'mod'.con.addPID.u1 = 'mod'.con.P.y;
  'mod'.con.limiter.u = 'mod'.con.gainPID.y;
  'mod'.con.gainPID.u = 'mod'.con.addPID.y;
  'mod'.con.addP.u1 = 'mod'.con.u_s;
  'mod'.set.y = 'mod'.con.u_s;
  'mod'.con.limiter.y = 'mod'.con.y;
  'mod'.oveAct.u = 'mod'.con.y;
  'mod'.oveAct.swi.u3 = 'mod'.con.y;
  'mod'.oveAct.uExt.y = 'mod'.oveAct.swi.u1;
  'mod'.oveAct.y = 'mod'.eff.u;
  'mod'.oveAct.swi.y = 'mod'.eff.u;
  'mod'.preHeat.Q_flow = 'mod'.eff.u;
  'mod'.PHea.y = 'mod'.PHea.u;
  'mod'.'abs'.y = 'mod'.PHea.u;
  'mod'.eff.y = 'mod'.'abs'.u;
  'mod'.CO2RooAir.y = 'mod'.CO2RooAir.u;
  'mod'.conCO2.y = 'mod'.CO2RooAir.u;
  'mod'.res.port_b.Q_flow = 'mod'.preTOut.port.Q_flow;
  'mod'.TRooAir.u = 'mod'.cap.T;
  'mod'.TRooAir.y = 'mod'.cap.T;
  'mod'.cap.port.T = 'mod'.cap.T;
  'mod'.con.u_m = 'mod'.cap.T;
  'mod'.con.addP.u2 = 'mod'.cap.T;
  'mod'.preHeat.port.T = 'mod'.cap.T;
  'mod'.res.port_b.T = 'mod'.cap.T;
  'mod'.senTZone.T = 'mod'.cap.T;
  'mod'.senTZone.port.T = 'mod'.cap.T;
  'mod'.res.port_a.Q_flow = 'mod'.res.Q_flow;
  'mod'.oveAct.swi.u2 = 'mod'.oveAct.activate.y;
  annotation (__Dymola_FMUImportVersion="Dymola 2023x", __Dymola_FMUImportPath="C:/Users/ASUS/Desktop/FDD/git_Boptest/project1-boptest-master/testcases/testcase1/models/wrapped.fmu", __Dymola_FMUImportIncludeAllVariables="true", __Dymola_FMUImportIntegrate="true", __Dymola_FMUResourcePath="Resources/Library/FMU/wrapped", __Dymola_canBeInstantiatedOnlyOncePerProcess=true,    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 2.0 CS")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 2.0</li>
<li>modelName = wrapped</li>
<li>generationTool = JModelica.org</li>
<li>generationDateAndTime = 2023-10-03T12:24:55</li>
</ul>
<p><br><b>Co-Simulation Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>canHandleVariableCommunicationStepSize = true</li>
<li>canInterpolateInputs = true</li>
<li>maxOutputDerivativeOrder = 0</li>
<li>canRunAsynchronuously = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = true</li>
<li>canNotUseMemoryManagementFunctions = false</li>
<li>canGetAndSetFMUstate = false</li>
<li>canSerializeFMUstate = false</li>
<li>providesDirectionalDerivative = false</li>
</ul>
</html>"));
end wrapped_fmu;

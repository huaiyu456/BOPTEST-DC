within ;
model SimpleRC22_fmu
  "A simple thermal R1C1 model with sinusoidal outside air temperature and a feedback controlled heater."
extends fmuIcon;
// Model automatically generated by Dymola from FMI model description
public
encapsulated package importedFMUTypes
  type Modelica_Blocks_Interfaces_BooleanInput = Boolean;
  type Modelica_Blocks_Interfaces_BooleanOutput = Boolean;
  type Modelica_Blocks_Interfaces_RealInput = Real;
  type Modelica_Blocks_Interfaces_RealOutput = Real;
  type Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs =
        enumeration(                                                                  None "Not used for KPI",
        AirZoneTemperature "Air zone temperature",
        RadiativeZoneTemperature "Radiative zone temperature",
        OperativeZoneTemperature "Operative zone temperature",
        RelativeHumidity "Relative humidity",
        CO2Concentration "CO2 concentration",
        ElectricPower "Electric power from grid",
        DistrictHeatingPower "Thermal power from district heating",
        GasPower "Thermal power from natural gas",
        BiomassPower "Thermal power from biomass",
        SolarThermalPower "Thermal power from solar thermal",
        FreshWaterFlowRate "FreshWaterFlowRate");
end importedFMUTypes;
protected

  record cap_rec
    parameter Modelica.Units.SI.HeatCapacity C = 1000000.0 "Heat capacity of element (= cp*m)";
    parameter Modelica.Units.SI.Temperature _T_start = 293.15
    annotation(Dialog(tab = "Initial", group = "States"));
    Modelica.Units.SI.Temperature T(start = _T_start) "Temperature of element";
    Modelica.Units.SI.TemperatureSlope der_T "Time derivative of temperature (= der(T))";
  protected
    record port_rec
      Modelica.Units.SI.Temperature T "Port temperature";
      Modelica.Units.SI.HeatFlowRate Q_flow "Heat flow rate (positive if flowing from outside into the component)";
    end port_rec;
  public
    port_rec port;
  end cap_rec;
public
  cap_rec cap annotation(Dialog);
protected
  record res_rec
    Modelica.Units.SI.HeatFlowRate Q_flow "Heat flow rate from port_a -> port_b";
    Modelica.Units.SI.TemperatureDifference dT "port_a.T - port_b.T";
    parameter Modelica.Units.SI.ThermalResistance R = 0.01 "Constant thermal resistance of material";
  protected
    record port_a_rec
      Modelica.Units.SI.Temperature T "Port temperature";
      Modelica.Units.SI.HeatFlowRate Q_flow "Heat flow rate (positive if flowing from outside into the component)";
    end port_a_rec;
  public
    port_a_rec port_a;
  protected
    record port_b_rec
      Modelica.Units.SI.Temperature T "Port temperature";
      Modelica.Units.SI.HeatFlowRate Q_flow "Heat flow rate (positive if flowing from outside into the component)";
    end port_b_rec;
  public
    port_b_rec port_b;
  end res_rec;
public
  res_rec res annotation(Dialog);
protected
  record senTZone_rec
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput T(unit = "K") "Absolute temperature as output signal";
  protected
    record port_rec
      Modelica.Units.SI.Temperature T "Port temperature";
      constant Modelica.Units.SI.HeatFlowRate Q_flow = 0 "Heat flow rate (positive if flowing from outside into the component)";
    end port_rec;
  public
    port_rec port;
  end senTZone_rec;
public
  senTZone_rec senTZone;
protected
  record preTOut_rec
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput T(unit = "K");
  protected
    record port_rec
      Modelica.Units.SI.Temperature T "Port temperature";
      Modelica.Units.SI.HeatFlowRate Q_flow "Heat flow rate (positive if flowing from outside into the component)";
    end port_rec;
  public
    port_rec port;
  end preTOut_rec;
public
  preTOut_rec preTOut;
protected
  record souTOut_rec
    parameter Real amplitude = 10 "Amplitude of sine wave";
    parameter Modelica.Units.SI.Frequency f = 1.1574074074074073E-05 "Frequency of sine wave";
    parameter Modelica.Units.SI.Angle phase = 0 "Phase of sine wave";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    parameter Real offset = 293.15 "Offset of output signal y";
    parameter Modelica.Units.SI.Time startTime = 0 "Output y = offset for time < startTime";
  end souTOut_rec;
public
  souTOut_rec souTOut annotation(Dialog);
protected
  record set_rec
    parameter Real height = 2 "Height of step";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    parameter Real offset = 293.15 "Offset of output signal y";
    parameter Modelica.Units.SI.Time startTime = 86400 "Output y = offset for time < startTime";
  end set_rec;
public
  set_rec set annotation(Dialog);
protected
  record con_rec
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u_s "Connector of setpoint input signal";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u_m "Connector of measurement input signal";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y(min = -10000.0, max = 10000.0) "Connector of actuator output signal";
    Real controlError "Control error (set point - measurement)";
    constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.P "Type of controller";
    parameter Real k(min = 0.0) = 2000 "Gain of controller";
    parameter Modelica.Units.SI.Time Ti(min = 1E-60) = 0.5 "Time constant of Integrator block";
    parameter Modelica.Units.SI.Time Td(min = 0.0) = 0.1 "Time constant of Derivative block";
    parameter Real yMax = 100000 "Upper limit of output";
    parameter Real yMin = 0 "Lower limit of output";
    parameter Real wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
    parameter Real wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
    parameter Real Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
    parameter Real Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
    constant Boolean withFeedForward = false "Use feed-forward input?";
    parameter Real kFF = 1 "Gain of feed-forward input";
    constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
    parameter Real xi_start = 0 "Initial or guess value for integrator output (= integrator state)";
    parameter Real xd_start = 0 "Initial or guess value for state of derivative block";
    parameter Real y_start = 0 "Initial value of output";
    constant Modelica.Blocks.Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
    constant Boolean strict = false "= true, if strict limits with noEvent(..)";
  protected
    record addP_rec
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      Real k1 "Gain of input signal 1";
      parameter Real k2 = -1 "Gain of input signal 2";
    end addP_rec;
  public
    addP_rec addP annotation(Dialog);
  protected
    record P_rec
      parameter Real k = 1 "Gain value multiplied with input signal";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
    end P_rec;
  public
    P_rec P annotation(Dialog);
  protected
    record gainPID_rec
      Real k "Gain value multiplied with input signal";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
    end gainPID_rec;
  public
    gainPID_rec gainPID;
  protected
    record addPID_rec
      parameter Real k1 = 1 "Gain of input signal 1";
      parameter Real k2 = 1 "Gain of input signal 2";
      parameter Real k3 = 1 "Gain of input signal 3";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end addPID_rec;
  public
    addPID_rec addPID annotation(Dialog);
  protected
    record limiter_rec
      Real uMax "Upper limits of input signals";
      Real uMin "Lower limits of input signals";
      constant Boolean strict = false "= true, if strict limits with noEvent(..)";
      constant Modelica.Blocks.Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end limiter_rec;
  public
    limiter_rec limiter;
  protected
    record Dzero_rec
      parameter Real k = 0 "Constant output value";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end Dzero_rec;
  public
    Dzero_rec Dzero annotation(Dialog);
  protected
    record Izero_rec
      parameter Real k = 0 "Constant output value";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end Izero_rec;
  public
    Izero_rec Izero annotation(Dialog);
  protected
    record FFzero_rec
      parameter Real k = 0 "Constant output value";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end FFzero_rec;
  public
    FFzero_rec FFzero annotation(Dialog);
  protected
    record addFF_rec
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      parameter Real k1 = 1 "Gain of input signal 1";
      Real k2 "Gain of input signal 2";
    end addFF_rec;
  public
    addFF_rec addFF annotation(Dialog);
  end con_rec;
public
  con_rec con annotation(Dialog);
protected
  record oveAct_rec
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u(unit = "W", min = -10000.0, max = 10000.0) "Connector of Real input signal";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    constant Boolean boptestOverwrite = true "Parameter that is used by tools to search for overwrite block in models";
  protected
    record swi_rec
      constant importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u1 = 0.0 "Connector of first Real input signal";
      constant importedFMUTypes.Modelica_Blocks_Interfaces_BooleanInput u2 = false "Connector of Boolean input signal";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end swi_rec;
  public
    swi_rec swi;
  protected
    record uExt_rec
      constant importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y = 0.0 "Value of Real output";
    end uExt_rec;
  public
    uExt_rec uExt;
  protected
    record activate_rec
      constant importedFMUTypes.Modelica_Blocks_Interfaces_BooleanOutput y = false "Value of Boolean output";
    end activate_rec;
  public
    activate_rec activate;
  end oveAct_rec;
public
  oveAct_rec oveAct;
protected
  record preHeat_rec
    parameter Modelica.Units.SI.Temperature T_ref = 293.15 "Reference temperature";
    parameter Modelica.Units.SI.LinearTemperatureCoefficient alpha = 0 "Temperature coefficient of heat flow rate";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput Q_flow(unit = "W");
  protected
    record port_rec
      Modelica.Units.SI.Temperature T "Port temperature";
      Modelica.Units.SI.HeatFlowRate Q_flow "Heat flow rate (positive if flowing from outside into the component)";
    end port_rec;
  public
    port_rec port;
  end preHeat_rec;
public
  preHeat_rec preHeat annotation(Dialog);
protected
  record eff_rec
    parameter Real k = 1.0101010101010102 "Gain value multiplied with input signal";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
  end eff_rec;
public
  eff_rec eff annotation(Dialog);
protected
  record TRooAir_rec
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y(unit = "K") "Connector of Real output signal";
    constant importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs KPIs = importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs.AirZoneTemperature "Tag with the type of signal for the calculation of the KPIs";
    constant Boolean boptestRead = true "Parameter that is used by tools to search for read block in models";
  end TRooAir_rec;
public
  TRooAir_rec TRooAir;
protected
  record PHea_rec
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Connector of Real output signal";
    constant importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs KPIs = importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs.GasPower "Tag with the type of signal for the calculation of the KPIs";
    constant Boolean boptestRead = true "Parameter that is used by tools to search for read block in models";
  end PHea_rec;
public
  PHea_rec PHea;
protected
  record 'abs_rec'
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    constant Boolean generateEvent = false "Choose whether events shall be generated";
  end 'abs_rec';
public
  'abs_rec' 'abs';
protected
  record CO2RooAir_rec
    importedFMUTypes.Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    constant importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs KPIs = importedFMUTypes.Buildings_Utilities_IO_SignalExchange_SignalTypes_SignalsForKPIs.CO2Concentration "Tag with the type of signal for the calculation of the KPIs";
    constant Boolean boptestRead = true "Parameter that is used by tools to search for read block in models";
  end CO2RooAir_rec;
public
  CO2RooAir_rec CO2RooAir;
protected
  record conCO2_rec
    parameter Real amplitude = 250 "Amplitude of sine wave";
    parameter Modelica.Units.SI.Frequency f = 1.1574074074074073E-05 "Frequency of sine wave";
    parameter Modelica.Units.SI.Angle phase = 0 "Phase of sine wave";
    importedFMUTypes.Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    parameter Real offset = 750 "Offset of output signal y";
    parameter Modelica.Units.SI.Time startTime = 0 "Output y = offset for time < startTime";
  end conCO2_rec;
public
  conCO2_rec conCO2 annotation(Dialog);
  Modelica.Blocks.Interfaces.RealOutput CPUtime(unit = "s")
  annotation (Placement(transformation(extent={{100,14},{140,54}})));
  Modelica.Blocks.Interfaces.RealOutput EventCounter
  annotation (Placement(transformation(extent={{100,-53},{140,-13}})));
public
  parameter String fmi_instanceName="SimpleRC22_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  parameter Real fmi_StartTime = 0.0
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_StopTime = 60.0
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_NumberOfSteps = 500
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_CommunicationStepSize=(fmi_StopTime-fmi_StartTime)/fmi_NumberOfSteps
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Integer stepSizeScaleFactor = 1 "Number of doSteps called between two CommunicationStepSize"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Boolean fmi_forceShutDownAtStopTime=false
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Boolean fmi_setTol=false "Set the tolerance fmi_rTol in fmi2SetupExperiment, if false fmu defautl tolerence will be used."
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_rTol=1E-06 "Relative tolerance for the internal solver of the fmu"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter String fmi_resourceLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/resources")
  annotation (Dialog(tab="FMI", group="Instantiation"));
protected
  fmi_Functions.fmiModel fmi;
  Boolean fmi_exitInit(start=false,fixed=true);
  parameter Real fmi_rdum(start=0,fixed=false);
  parameter Integer fmi_idum(start=0,fixed=false);
  Boolean fmi_StepOK;
  parameter Real zeroOffset = 0;
  parameter Real myTimeStart(fixed=false);
  record 'Internal '
    Real CPUtime;
    Real EventCounter;
  end 'Internal ';
  'Internal ' internal;
Real RealVariables[19];
Real RealFixedLocal[8];
  parameter String fmi_xNames[1] ={"cap.T"};
  parameter Integer fmi_xVrs[1] ={33554432};
  parameter String fmi_dxNames[1] ={"der(cap.T)"};
  parameter Integer fmi_dxVrs[1] ={587202560};
  parameter String fmi_uNames[0] =fill("",0);
  parameter Integer fmi_uVrs[0] =fill(0,0);
  parameter String fmi_yNames[2] ={"CPUtime", "EventCounter"};
  parameter Integer fmi_yVrs[2] ={67108864, 67108865};
package fmi_Functions
    class fmiModel
      extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        input String resourceLocation;
        output fmiModel fmi;
        external"C" fmi = SimpleRC2202929504448986350884_fmiInstantiateModel2(instanceName, loggingOn, resourceLocation)
        annotation(Include="
#ifndef SimpleRC2202929504448986350884_Instantiate_C
#define SimpleRC2202929504448986350884_Instantiate_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void SimpleRC2202929504448986350884Logger(fmi2ComponentEnvironment componentEnvironment, fmi2String instanceName, fmi2Status status,
  fmi2String category, fmi2String message, ...) {
  char msg[4096];
  char buf[4096];
  va_list ap;
  int len;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len < 4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmi2Fatal:
      ModelicaMessage(\"[fmi2Fatal]: \");
      break;
    case fmi2Error:
      ModelicaMessage(\"[fmi2Error]: \");
      break;
    case fmi2Discard:
      ModelicaMessage(\"[fmi2Discard]: \");
      break;
    case fmi2Warning:
      ModelicaMessage(\"[fmi2Warning]: \");
      break;
    case fmi2OK:
      ModelicaMessage(\"[fmi2OK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * SimpleRC2202929504448986350884_fmiInstantiateModel2(const char*instanceName, fmi2Boolean loggingOn, fmi2String resourceLocation) {
  static fmi2CallbackFunctions funcs = {&SimpleRC2202929504448986350884Logger, &calloc, &free, NULL, NULL};
  struct dy_fmi2Extended* res;
  res = calloc(1, sizeof(struct dy_fmi2Extended));
  if (res!=0) {
#ifdef _WIN32
    if (!(res->hInst=LoadLibraryW(L\"SimpleRC22.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (SimpleRC22.dll) failed!\");
#else
    if (!(res->hInst=LoadLibrary(\"SimpleRC22.so\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (SimpleRC22.so) failed!\");
#endif
      return 0;
    }
    if (!(res->dyFmiInstantiate=(fmi2InstantiateFunc)GetProcAddress(res->hInst,\"fmi2Instantiate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Instantiate!\");
      return 0;
    }
    if (!(res->dyFmiFreeInstance=(fmi2FreeInstanceFunc)GetProcAddress(res->hInst,\"fmi2FreeInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeInstance!\");
      return 0;
    }
    if (!(res->dyFmiSetupExperiment=(fmi2SetupExperimentFunc)GetProcAddress(res->hInst,\"fmi2SetupExperiment\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetupExperiment!\");
      return 0;
    }
    if (!(res->dyFmiEnterInitializationMode=(fmi2EnterInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2EnterInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiExitInitializationMode=(fmi2ExitInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2ExitInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2ExitInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmi2TerminateFunc)GetProcAddress(res->hInst,\"fmi2Terminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Terminate!\");
      return 0;
    }
    if (!(res->dyFmiReset=(fmi2ResetFunc)GetProcAddress(res->hInst,\"fmi2Reset\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Reset!\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmi2SetRealFunc)GetProcAddress(res->hInst,\"fmi2SetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmi2GetRealFunc)GetProcAddress(res->hInst,\"fmi2GetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmi2SetIntegerFunc)GetProcAddress(res->hInst,\"fmi2SetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmi2GetIntegerFunc)GetProcAddress(res->hInst,\"fmi2GetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmi2SetBooleanFunc)GetProcAddress(res->hInst,\"fmi2SetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmi2GetBooleanFunc)GetProcAddress(res->hInst,\"fmi2GetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmi2SetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmi2SetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetDebugLogging!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmi2SetStringFunc)GetProcAddress(res->hInst,\"fmi2SetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmi2GetStringFunc)GetProcAddress(res->hInst,\"fmi2GetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetString!\");
      return 0;
    }
    if(!(res->dyFmiDoStep=(fmi2DoStepFunc)GetProcAddress(res->hInst,\"fmi2DoStep\"))){
      ModelicaError(\"GetProcAddress failed for fmi2DoStep!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiDoStep\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiGetBooleanStatus=(fmi2GetBooleanStatusFunc)GetProcAddress(res->hInst,\"fmi2GetBooleanStatus\"))){
      ModelicaError(\"GetProcAddress failed for fmi2GetBooleanStatus!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiGetBooleanStatus\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiGetRealStatus=(fmi2GetRealStatusFunc)GetProcAddress(res->hInst,\"fmi2GetRealStatus\"))){
      ModelicaError(\"GetProcAddress failed for fmi2GetRealStatus!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiGetRealStatus\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if (!(res->dyFmiGetDirectionalDerivative=(fmi2GetDirectionalDerivativeFunc)GetProcAddress(res->hInst,\"fmi2GetDirectionalDerivative\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDirectionalDerivative!\");
      return 0;
    }
    if (!(res->dyFmiGetFMUstate=(fmi2GetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2GetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSetFMUstate=(fmi2SetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiFreeFMUstate=(fmi2FreeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2FreeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSerializedFMUstateSize=(fmi2SerializedFMUstateSizeFunc)GetProcAddress(res->hInst,\"fmi2SerializedFMUstateSize\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializedFMUstateSize!\");
      return 0;
    }
    if (!(res->dyFmiSerializeFMUstate=(fmi2SerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiDeSerializeFMUstate=(fmi2DeSerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2DeSerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2DeSerializeFMUstate!\");
      return 0;
    }
    res->m=res->dyFmiInstantiate(instanceName, fmi2CoSimulation, \"{029295fe-be04-448f-b986-3abd50b884ef}\",resourceLocation, &funcs, fmi2False, loggingOn);
    res->der = calloc(1,sizeof(double));
    res->out = calloc(2,sizeof(double));
    if (!res->m || !res->der && 1 || !res->out && 2 ) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {
      /*static const char* funcCalls = \"FunctionCalls\";*/
      /*res->dyFmiSetDebugLogging(res->m,fmi2True,1,&funcCalls);*/
      res->dyTriggered=0;
      res->dyTime=res->dyLastTime=-1e37;
      res->discreteInputChanged=1;
      res->currentMode=dyfmi2InstantiationMode;
      res->dyLastStepTime=0;
      res->dyFMUstate=NULL;
    }
  }
  return res;
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
        annotation (__Dymola_doNotLinkSharedObject=true,
            __Dymola_CriticalRegion="SimpleRC22");
      end constructor;

      function destructor "Release storage of FMI model"
          extends Modelica.Icons.Function;
          input fmiModel fmi;
          external"C"
                     SimpleRC2202929504448986350884_fmiFreeModelInstance2(fmi)
          annotation (Include="
#ifndef SimpleRC2202929504448986350884_Free_C
#define SimpleRC2202929504448986350884_Free_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void SimpleRC2202929504448986350884_fmiFreeModelInstance2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    if(a->dyFMUstate)
    a->dyFmiFreeFMUstate(a->m, &a->dyFMUstate);
    /*a->dyFmiSetDebugLogging(a->m,fmi2True,0,NULL);*/
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeInstance(a->m);
    FreeLibrary(a->hInst);
    free(a->der);a->der=0;
    free(a->out);a->out=0;
    free(a);
  }
}
#endif",       Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
        annotation(__Dymola_doNotLinkSharedObject=true,__Dymola_CriticalRegion = "SimpleRC22");
      end destructor;
    end fmiModel;

    function  fmiDoStep
    input fmiModel fmi;
    input Real currentTime;
    input Real stepSize;
    input Real preAvailable;
    output Boolean stepOK;
    output Real postAvailable=preAvailable;
    external"C" stepOK= SimpleRC2202929504448986350884_fmiDoStep2(fmi, currentTime, stepSize)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_DoStep_C
#define SimpleRC2202929504448986350884_DoStep_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double SimpleRC2202929504448986350884_fmiDoStep2(void*m, double currentTime, double stepSize) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  fmi2Boolean value=fmi2False;
  if (a) {
    status=a->dyFmiDoStep(a->m, currentTime, stepSize, fmi2True);
    if(status==fmi2Discard){
      status = a->dyFmiGetBooleanStatus(a->m, fmi2Terminated, &value);
      if(value==fmi2True){
        double tt = 0;
        char s[64] = {0};
        fmi2Status stat2 = fmi2Error;
        stat2 = a->dyFmiGetRealStatus(a->m, fmi2LastSuccessfulTime, &tt);
#if defined(_MSC_VER) && _MSC_VER >= 1200
        if(stat2 == fmi2OK && _snprintf(s, sizeof(s)/sizeof(*s), \"Terminate signaled by the FMU at time %g\", tt) > 0){
#else
        if(stat2 == fmi2OK && snprintf(s, sizeof(s)/sizeof(*s), \"Terminate signaled by the FMU at time %g\", tt) > 0){
#endif
			terminate(s);
        }else{
          terminate(\"Terminate signaled by the FMU\");
        }
      }
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning){    ModelicaFormatError(\"The call of fmi2DoStep(%f, %f) failed in FMU\\r\\nNote: setting fmi_loggingOn in the FMU component may produce more information from the FMU.\",currentTime, stepSize);  }  return 1.0;
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiDoStep;

    function fmiReset
      input fmiModel fmi;
      output Boolean resetOK;
      external"C" resetOK = SimpleRC2202929504448986350884_fmiReset2(fmi)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_Reset_C
#define SimpleRC2202929504448986350884_Reset_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double SimpleRC2202929504448986350884_fmiReset2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiReset(a->m);
    a->currentMode=dyfmi2InstantiationMode;
    a->cpDer = 1;
    a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiReset failed\");
    return 1.0;
  }
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiReset;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_GetReal_C
#define SimpleRC2202929504448986350884_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiGetReal;

    function fmiGetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real preAvailable;
      output Real vals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_GetReal_C
#define SimpleRC2202929504448986350884_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiGetRealwf;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      external"C"
                 SimpleRC2202929504448986350884_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_SetReal_C
#define SimpleRC2202929504448986350884_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    a->cpDer = 1;
    a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      input Real preAvailable;
      output Real postAvailable=preAvailable;
      external"C"
                 SimpleRC2202929504448986350884_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_SetReal_C
#define SimpleRC2202929504448986350884_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    a->cpDer = 1;
    a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealwf;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_GetInteger_C
#define SimpleRC2202929504448986350884_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiGetInteger;

    function fmiGetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Integer vals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_GetInteger_C
#define SimpleRC2202929504448986350884_GetInteger_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void SimpleRC2202929504448986350884_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiGetIntegerwf;

    function fmiSetInteger
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_SetInteger_C
#define SimpleRC2202929504448986350884_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed in SetInteger\");
      for( i = 0; i < nrefs; ++i){
        if(oldVals[i] != vals[i]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
      a->cpDer = 1;
      a->cpOut = 1;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiSetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
      input Integer preAvailable;
      output Integer postAvailable=preAvailable;
      external"C" SimpleRC2202929504448986350884_fmiSetInteger2wf(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_SetIntegerwf_C
#define SimpleRC2202929504448986350884_SetIntegerwf_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSetInteger2wf(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
      a->cpDer = 1;
      a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetIntegerwf;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_GetBoolean_C
#define SimpleRC2202929504448986350884_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiGetBoolean;

    function fmiGetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Boolean vals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_GetBoolean_C
#define SimpleRC2202929504448986350884_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiGetBooleanwf;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_SetBoolean_C
#define SimpleRC2202929504448986350884_SetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals, int* dummy, int* oldVals) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(oldVals));
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed in SetBoolean\");
      for(j=nr-1;j>=0;j--){
        oldVals[j]=((fmi2Boolean*)(oldVals))[j];
        if(oldVals[j] != dummy[j]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
      a->cpDer = 1;
      a->cpOut = 1;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetString
      input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_SetString_C
#define SimpleRC2202929504448986350884_SetString_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSetString2(void*m, const int*refs, size_t nrefs,const fmi2String vals[]) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    a->discreteInputChanged = fmi2True;
    a->cpDer = 1;
    a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetString failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiSetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
      input Integer preAvailable;
      output Integer postAvailable=preAvailable;
    protected
      Boolean dummy[size(refs, 1)];
      external"C" SimpleRC2202929504448986350884_fmiSetBoolean2wf(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_SetBooleanwf_C
#define SimpleRC2202929504448986350884_SetBooleanwf_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSetBoolean2wf(void*m, const int* refs, size_t nr, const int* vals, int* dummy) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
      a->cpDer = 1;
      a->cpOut = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true,
        __Dymola_IdemPotent=true,
        __Dymola_VectorizedExceptFirst=true);
    end fmiSetBooleanwf;

    function fmiGetDirectionalDerivative
      input fmiModel fmi;
      input Integer z_refs[:];
      input Integer v_refs[:];
      input Real dv[size(v_refs, 1)];
      output Real dz[size(z_refs, 1)];
      external"C" SimpleRC2202929504448986350884_GetDirectionalDerivative2(
        fmi,
        z_refs,
        size(z_refs, 1),
        v_refs,
        size(v_refs, 1),
        dv,
        dz)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_GetDirectionalDerivative2_C
#define SimpleRC2202929504448986350884_GetDirectionalDerivative2_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_GetDirectionalDerivative2(void*m, const int* zref, size_t nzr, const int* vrefs, size_t nvr, const double *dv, double *dz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDirectionalDerivative(a->m, zref, nzr, vrefs, nvr, dv, dz);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetDirectionalDerivative failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiGetDirectionalDerivative;

    function GetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1]);
      annotation(derivative(noDerivative=realLinearDependentInputs,noDerivative=linearDependentStates)=derGetRealVariable, LateInline=true);
    end GetRealVariable;

    function GetRealVariable2
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Integer outputIndex;
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetOutput(fmi,outputIndex);
      annotation(derivative(noDerivative=realLinearDependentInputs,noDerivative=linearDependentStates)=derGetRealVariable2, LateInline=true);
    end GetRealVariable2;

    function GetRealDerVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Integer outputIndex;
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetDerivatives2(fmi,outputIndex);
      annotation(derivative(noDerivative=realLinearDependentInputs,noDerivative=linearDependentStates)=derGetRealVariable2, LateInline=true);
    end GetRealDerVariable;

    function derGetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Real derRealInputs[:];
      input Real derStates[:];
      input Real derLinearOffsets;
      output Real derOutputVariable;
    protected
      Real dummy[1];
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //setString(fmi,stringInputValueReferences,stringInputs);
      dummy:=fmiGetDirectionalDerivative(fmi, outputValueReference,  cat(1,realInputValueReferences,statesValueRefernces), cat(1,derRealInputs,derStates));
      derOutputVariable:=dummy[1]+derLinearOffsets;
      annotation(LateInline=true);
    end derGetRealVariable;

    function derGetRealVariable2
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Integer outputIndex;
      input Real derRealInputs[:];
      input Real derStates[:];
      input Real derLinearOffsets;
      output Real derOutputVariable;
    protected
      Real dummy[1];
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //setString(fmi,stringInputValueReferences,stringInputs);
      dummy:=fmiGetDirectionalDerivative(fmi, outputValueReference,  cat(1,realInputValueReferences,statesValueRefernces), cat(1,derRealInputs,derStates));
      derOutputVariable:=dummy[1]+derLinearOffsets;
      annotation(LateInline=true);
    end derGetRealVariable2;

    function linearizeFMU
      input fmiModel fmi;
      input Integer xVr[:];
      input Integer dxVr[:];
      input Integer uVr[:];
      input Integer yVr[:];
      output Real A[size(dxVr, 1), size(xVr, 1)];
      output Real B[size(dxVr, 1), size(uVr, 1)];
      output Real C[size(yVr, 1), size(xVr, 1)];
      output Real D[size(yVr, 1), size(uVr, 1)];
    protected
      parameter Integer nD = size(dxVr, 1);
      parameter Integer nY = size(yVr, 1);
      parameter Integer nU = size(uVr, 1);
      parameter Integer nX = size(xVr, 1);
      parameter Integer zRef[nD + nY] = cat(1, dxVr, yVr);
      Real vec[nD + nY];
      parameter Real one[1] = { 1.0};
    algorithm
      for i in 1:nX loop
        vec := fmiGetDirectionalDerivative(
          fmi,zRef,{ xVr[i]}, one);
        A[:, i] := vec[1:nD];
        C[:, i] := vec[nD + 1:end];
      end for;
      for i in 1:nU loop
        vec := fmiGetDirectionalDerivative(
        fmi,zRef,{ uVr[i]}, one);
        B[:, i] := vec[1:nD];
        D[:, i] := vec[nD + 1:end];
      end for;
    end linearizeFMU;

    function fmiSaveFMUState
      input fmiModel fmi;
      external"C" SimpleRC2202929504448986350884_fmiSaveFMUState2(fmi)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_fmiSaveFMUState_C
#define SimpleRC2202929504448986350884_fmiSaveFMUState_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSaveFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiSaveFMUState;

    function fmiRestoreFMUState
      input fmiModel fmi;
      external"C" SimpleRC2202929504448986350884_fmiRestoreFMUState2(fmi)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_fmiRestoreFMUState_C
#define SimpleRC2202929504448986350884_fmiRestoreFMUState_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiRestoreFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
    a->cpOut = 1;
    a->cpDer = 1;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiRestoreFMUState;

    function fmiSerializeFMUstate
      input fmiModel fmi;
      external"C" SimpleRC2202929504448986350884_fmiSerializeFMUstate2(fmi)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_fmiSerializeFMUstate_C
#define SimpleRC2202929504448986350884_fmiSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
    status = a->dyFmiSerializedFMUstateSize(a->m, a->dyFMUstate, &a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializedFMUstateSize failed\");
    if( a->dySerializeFMUstate) free(a->dySerializeFMUstate); a->dySerializeFMUstate = NULL;
    a->dySerializeFMUstate = malloc(a->dyFMUStateSize);
    if(!a->dySerializeFMUstate)  ModelicaError(\"malloc call to allocate SerializeFMUstate failed\");
    status = a->dyFmiSerializeFMUstate(a->m, a->dyFMUstate, a->dySerializeFMUstate, a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializeFMUstate failed\");
  }
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiSerializeFMUstate;

    function fmiDeSerializeFMUstate
      input fmiModel fmi;
      external"C" SimpleRC2202929504448986350884_fmiDeSerializeFMUstate2(fmi)
        annotation (Include="
#ifndef SimpleRC2202929504448986350884_fmiDeSerializeFMUstate_C
#define SimpleRC2202929504448986350884_fmiDeSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiDeSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(!a->dySerializeFMUstate) ModelicaError(\"serializedFmuState is not allocated!!!\");
    if(a->dyFMUstate){
      a->dyFmiFreeFMUstate(a->m, &a->dyFMUstate);
      a->dyFMUstate = NULL;    }
    status = a->dyFmiDeSerializeFMUstate(a->m, a->dySerializeFMUstate, a->dyFMUStateSize, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiDeSerializeFMUstate failed\");
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
  }
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiDeSerializeFMUstate;

    function fmiEnterSlaveInitializationMode
      input fmiModel fmi;
      input Boolean setTolerance;
      input Real relativeTolerance;
      input Real tStart;
      input Boolean forceShutDownAtTStop;
      input Real tStop;
      input Real preAvailable;
      output Real postAvailable = preAvailable;
      external"C" SimpleRC2202929504448986350884_fmiEnterSlaveInitializationMode2(fmi, setTolerance, relativeTolerance, tStart, forceShutDownAtTStop, tStop)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_fmiEnterSlaveInitializationMode_C
#define SimpleRC2202929504448986350884_fmiEnterSlaveInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiEnterSlaveInitializationMode2(void*m, int setTolerance, double relativeTolerance, double tStart, int forceShutDownAtTStop, double tStop) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode==dyfmi2InstantiationMode){
      status=a->dyFmiSetupExperiment(a->m, setTolerance, relativeTolerance, tStart, forceShutDownAtTStop, tStop);
      status=a->dyFmiEnterInitializationMode(a->m);
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->currentMode=dyfmi2InitializationMode;
    }else{
      status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"InitializeSlave failed\");
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiEnterSlaveInitializationMode;

    function fmiExitSlaveInitializationMode
      input fmiModel fmi;
      input Real preAvailable;
      output Real postAvailable = preAvailable;
      external"C" SimpleRC2202929504448986350884_fmiExitSlaveInitializationMode2(fmi)
      annotation (Include="
#ifndef SimpleRC2202929504448986350884_fmiExitSlaveInitializationMode_C
#define SimpleRC2202929504448986350884_fmiExitSlaveInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void SimpleRC2202929504448986350884_fmiExitSlaveInitializationMode2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode==dyfmi2InitializationMode){
      status=a->dyFmiExitInitializationMode(a->m);
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->currentMode = dyfmi2EventMode;
    }else{status = fmi2OK;}
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiExitModelInitialization failed!\");
  return;
}
#endif", Library="SimpleRC22", LibraryDirectory="modelica://SimpleRC22_fmu/Resources/Library/FMU/SimpleRC22/binaries");
      annotation (
        __Dymola_doNotLinkSharedObject=true,
        __Dymola_CriticalRegion="SimpleRC22",
        __Dymola_LockExternalObject=true);
    end fmiExitSlaveInitializationMode;
end fmi_Functions;
initial equation
equation
  when initial() then
    fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_resourceLocation);
  end when;
initial algorithm
  fmi_Functions.fmiSetReal(fmi, {16777216, 16777217, 16777218, 16777219, 16777220, 16777221, 16777222, 16777223, 16777224, 16777225, 16777226, 16777227, 16777228, 16777229, 16777230, 16777231, 16777232, 16777233, 16777234, 16777235, 16777236, 16777237, 16777238, 16777239, 16777240, 16777241, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 16777251, 16777252, 16777253, 16777254, 16777255}, {cap.C, res.R, souTOut.amplitude, souTOut.f, souTOut.phase, souTOut.offset, souTOut.startTime, set.height, set.offset, set.startTime, con.k, con.Ti, con.Td, con.yMax, con.yMin, con.wp, con.wd, con.Ni, con.Nd, con.kFF, con.xi_start, con.xd_start, con.y_start, con.addP.k2, con.P.k, con.addPID.k1, con.addPID.k2, con.addPID.k3, con.Dzero.k, con.Izero.k, con.FFzero.k, con.addFF.k1, preHeat.T_ref, preHeat.alpha, eff.k, conCO2.amplitude, conCO2.f, conCO2.phase, conCO2.offset, conCO2.startTime});
  fmi_Functions.fmiSetReal(fmi, {33554432}, {cap._T_start});
    fmi_Functions.fmiEnterSlaveInitializationMode(fmi, fmi_setTol, fmi_rTol, fmi_StartTime, fmi_forceShutDownAtStopTime, fmi_StopTime, 1);
  fmi_rdum := 1;
  fmi_idum := 1;
  myTimeStart :=time;
algorithm
assert(fmi_CommunicationStepSize > 0.0,"The parameter fmi_CommunicationStepSize has an invalid value, please set a positive value larger than 0.0");
  when {initial(), sample(fmi_StartTime, fmi_CommunicationStepSize)} then
      if fmi_rdum > 0  and fmi_idum > 0 and not fmi_exitInit and not initial() then
        fmi_Functions.fmiExitSlaveInitializationMode(fmi, 1);
        fmi_exitInit:=true;
RealFixedLocal :=fmi_Functions.fmiGetRealwf(
        fmi,
        {100663303,100663304,234881052,234881053,100663305,100663306,234881054,
          100663311},
        fmi_rdum);
      end if;
    if time>=fmi_CommunicationStepSize +fmi_StartTime then
      for stepSizeIndex in 1:stepSizeScaleFactor loop
        fmi_StepOK :=fmi_Functions.fmiDoStep(
          fmi,
          time + (stepSizeIndex - 1 - stepSizeScaleFactor)*
            fmi_CommunicationStepSize/stepSizeScaleFactor,
          fmi_CommunicationStepSize/stepSizeScaleFactor,
          1);
      end for;
    end if;
    if not initial() then
  internal.CPUtime :=fmi_Functions.fmiGetRealScalar(fmi, 67108864);
  internal.EventCounter :=fmi_Functions.fmiGetRealScalar(fmi, 67108865);
    end if;
RealVariables :=fmi_Functions.fmiGetReal(fmi, {33554432,587202560,637534237,
      637534238,637534239,637534240,637534241,637534236,637534242,905969699,
      637534244,637534245,637534246,637534247,637534248,637534249,905969706,
      905969707,905969708});
  end when;
equation
  if initial() then
    CPUtime = fmi_Functions.GetRealVariable(fmi,myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {67108864});
  else
    CPUtime = internal.CPUtime;
  end if;
  if initial() then
    EventCounter = fmi_Functions.GetRealVariable(fmi,myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {67108865});
  else
    EventCounter = internal.EventCounter;
  end if;
  cap.T = RealVariables[1];
  cap.der_T = RealVariables[2];
  cap.port.Q_flow = RealVariables[3];
  res.Q_flow = RealVariables[4];
  res.dT = RealVariables[5];
  res.port_a.T = RealVariables[6];
  res.port_b.Q_flow = RealVariables[7];
  set.y = RealVariables[8];
  con.y = RealVariables[9];
  con.controlError = RealVariables[10];
  con.addP.y = RealVariables[11];
  con.P.y = RealVariables[12];
  con.gainPID.u = RealVariables[13];
  con.gainPID.y = RealVariables[14];
  con.limiter.u = RealVariables[15];
  preHeat.port.Q_flow = RealVariables[16];
  eff.y = RealVariables[17];
  PHea.u = RealVariables[18];
  CO2RooAir.u = RealVariables[19];
  con.addP.k1 = RealFixedLocal[1];
  con.gainPID.k = RealFixedLocal[2];
  con.addPID.u2 = RealFixedLocal[3];
  con.addPID.u3 = RealFixedLocal[4];
  con.limiter.uMax = RealFixedLocal[5];
  con.limiter.uMin = RealFixedLocal[6];
  con.FFzero.y = RealFixedLocal[7];
  con.addFF.k2 = RealFixedLocal[8];
//alias Declarations
  con.Dzero.y = con.addPID.u2;
  con.Izero.y = con.addPID.u3;
  con.addFF.u2 = con.FFzero.y;
  cap.port.T = cap.T;
  res.port_b.T = cap.T;
  senTZone.T = cap.T;
  senTZone.port.T = cap.T;
  con.u_m = cap.T;
  con.addP.u2 = cap.T;
  preHeat.port.T = cap.T;
  TRooAir.u = cap.T;
  TRooAir.y = cap.T;
  con.u_s = set.y;
  con.addP.u1 = set.y;
  res.port_a.Q_flow = res.Q_flow;
  preTOut.T = res.port_a.T;
  preTOut.port.T = res.port_a.T;
  souTOut.y = res.port_a.T;
  preTOut.port.Q_flow = res.port_b.Q_flow;
  con.limiter.y = con.y;
  oveAct.u = con.y;
  oveAct.y = con.y;
  oveAct.swi.u3 = con.y;
  oveAct.swi.y = con.y;
  preHeat.Q_flow = con.y;
  eff.u = con.y;
  con.P.u = con.addP.y;
  con.addPID.u1 = con.P.y;
  con.addPID.y = con.gainPID.u;
  con.addFF.u1 = con.gainPID.y;
  con.addFF.y = con.limiter.u;
  'abs'.u = eff.y;
  PHea.y = PHea.u;
  'abs'.y = PHea.u;
  CO2RooAir.y = CO2RooAir.u;
  conCO2.y = CO2RooAir.u;
  annotation (__Dymola_FMUImportVersion="Dymola 2023x", __Dymola_FMUImportPath="C:/Users/ASUS/Desktop/FDD/git_Boptest/project1-boptest-master/testcases/testcase1/models/SimpleRC22.fmu", __Dymola_FMUImportIncludeAllVariables="true", __Dymola_FMUImportIntegrate="true", __Dymola_FMUResourcePath="Resources/Library/FMU/SimpleRC22", experiment(StartTime=0.0, StopTime=60.0, Tolerance=1E-06),
    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 2.0 CS")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 2.0</li>
<li>modelName = SimpleRC22</li>
<li>generationTool = Dymola Version 2023x, 2022-10-07</li>
<li>generationDateAndTime = 2025-01-04T06:51:54Z</li>
</ul>
<p><br><b>Co-Simulation Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>canHandleVariableCommunicationStepSize = true</li>
<li>canInterpolateInputs = true</li>
<li>maxOutputDerivativeOrder = 1</li>
<li>canRunAsynchronuously = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = true</li>
<li>canGetAndSetFMUstate = true</li>
<li>canSerializeFMUstate = true</li>
<li>providesDirectionalDerivative = true</li>
</ul>
</html>"));
end SimpleRC22_fmu;

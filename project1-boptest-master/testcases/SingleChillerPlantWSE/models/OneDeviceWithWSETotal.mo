package ModelicaServices
  "ModelicaServices (Dymola implementation) - Models and functions used in the Modelica Standard Library requiring a tool specific implementation"
extends Modelica.Icons.Package;

package Machine

  final constant Real eps=1.e-15 "Biggest number such that 1.0 + eps = 1.0";

  final constant Real small=1.e-60
    "Smallest number such that small and -small are representable on the machine";

  final constant Real inf=1.e+60
    "Biggest Real number such that inf and -inf are representable on the machine";
  annotation (Documentation(info="<html>
<p>
Package in which processor specific constants are defined that are needed
by numerical algorithms. Typically these constants are not directly used,
but indirectly via the alias definition in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.
</p>
</html>"));
end Machine;
annotation (
  Protection(access=Access.hide),
  preferredView="info",
  version="4.0.0",
  Dymola2(checkSum="3933384872:3320196239"),
  versionBuild=0,
  versionDate="2020-01-15",
  dateModified = "2020-01-15 08:44:41Z",
  uses(Modelica(version="4.0.0")),
  conversion(
    noneFromVersion="1.0",
    noneFromVersion="1.1",
    noneFromVersion="1.2",
    noneFromVersion="3.2.1",
 noneFromVersion="3.2.3"),
  Documentation(info="<html>
<p>
This package contains a set of functions and models to be used in the
Modelica Standard Library that requires a tool specific implementation.
These are:
</p>

<ul>
<li> <a href=\"modelica://ModelicaServices.Animation.Shape\">Animation.Shape</a>
     provides a 3-dim. visualization of elementary
     mechanical objects. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Animation.Surface\">Animation.Surface</a>
     provides a 3-dim. visualization of
     moveable parameterized surface. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Animation.Vector\">Animation.Vector</a>
     provides a 3-dim. visualization of a vector objects. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Vector\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Vector</a>
     via inheritance.</li>
	 
<li> <a href=\"modelica://ModelicaServices.ExternalReferences.loadResource\">ExternalReferences.loadResource</a>
     provides a function to return the absolute path name of an URI or a local file name. It is used in
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Files.loadResource</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Machine\">Machine</a>
     provides a package of machine constants. It is used in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.</li>

<li> <a href=\"modelica://ModelicaServices.System.exit\">System.exit</a> provides a function to terminate the execution of the Modelica environment. It is used in <a href=\"modelica://Modelica.Utilities.System.exit\">Modelica.Utilities.System.exit</a> via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Types.SolverMethod\">Types.SolverMethod</a>
     provides a string defining the integration method to solve differential equations in
     a clocked discretized continuous-time partition (see Modelica 3.3 language specification).
     It is not yet used in the Modelica Standard Library, but in the Modelica_Synchronous library
     that provides convenience blocks for the clock operators of Modelica version &ge; 3.3.</li>
</ul>

<p>
This is the Dymola implementation.
</p>

<p>
Original version
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 2009-2020, Modelica Association and contributors.
</p>
<p>
<strong>Modifications licensed by Dassault Syst&egrave;mes, copyright &copy; 2009-2020.</strong>
</p>

</html>"));
end ModelicaServices;

package Buildings "Library with models for building energy and control systems"
  extends Modelica.Icons.Package;

  package BoundaryConditions "Package with models for boundary conditions"
    extends Modelica.Icons.Package;

    package SkyTemperature "Package with models to compute the sky temperature"
      extends Modelica.Icons.VariantsPackage;

      block BlackBody "Calculate black body sky temperature"
        extends Modelica.Blocks.Icons.Block;

        parameter Buildings.BoundaryConditions.Types.SkyTemperatureCalculation calTSky=
          Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Computation of black-body sky temperature"
          annotation(choicesAllMatching=true,
                     Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dry bulb temperature at ground level"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput TDewPoi(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dew point temperature"
          annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
        Modelica.Blocks.Interfaces.RealInput nOpa( min=0, max=1, unit="1")
          "Opaque sky cover [0, 1]"
          annotation (Placement(transformation(extent={{-140,-50},{-100,-10}})));
        Modelica.Blocks.Interfaces.RealOutput TBlaSky(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K") "Black-body sky temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput HHorIR(
          unit="W/m2",
          min=0,
          nominal=100) "Horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
    protected
        Modelica.Units.SI.Temperature TDewPoiK "Dewpoint temperature";
        Modelica.Units.SI.Emissivity epsSky "Black-body absorptivity of sky";
        Real nOpa10(min=0, max=10) "Opaque sky cover in [0, 10]";
      equation
        if calTSky == Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover then
          TDewPoiK =  Buildings.Utilities.Math.Functions.smoothMin(TDryBul, TDewPoi, 0.1);
          nOpa10 =  10*nOpa "Input nOpa is scaled to [0,1] instead of [0,10]";
          epsSky =  (0.787 + 0.764*Modelica.Math.log(-TDewPoiK/Modelica.Constants.T_zero))*(1 + 0.0224*nOpa10 -
            0.0035*(nOpa10^2) + 0.00028*(nOpa10^3));
          TBlaSky =  TDryBul*(epsSky^0.25);
        else
          TDewPoiK =  273.15;
          nOpa10   =  0.0;
          epsSky   =  0.0;
          TBlaSky  =  (HHorIR/Modelica.Constants.sigma)^0.25;
        end if;
        annotation (
          defaultComponentName="TBlaSky",
          Documentation(info="<html>
<p>
This component computes the black-body sky temperature.
</p>
<p>
For <code>calTSky = 0</code>, the model uses horizontal infrared irradiation.
Otherwise, it uses dry buld temperature, dew point temperature and opaque sky cover.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2017, by Michael Wetter:<br/>
Removed <code>import</code> statement.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/852\">#852</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed unit and comment of input <code>nOpa</code> for correct display of units
in <code>weaBus</code> and input <code>radHorIR</code> to <code>HHorIR</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code>.
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Used enumeration to set the sky temperature computation.
Fixed error in <code>if-then</code> statement that led to
a selection of the wrong branch to compute the sky temperature.
</li>
<li>
March 16, 2011, by Michael Wetter:<br/>
Added types for parameters and attributes for variables.
Removed default parameter value.
</li>
<li>
March 15, 2011, by Wangda Zuo:<br/>
Use <code>smoothMin()</code> instead of <code>min()</code>.
</li>
<li>
June 1, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-50,44},{56,-40}},
                textColor={0,0,255},
                textString="T"),
              Text(
                extent={{-96,84},{-66,74}},
                textColor={0,0,127},
                textString="TDry"),
              Text(
                extent={{-90,36},{-66,24}},
                textColor={0,0,127},
                textString="TDewPoi"),
              Text(
                extent={{-92,-74},{-62,-88}},
                textColor={0,0,127},
                textString="radHorIR"),
              Text(
                extent={{16,-6},{54,-28}},
                textColor={0,0,255},
                textString="bs"),
              Text(
                extent={{-88,-24},{-64,-36}},
                textColor={0,0,127},
                textString="nOpa")}));
      end BlackBody;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the black body sky temperature.
</html>"));
    end SkyTemperature;

    package SolarGeometry "Package with models to compute solar geometry"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Package with base classes for Buildings.BoundaryConditions.SolarGeometry"
        extends Modelica.Icons.BasesPackage;

        block AltitudeAngle "Solar altitude angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
        annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput alt(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar altitude angle"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          alt = (Modelica.Constants.pi/2) - zen;
          annotation (Icon(graphics={Bitmap(extent={{-90,-90},{90,90}}, fileName
                  =   "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/AltitudeAngle.png")}),
            defaultComponentName="altAng", Documentation(info="<html>
<p>
This block computes the altitude angle of the sun with respect to a horizontal surface.
The altitude angle is the angle between the sun ray and the projection of the ray
on a horizontal surface.
It is the complementory angle to the zenith angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the output connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
        end AltitudeAngle;

        block Declination "Declination angle"
          extends
          Buildings.BoundaryConditions.WeatherData.BaseClasses.PartialConvertTime;
          Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
            "Day number with units of seconds"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput decAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar declination angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          constant Real k1 = sin(23.45*2*Modelica.Constants.pi/360) "Constant";
          constant Real k2 = 2*Modelica.Constants.pi/365.25 "Constant";
        equation
          modTimAux = nDay;
          decAng = Modelica.Math.asin(-k1 * Modelica.Math.cos((calTimAux/86400 + 10)*k2))
            "(A4.5)";
          annotation (
            defaultComponentName="decAng",
            Documentation(info="<html>
<p>
This component computes the solar declination, which is
the angle between the equatorial plane and the solar beam.
The input signal <code>nDay</code> is the one-based number of the day, but in seconds.
Hence, during January 1, we should have <code>nDay = 86400</code> seconds.
Since the effect of using a continuous number rather than an integer is small,
we approximate this so that <code>nDay = 0</code> at the start of January 1,
and <code>nDay = 86400</code> at the end of January 1.
</p>
<h4>Validation</h4>
<p>
A validation with a more detailed calculation can be found at
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Updated to use partial class for conversion from simulation time to calendar time.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Updated documentation and added validation.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/382\">issue 382</a>.
</li>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of output signal as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
November 11, 2015, by Michael Wetter:<br/>
Corrected typo in documentation.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName
                  =   "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/Declination.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  textColor={0,0,255})}));
        end Declination;

        block SolarHourAngle "Solar hour angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput solHouAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar hour angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solHouAng = (solTim/3600 - 12)*2*Modelica.Constants.pi/24
            "Our unit is s instead of h in (A4.6)";
          annotation (
            defaultComponentName="solHouAng",
            Documentation(info="<html>
<p>
This component computes the solar hour angle,
which is defined as the angle between the circle
that passes through an observer, the north pole and the south pole,
and the circle that passes through the sun, the north and the south pole.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName
                  =   "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarHourAngle.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  textColor={0,0,255})}));
        end SolarHourAngle;

        block ZenithAngle "Zenith angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Solar declination angle"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}}),
                iconTransformation(extent={{-140,34},{-100,74}})));
          Modelica.Blocks.Interfaces.RealOutput zen(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Zenith angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput lat(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Latitude"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}}),
                iconTransformation(extent={{-140,-20},{-100,20}})));
        equation
          zen =  Modelica.Math.acos(Modelica.Math.cos(lat)*Modelica.Math.cos(decAng)*
            Modelica.Math.cos(solHouAng) + Modelica.Math.sin(lat)*Modelica.Math.sin(
            decAng)) "(A4.8)";
          annotation (
            defaultComponentName="zen",
            Documentation(info="<html>
<p>
This component computes the zenith angle, which is the angle between the earth surface normal and the sun's beam.
Input are the solar hour angle and the declination angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed <code>lat</code> from being a parameter to an input from weather bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the input connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-86,-88},{94,92}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/ZenithAngle.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  textColor={0,0,255}),
                Text(
                  extent={{-98,62},{-46,46}},
                  textColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-40},{-22,-58}},
                  textColor={0,0,127},
                  textString="solHouAng")}));
        end ZenithAngle;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry\">Buildings.BoundaryConditions.SolarGeometry</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the solar geometry and incidence
angles on tilted surfaces.
</html>"));
    end SolarGeometry;

    package WeatherData "Weather data reader"
      extends Modelica.Icons.VariantsPackage;

      expandable connector Bus "Data bus that stores weather data"
        extends Modelica.Icons.SignalBus;

        Modelica.Units.SI.Temperature TDryBul "Dry bulb temperature";
        Modelica.Units.SI.Temperature TWetBul "Wet bulb temperature";
        Modelica.Units.SI.Temperature TDewPoi "Dew point temperature";
        Modelica.Units.SI.Temperature TBlaSky "Black-body sky temperature";

        Real relHum(final unit="1") "Relative humidity";

        Real HDirNor(final unit="W/m2") "Direct normal solar irradiation";
        Real HGloHor(final unit="W/m2") "Global horizontal solar irradiation";
        Real HDifHor(final unit="W/m2") "Diffuse horizontal solar irradiation";

        Real HHorIR(final unit="W/m2") "Horizontal infrared irradiation";

        Modelica.Units.SI.Angle winDir "Wind direction";
        Modelica.Units.SI.Velocity winSpe "Wind speed";

        Modelica.Units.SI.Height ceiHei "Cloud cover ceiling height";
        Real nOpa(final unit="1") "Opaque sky cover";
        Real nTot(final unit="1") "Total sky cover";

        Modelica.Units.SI.Angle lat "Latitude of the location";
        Modelica.Units.SI.Angle lon "Longitude of the location";
        Modelica.Units.SI.Height alt "Location altitude above sea level";

        Modelica.Units.SI.AbsolutePressure pAtm "Atmospheric pressure";

        Modelica.Units.SI.Angle solAlt "Solar altitude angle";
        Modelica.Units.SI.Angle solDec "Solar declination angle";
        Modelica.Units.SI.Angle solHouAng "Solar hour angle";
        Modelica.Units.SI.Angle solZen "Solar zenith angle";

        Modelica.Units.SI.Time solTim "Solar time";
        Modelica.Units.SI.Time cloTim "Model time";

        annotation (
          defaultComponentName="weaBus",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 22, 2023, by Michael Wetter:<br/>
Declared the variables that are on the bus.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1798\">IBPSA, #1798</a>.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Bus;

      block ReaderTMY3 "Reader for TMY3 weather data"

        Bus weaBus "Weather data bus" annotation (Placement(transformation(extent={{
                  290,-10},{310,10}}), iconTransformation(extent={{190,-10},{210,10}})));

        //--------------------------------------------------------------
        parameter String filNam="" "Name of weather data file" annotation (
          Dialog(loadSelector(filter="Weather files (*.mos)",
                              caption="Select weather file")));

        parameter Boolean computeWetBulbTemperature = true
          "If true, then this model computes the wet bulb temperature"
          annotation(Evaluate=true);

        //--------------------------------------------------------------
        // Atmospheric pressure
        parameter Buildings.BoundaryConditions.Types.DataSource pAtmSou=Buildings.BoundaryConditions.Types.DataSource.Parameter
          "Atmospheric pressure"
          annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.Units.SI.Pressure pAtm=101325
          "Atmospheric pressure (used if pAtmSou=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput pAtm_in(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="Pa") if (pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input pressure"
          annotation (Placement(transformation(extent={{-240,254},{-200,294}}),
              iconTransformation(extent={{-240,254},{-200,294}})));

        //--------------------------------------------------------------
        // Dry bulb temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TDryBulSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Dry bulb temperature"
          annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.Units.SI.Temperature TDryBul(displayUnit="degC") = 293.15
          "Dry bulb temperature (used if TDryBul=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDryBul_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input dry bulb temperature"
          annotation (Placement(transformation(extent={{-240,160},{-200,200}})));

        //--------------------------------------------------------------
        // Dew point temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TDewPoiSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Dew point temperature"
          annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.Units.SI.Temperature TDewPoi(displayUnit="degC") = 283.15
          "Dew point temperature (used if TDewPoi=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDewPoi_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDewPoiSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input dew point temperature"
          annotation (Placement(transformation(extent={{-240,204},{-200,244}})));

        //--------------------------------------------------------------
        // Black body sky temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TBlaSkySou=Buildings.BoundaryConditions.Types.DataSource.File
          "Black-body sky temperature" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.Units.SI.Temperature TBlaSky=273.15
          "Black-body sky temperature (used if TBlaSkySou=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput TBlaSky_in(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K")
       if (TBlaSkySou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Black-body sky temperature"
          annotation (Placement(transformation(extent={{-240,120},{-200,160}}),
              iconTransformation(extent={{-240,120},{-200,160}})));
        //--------------------------------------------------------------
        // Relative humidity
        parameter Buildings.BoundaryConditions.Types.DataSource relHumSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Relative humidity" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Real relHum(
          min=0,
          max=1,
          unit="1") = 0.5 "Relative humidity (used if relHum=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput relHum_in(
          min=0,
          max=1,
          unit="1") if (relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input relative humidity"
          annotation (Placement(transformation(extent={{-240,80},{-200,120}}),
              iconTransformation(extent={{-240,80},{-200,120}})));
        //--------------------------------------------------------------
        // Wind speed
        parameter Buildings.BoundaryConditions.Types.DataSource winSpeSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Wind speed" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.Units.SI.Velocity winSpe(min=0) = 1
          "Wind speed (used if winSpe=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput winSpe_in(
          final quantity="Velocity",
          final unit="m/s",
          min=0) if (winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input wind speed"
          annotation (Placement(transformation(extent={{-240,-98},{-200,-58}}),
              iconTransformation(extent={{-240,-98},{-200,-58}})));
        //--------------------------------------------------------------
        // Wind direction
        parameter Buildings.BoundaryConditions.Types.DataSource winDirSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Wind direction" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.Units.SI.Angle winDir=1.0
          "Wind direction (used if winDir=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput winDir_in(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") if (winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input wind direction"
          annotation (Placement(transformation(extent={{-240,-140},{-200,-100}}),
              iconTransformation(extent={{-240,-140},{-200,-100}})));
        //--------------------------------------------------------------
        // Infrared horizontal radiation
        parameter Buildings.BoundaryConditions.Types.DataSource HInfHorSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Infrared horizontal radiation" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.Units.SI.HeatFlux HInfHor=0.0
          "Infrared horizontal radiation (used if HInfHorSou=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput HInfHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HInfHorSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input infrared horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-180},{-200,-140}}),
              iconTransformation(extent={{-240,-180},{-200,-140}})));

         parameter Buildings.BoundaryConditions.Types.RadiationDataSource HSou=Buildings.BoundaryConditions.Types.RadiationDataSource.File
          "Global, diffuse, and direct normal radiation"
           annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        //--------------------------------------------------------------
        // Global horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HGloHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2")
            if (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or
                HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input global horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-320},{-200,-280}}),
              iconTransformation(extent={{-240,-280},{-200,-240}})));
        //--------------------------------------------------------------
        // Diffuse horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HDifHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2")
            if (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or
                HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor)
          "Input diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-240},{-200,-200}}),
              iconTransformation(extent={{-240,-210},{-200,-170}})));
        //--------------------------------------------------------------
        // Direct normal radiation
        Modelica.Blocks.Interfaces.RealInput HDirNor_in(final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
            if (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor or
                HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input direct normal radiation"
          annotation (Placement(transformation(extent={{-240,-280},{-200,-240}}),
              iconTransformation(extent={{-240,-240},{-200,-200}})));

      //--------------------------------------------------------------
        // Ceiling height
        parameter Buildings.BoundaryConditions.Types.DataSource ceiHeiSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Ceiling height" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Real ceiHei(
          final quantity="Height",
          final unit="m",
          displayUnit="m") = 20000 "Ceiling height (used if ceiHei=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput ceiHei_in(
          final quantity="Height",
          final unit="m",
          displayUnit="m") if (ceiHeiSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input ceiling height"
          annotation (Placement(transformation(extent={{-240,-10},{-200,30}}),
              iconTransformation(extent={{-240,-10},{-200,30}})));
        //--------------------------------------------------------------
        // Total sky cover
        parameter Buildings.BoundaryConditions.Types.DataSource totSkyCovSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Total sky cover" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Real totSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Total sky cover (used if totSkyCov=Parameter). Use 0 <= totSkyCov <= 1"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput totSkyCov_in(
          min=0,
          max=1,
          unit="1") if (totSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input total sky cover"
          annotation (Placement(transformation(extent={{-240,-58},{-200,-18}}),
              iconTransformation(extent={{-240,-58},{-200,-18}})));
        // Opaque sky cover
        parameter Buildings.BoundaryConditions.Types.DataSource opaSkyCovSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Opaque sky cover" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Real opaSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Opaque sky cover (used if opaSkyCov=Parameter). Use 0 <= opaSkyCov <= 1"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput opaSkyCov_in(
          min=0,
          max=1,
          unit="1") if (opaSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input opaque sky cover"
          annotation (Placement(transformation(extent={{-240,32},{-200,72}}),
              iconTransformation(extent={{-240,32},{-200,72}})));

        parameter Buildings.BoundaryConditions.Types.SkyTemperatureCalculation
          calTSky=Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Model choice for black-body sky temperature calculation" annotation (
          choicesAllMatching=true,
          Evaluate=true,
          Dialog(tab="Advanced", group="Sky temperature"));

        final parameter Modelica.Units.SI.Angle lon(displayUnit="deg") =
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(filNam)
          "Longitude";
        final parameter Modelica.Units.SI.Angle lat(displayUnit="deg") =
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getLatitudeTMY3(filNam)
          "Latitude";
        final parameter Modelica.Units.SI.Time timZon(displayUnit="h") =
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(filNam)
          "Time zone";
        final parameter Modelica.Units.SI.Length alt(displayUnit="m") =
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getAltitudeLocationTMY3(
          filNam) "Location altitude above sea level";

    protected
        final parameter Modelica.Units.SI.Time[2] timeSpan=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3(filNam,
            "tab1") "Start time, end time of weather data";

        Modelica.Blocks.Tables.CombiTable1Ds datRea(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          verboseRead=false,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns={2,3,4,5,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
              28,29,30,8}) "Data reader"
          annotation (Placement(transformation(extent={{-70,-40},{-50,-20}})));

        BaseClasses.SourceSelector pAtmSel(
          final datSou=pAtmSou,
          final p=pAtm) "Source selection for atmospheric pressure"
          annotation (Placement(transformation(extent={{0,260},{20,280}})));
        BaseClasses.SourceSelector TDewPoiSel(
          final datSou=TDewPoiSou,
          final p=TDewPoi)
          "Source selection for dewpoint temperature pressure"
          annotation (Placement(transformation(extent={{92,-240},{112,-220}})));
        BaseClasses.SourceSelector TDryBulSel(
          final datSou=TDryBulSou,
          final p=TDryBul)
          "Source selection for drybulb temperature pressure"
          annotation (Placement(transformation(extent={{92,-200},{112,-180}})));
        BaseClasses.SourceSelector TBlaSkySel(
          final datSou=TBlaSkySou,
          final p=TBlaSky)
          "Source selection for sky black body radiation"
          annotation (Placement(transformation(extent={{240,-180},{260,-160}})));
        BaseClasses.SourceSelector relHumSel(
          final datSou=relHumSou,
          final p=relHum)
          "Source selection for relative humidity"
          annotation (Placement(transformation(extent={{120,20},{140,40}})));
        BaseClasses.SourceSelector opaSkyCovSel(
          final datSou=opaSkyCovSou,
          final p=opaSkyCov)
          "Source selection for opaque sky cover"
          annotation (Placement(transformation(extent={{120,-160},{140,-140}})));
        BaseClasses.SourceSelector ceiHeiSel(
          final datSou=ceiHeiSou,
          final p=ceiHei)
          "Source selection for ceiling height"
          annotation (Placement(transformation(extent={{120,-120},{140,-100}})));
        BaseClasses.SourceSelector totSkyCovSel(
          final datSou=totSkyCovSou,
          final p=totSkyCov)
          "Source selection for total sky cover"
          annotation (Placement(transformation(extent={{120,-40},{140,-20}})));
        BaseClasses.SourceSelector winSpeSel(
          final datSou=winSpeSou,
          final p=winSpe)
          "Source selection for wind speed"
          annotation (Placement(transformation(extent={{120,-80},{140,-60}})));
        BaseClasses.SourceSelector winDirSel(
          final datSou=winDirSou,
          final p=winDir)
          "Source selection for wind speed"
          annotation (Placement(transformation(extent={{120,-280},{140,-260}})));
        BaseClasses.SourceSelector horInfRadSel(
          final datSou=HInfHorSou,
          final p=HInfHor)
          "Source selection for horizontal infrared radiation"
          annotation (Placement(transformation(extent={{120,60},{140,80}})));
        BaseClasses.SourceSelectorRadiation souSelRad(
          final datSou=HSou)
          "Source selection for solar irradiation"
          annotation (Placement(transformation(extent={{120,180},{140,200}})));

        BaseClasses.CheckDryBulbTemperature
          cheTemDryBul "Check dry bulb temperature "
          annotation (Placement(transformation(extent={{160,-200},{180,-180}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckDewPointTemperature
          cheTemDewPoi "Check dew point temperature"
          annotation (Placement(transformation(extent={{160,-240},{180,-220}})));
        Modelica.Blocks.Math.Gain conRelHum(final k=0.01)
          if relHumSou == Buildings.BoundaryConditions.Types.DataSource.File
          "Convert the relative humidity from percentage to [0, 1] "
          annotation (Placement(transformation(extent={{40,14},{60,34}})));
        BaseClasses.CheckPressure chePre "Check the air pressure"
          annotation (Placement(transformation(extent={{160,260},{180,280}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterRelativeHumidity limRelHum
          "Limiter for relative humidity"
          annotation (Placement(transformation(extent={{160,20},{180,40}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterTotalSkyCover limTotSkyCov
          "Limits the total sky cover"
          annotation (Placement(transformation(extent={{160,-40},{180,-20}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterOpaqueSkyCover limOpaSkyCov
          "Limits the opaque sky cover"
          annotation (Placement(transformation(extent={{160,-160},{180,-140}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterCeilingHeight limCeiHei "Limits the ceiling height"
          annotation (Placement(transformation(extent={{160,-120},{180,-100}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterWindSpeed limWinSpe "Limits the wind speed"
          annotation (Placement(transformation(extent={{160,-80},{180,-60}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterHorizontalInfraredIrradiation limHorInfRad
          "Limits the horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{160,60},{180,80}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterWindDirection limWinDir
          "Limits the wind direction"
          annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
        SkyTemperature.BlackBody TBlaSkyCom(final calTSky=calTSky)
          if TBlaSkySou == Buildings.BoundaryConditions.Types.DataSource.File
          "Computation of the black-body sky temperature"
          annotation (Placement(transformation(extent={{240,-220},{260,-200}})));
        Buildings.Utilities.Time.ModelTime modTim "Model time"
          annotation (Placement(transformation(extent={{-160,-10},{-140,10}})));
        Modelica.Blocks.Math.Add add30Min
          "Add 30 minutes to time to shift weather data reader"
          annotation (Placement(transformation(extent={{-112,180},{-92,200}})));
        Modelica.Blocks.Sources.Constant con30Min(final k=1800)
          "Constant used to shift weather data reader"
          annotation (Placement(transformation(extent={{-160,186},{-140,206}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(
            final lon=lon, final timZon=timZon) "Local civil time"
          annotation (Placement(transformation(extent={{-120,-160},{-100,-140}})));
        Modelica.Blocks.Tables.CombiTable1Ds datRea30Min(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          verboseRead=false,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns=9:11) "Data reader with 30 min offset for solar irradiation"
          annotation (Placement(transformation(extent={{-50,180},{-30,200}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTimMin(final
            weaDatStaTim=timeSpan[1], final weaDatEndTim=timeSpan[2])
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-80,180},{-60,200}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim(
          final weaDatStaTim = timeSpan[1],
          final weaDatEndTim = timeSpan[2])
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
        BaseClasses.EquationOfTime eqnTim "Equation of time"
          annotation (Placement(transformation(extent={{-120,-120},{-100,-100}})));
        BaseClasses.SolarTime solTim "Solar time"
          annotation (Placement(transformation(extent={{-88,-140},{-68,-120}})));


        Modelica.Blocks.Math.UnitConversions.From_deg conWinDir
          "Convert the wind direction unit from [deg] to [rad]"
          annotation (Placement(transformation(extent={{40,-286},{60,-266}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDryBul
          annotation (Placement(transformation(extent={{40,-200},{60,-180}})));


        Modelica.Blocks.Math.UnitConversions.From_degC conTDewPoi
          "Convert the dew point temperature form [degC] to [K]"
          annotation (Placement(transformation(extent={{40,-240},{60,-220}})));
        SolarGeometry.BaseClasses.AltitudeAngle altAng "Solar altitude angle"
          annotation (Placement(transformation(extent={{-28,-226},{-8,-206}})));
         SolarGeometry.BaseClasses.ZenithAngle zenAng
                            "Zenith angle"
          annotation (Placement(transformation(extent={{-70,-226},{-50,-206}})));
         SolarGeometry.BaseClasses.Declination decAng "Declination angle"
          annotation (Placement(transformation(extent={{-120,-220},{-100,-200}})));
         SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng "Solar hour angle"
          annotation (Placement(transformation(extent={{-120,-250},{-100,-230}})));
        Latitude latitude(final latitude=lat) "Latitude"
          annotation (Placement(transformation(extent={{-150,-290},{-130,-270}})));
        Longitude longitude(final longitude=lon) "Longitude"
          annotation (Placement(transformation(extent={{-120,-282},{-100,-262}})));
        Altitude altitude(final Altitude=alt) "Altitude"
          annotation (Placement(transformation(extent={{226,94},{246,114}})));
        //---------------------------------------------------------------------------
        // Optional instanciation of a block that computes the wet bulb temperature.
        // This block may be needed for evaporative cooling towers.
        // By default, it is enabled. This introduces a nonlinear equation, but
        // we have not observed an increase in computing time because of this equation.
        Buildings.Utilities.Psychrometrics.TWetBul_TDryBulPhi tWetBul_TDryBulXi(
            redeclare package Medium = Buildings.Media.Air,
            TDryBul(displayUnit="degC")) if computeWetBulbTemperature
          annotation (Placement(transformation(extent={{240,-60},{260,-40}})));

        //---------------------------------------------------------------------------
        // Conversion blocks for sky cover
        Modelica.Blocks.Math.Gain conTotSkyCov(final k=0.1)
          if totSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
        Modelica.Blocks.Math.Gain conOpaSkyCov(final k=0.1)
          if opaSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{40,-166},{60,-146}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckBlackBodySkyTemperature cheTemBlaSky(TMin=0)
          "Check black body sky temperature"
          annotation (Placement(transformation(extent={{240,-140},{260,-120}})));

        // Blocks that are added in order to set the name of the output signal,
        // which then is displayed in the GUI of the weather data connector.
        block Latitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.Units.SI.Angle latitude "Latitude";

          Modelica.Blocks.Interfaces.RealOutput y(
            unit="rad",
            displayUnit="deg") "Latitude of the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = latitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                textColor={0,0,0},
                  textString="Latitude")}),
          Documentation(info="<html>
<p>
Block to output the latitude of the location.
This block is added so that the latitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the latitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Latitude;

        block Longitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.Units.SI.Angle longitude "Longitude";

          Modelica.Blocks.Interfaces.RealOutput y(
            unit="rad",
            displayUnit="deg") "Longitude of the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = longitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                textColor={0,0,0},
                  textString="Longitude")}),
          Documentation(info="<html>
<p>
Block to output the longitude of the location.
This block is added so that the longitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the longitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Longitude;

        block Altitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.Units.SI.Length Altitude
            "Location altitude above sea level";

          Modelica.Blocks.Interfaces.RealOutput y(
            unit="m") "Location altitude above sea level"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = Altitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                textColor={0,0,0},
                  textString="Altitude")}),
          Documentation(info="<html>
<p>
Block to output the altitude of the location.
This block is added so that the altitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the Altitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Altitude;

      equation

        connect(modTim.y, add30Min.u2) annotation (Line(points={{-139,0},{-128,0},{-128,
                184},{-114,184}}, color={0,0,127}));
        connect(con30Min.y, add30Min.u1)
          annotation (Line(points={{-139,196},{-114,196}}, color={0,0,127}));
        connect(add30Min.y, conTimMin.modTim)
          annotation (Line(points={{-91,190},{-82,190}}, color={0,0,127}));
        connect(conTimMin.calTim, datRea30Min.u)
          annotation (Line(points={{-59,190},{-52,190}}, color={0,0,127}));
        connect(modTim.y, locTim.cloTim) annotation (Line(
            points={{-139,6.10623e-16},{-128,6.10623e-16},{-128,-150},{-122,-150}},
            color={0,0,127}));
        connect(modTim.y, conTim.modTim) annotation (Line(
            points={{-139,6.10623e-16},{-128,6.10623e-16},{-128,-30},{-102,-30}},
            color={0,0,127}));
        connect(conTim.calTim, datRea.u) annotation (Line(
            points={{-79,-30},{-72,-30}},
            color={0,0,127}));
        connect(modTim.y, eqnTim.nDay) annotation (Line(
            points={{-139,6.10623e-16},{-128,6.10623e-16},{-128,-110},{-122,-110}},
            color={0,0,127}));
        connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(
            points={{-99,-110},{-94,-110},{-94,-124},{-90,-124}},
            color={0,0,127}));
        connect(locTim.locTim, solTim.locTim) annotation (Line(
            points={{-99,-150},{-96,-150},{-96,-135.4},{-90,-135.4}},
            color={0,0,127}));
        connect(datRea.y[11], conWinDir.u) annotation (Line(
            points={{-49,-30},{20,-30},{20,-276},{38,-276}},
            color={0,0,127}));
        connect(datRea.y[1], conTDryBul.u) annotation (Line(
            points={{-49,-30},{20,-30},{20,-190},{38,-190}},
            color={0,0,127}));
        connect(datRea.y[2], conTDewPoi.u) annotation (Line(
            points={{-49,-30},{20,-30},{20,-230},{38,-230}},
            color={0,0,127}));
        connect(conRelHum.u, datRea.y[3]) annotation (Line(points={{38,24},{20,24},{20,
                -30},{-49,-30}},    color={0,0,127}));

        connect(decAng.decAng, zenAng.decAng)
                                        annotation (Line(
            points={{-99,-210},{-72,-210},{-72,-210.6}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, zenAng.solHouAng)  annotation (Line(
            points={{-99,-240},{-80,-240},{-80,-220.8},{-72,-220.8}},
            color={0,0,127}));
        connect(solHouAng.solTim, solTim.solTim) annotation (Line(
            points={{-122,-240},{-140,-240},{-140,-174},{-10,-174},{-10,-130},{-67,-130}},
            color={0,0,127}));
        connect(decAng.nDay, modTim.y) annotation (Line(
            points={{-122,-210},{-134,-210},{-134,-180},{0,-180},{0,6.10623e-16},{-139,
                6.10623e-16}},
            color={0,0,127}));
        connect(zenAng.zen, altAng.zen) annotation (Line(
            points={{-49,-216},{-30,-216}},
            color={0,0,127}));

        connect(limOpaSkyCov.nOpa, TBlaSkyCom.nOpa) annotation (Line(points={{181,-150},
                {220,-150},{220,-213},{238,-213}}, color={0,0,127}));
        connect(limRelHum.relHum, tWetBul_TDryBulXi.phi) annotation (Line(points={{181,30},
                {220,30},{220,-50},{239,-50}}, color={0,0,127}));

        connect(pAtmSel.y, chePre.PIn)
          annotation (Line(points={{21,270},{158,270}},   color={0,0,127}));
        connect(pAtmSel.uCon, pAtm_in) annotation (Line(points={{-1,278},{-110,278},{-110,
                274},{-220,274}}, color={0,0,127}));
        connect(datRea.y[4], pAtmSel.uFil) annotation (Line(points={{-49,-30},{-20,-30},
                {-20,262},{-1,262}}, color={0,0,127}));
        connect(cheTemDewPoi.TIn, TDewPoiSel.y)
          annotation (Line(points={{158,-230},{113,-230}}, color={0,0,127}));
        connect(TDewPoiSel.uFil, conTDewPoi.y) annotation (Line(points={{91,-238},{76,
                -238},{76,-230},{61,-230}}, color={0,0,127}));
        connect(TDewPoiSel.uCon, TDewPoi_in) annotation (Line(points={{91,-222},{82,-222},
                {82,146},{-168,146},{-168,224},{-220,224}}, color={0,0,127}));
        connect(TDryBulSel.y, cheTemDryBul.TIn)
          annotation (Line(points={{113,-190},{158,-190}}, color={0,0,127}));
        connect(TDryBulSel.uFil, conTDryBul.y) annotation (Line(points={{91,-198},{70,
                -198},{70,-190},{61,-190}}, color={0,0,127}));
        connect(TDryBulSel.uCon, TDryBul_in) annotation (Line(points={{91,-182},{78,-182},
                {78,142},{-176,142},{-176,180},{-220,180}}, color={0,0,127}));

        connect(TBlaSkySel.y, cheTemBlaSky.TIn) annotation (Line(points={{261,-170},{270,
                -170},{270,-148},{230,-148},{230,-130},{238,-130}}, color={0,0,127}));
        connect(TBlaSkyCom.TBlaSky, TBlaSkySel.uFil) annotation (Line(points={{261,-210},
                {268,-210},{268,-186},{232,-186},{232,-178},{239,-178}}, color={0,0,127}));
        connect(TBlaSky_in, TBlaSkySel.uCon) annotation (Line(points={{-220,140},{74,140},
                {74,-168},{228,-168},{228,-162},{239,-162}}, color={0,0,127}));
        connect(relHumSel.y, limRelHum.u)
          annotation (Line(points={{141,30},{158,30}}, color={0,0,127}));
        connect(relHumSel.uFil, conRelHum.y)
          annotation (Line(points={{119,22},{90,22},{90,24},{61,24}},
                                                       color={0,0,127}));
        connect(relHum_in, relHumSel.uCon) annotation (Line(points={{-220,100},{110,100},
                {110,38},{119,38}}, color={0,0,127}));
        connect(conOpaSkyCov.y, opaSkyCovSel.uFil)
          annotation (Line(points={{61,-156},{90,-156},{90,-158},{119,-158}},
                                                          color={0,0,127}));
        connect(opaSkyCov_in, opaSkyCovSel.uCon) annotation (Line(points={{-220,52},{70,
                52},{70,-142},{119,-142}}, color={0,0,127}));
        connect(ceiHeiSel.y, limCeiHei.u)
          annotation (Line(points={{141,-110},{158,-110}}, color={0,0,127}));
        connect(ceiHeiSel.uFil, datRea.y[16]) annotation (Line(points={{119,-118},{20,
                -118},{20,-30},{-49,-30}}, color={0,0,127}));
        connect(ceiHeiSel.uCon, ceiHei_in) annotation (Line(points={{119,-102},{-40,-102},
                {-40,-90},{-180,-90},{-180,10},{-220,10}}, color={0,0,127}));
        connect(totSkyCovSel.uFil, conTotSkyCov.y) annotation (Line(points={{119,-38},
                {100,-38},{100,-30},{61,-30}}, color={0,0,127}));
        connect(totSkyCovSel.uCon, totSkyCov_in) annotation (Line(points={{119,-22},{108,
                -22},{108,-50},{-190,-50},{-190,-38},{-220,-38}}, color={0,0,127}));
        connect(totSkyCovSel.y, limTotSkyCov.u)
          annotation (Line(points={{141,-30},{158,-30}}, color={0,0,127}));
        connect(winSpeSel.y, limWinSpe.u)
          annotation (Line(points={{141,-70},{158,-70}}, color={0,0,127}));
        connect(conTotSkyCov.u, datRea.y[13])
          annotation (Line(points={{38,-30},{-49,-30}}, color={0,0,127}));
        connect(winSpeSel.uFil, datRea.y[12]) annotation (Line(points={{119,-78},{-20,
                -78},{-20,-30},{-49,-30}}, color={0,0,127}));
        connect(winSpeSel.uCon, winSpe_in) annotation (Line(points={{119,-62},{-190,-62},
                {-190,-78},{-220,-78}}, color={0,0,127}));
        connect(winDirSel.y, limWinDir.u)
          annotation (Line(points={{141,-270},{158,-270}}, color={0,0,127}));
        connect(conWinDir.y, winDirSel.uFil)
          annotation (Line(points={{61,-276},{90,-276},{90,-278},{119,-278}},
                                                          color={0,0,127}));
        connect(winDirSel.uCon, winDir_in) annotation (Line(points={{119,-262},{66,-262},
                {66,-80},{-190,-80},{-190,-120},{-220,-120}}, color={0,0,127}));
        connect(conOpaSkyCov.u, datRea.y[14]) annotation (Line(points={{38,-156},{20,-156},
                {20,-30},{-49,-30}},       color={0,0,127}));
        connect(horInfRadSel.y, limHorInfRad.u) annotation (Line(points={{141,70},{158,
                70}},                      color={0,0,127}));
        connect(horInfRadSel.uFil, datRea.y[26]) annotation (Line(points={{119,62},{20,
                62},{20,-30},{-49,-30}},  color={0,0,127}));
        connect(horInfRadSel.uCon, HInfHor_in) annotation (Line(points={{119,78},{-174,
                78},{-174,-160},{-220,-160}},  color={0,0,127}));

        connect(souSelRad.HDifHorFil, datRea30Min.y[3]) annotation (Line(points={{119,199},
                {44,199},{44,190},{-29,190}}, color={0,0,127}));
        connect(souSelRad.HDifHorIn, HDifHor_in) annotation (Line(points={{119,196},{
                98,196},{98,166},{-170,166},{-170,-220},{-220,-220}},
                                                                   color={0,0,127}));
        connect(souSelRad.HDirNorFil, datRea30Min.y[2]) annotation (Line(points={{119,192},
                {44,192},{44,190},{-29,190}}, color={0,0,127}));
        connect(souSelRad.HDirNorIn, HDirNor_in) annotation (Line(points={{119,188},{
                100,188},{100,160},{-168,160},{-168,-260},{-220,-260}},
                                                                    color={0,0,127}));
        connect(souSelRad.HGloHorIn, HGloHor_in) annotation (Line(points={{119,181},{
                102,181},{102,156},{-164,156},{-164,-300},{-220,-300}},
                                                                    color={0,0,127}));
        connect(souSelRad.zen, zenAng.zen) annotation (Line(points={{124,179},{124,
                152},{-40,152},{-40,-216},{-49,-216}},
                                                  color={0,0,127}));
        connect(souSelRad.HGloHorFil, datRea30Min.y[1]) annotation (Line(points={{119,
                184},{44,184},{44,190},{-29,190}}, color={0,0,127}));

        connect(TBlaSkyCom.HHorIR, limHorInfRad.HHorIR) annotation (Line(points={{238,
                -218},{220,-218},{220,70},{181,70}}, color={0,0,127}));

        connect(opaSkyCovSel.y, limOpaSkyCov.u)
          annotation (Line(points={{141,-150},{158,-150}}, color={0,0,127}));
        connect(cheTemDryBul.TDryBul, TBlaSkyCom.TDryBul) annotation (Line(points={{
                181,-190},{220,-190},{220,-202},{238,-202}}, color={0,0,127}));
        connect(cheTemDryBul.TDryBul, tWetBul_TDryBulXi.TDryBul) annotation (Line(
              points={{181,-190},{220,-190},{220,-42},{239,-42}}, color={0,0,127}));

        connect(chePre.pAtm, tWetBul_TDryBulXi.p) annotation (Line(points={{181,270},
                {220,270},{220,-58},{239,-58}}, color={0,0,127}));

        connect(cheTemDewPoi.TDewPoi, TBlaSkyCom.TDewPoi) annotation (Line(points={{
                181,-230},{220,-230},{220,-207},{238,-207}}, color={0,0,127}));

        // Connections to weather data bus
        connect(cheTemDryBul.TDryBul, weaBus.TDryBul) annotation (Line(points={{181,
                -190},{220,-190},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(cheTemDewPoi.TDewPoi, weaBus.TDewPoi) annotation (Line(points={{181,
                -230},{280,-230},{280,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(tWetBul_TDryBulXi.TWetBul, weaBus.TWetBul) annotation (Line(
            points={{261,-50},{280,-50},{280,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(limRelHum.relHum, weaBus.relHum) annotation (Line(points={{181,30},{280,30},
                {280,0},{300,0}}, color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(souSelRad.HDirNor, weaBus.HDirNor) annotation (Line(points={{141,190},
                {220,190},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(souSelRad.HDifHor, weaBus.HDifHor) annotation (Line(points={{141,
                197.8},{220,197.8},{220,0},{300,0}},
                                              color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(souSelRad.HGloHor, weaBus.HGloHor) annotation (Line(points={{141,182},
                {220,182},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(cheTemBlaSky.TBlaSky, weaBus.TBlaSky) annotation (Line(points={{261,
                -130},{280,-130},{280,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(limHorInfRad.HHorIR, weaBus.HHorIR) annotation (Line(points={{181,70},
                {220,70},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(limWinSpe.winSpe, weaBus.winSpe) annotation (Line(points={{181,-70},{220,
                -70},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(limWinDir.winDir, weaBus.winDir) annotation (Line(points={{181,-270},{280,
                -270},{280,0},{300,0}}, color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(limCeiHei.ceiHei, weaBus.ceiHei) annotation (Line(points={{181,-110},{
                220,-110},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(limTotSkyCov.nTot, weaBus.nTot) annotation (Line(points={{181,-30},{220,
                -30},{220,0},{300,0}}, color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(limOpaSkyCov.nOpa, weaBus.nOpa) annotation (Line(points={{181,-150},{220,
                -150},{220,0},{300,0}}, color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(modTim.y, weaBus.cloTim) annotation (Line(
            points={{-139,6.10623e-16},{34.75,6.10623e-16},{34.75,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(solTim.solTim, weaBus.solTim) annotation (Line(
            points={{-67,-130},{-10,-130},{-10,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(altAng.alt, weaBus.solAlt) annotation (Line(
            points={{-7,-216},{0,-216},{0,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(zenAng.zen, weaBus.solZen) annotation (Line(
            points={{-49,-216},{-40,-216},{-40,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(decAng.decAng, weaBus.solDec) annotation (Line(
            points={{-99,-210},{-90,-210},{-90,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, weaBus.solHouAng) annotation (Line(
            points={{-99,-240},{-90,-240},{-90,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(longitude.y, weaBus.lon) annotation (Line(
            points={{-99,-272},{-90,-272},{-90,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(latitude.y, weaBus.lat) annotation (Line(
            points={{-129,-280},{-124,-280},{-124,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(altitude.y, weaBus.alt) annotation (Line(points={{247,104},{290,104},{
                290,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(chePre.pAtm, weaBus.pAtm) annotation (Line(points={{181,270},{220,270},
                {220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(latitude.y, zenAng.lat) annotation (Line(points={{-129,-280},{-124,
                -280},{-124,-290},{-90,-290},{-90,-216},{-72,-216}}, color={0,0,127}));
          annotation (
          defaultComponentName="weaDat",
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-200,-200},{200,200}},
              initialScale=0.05), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={124,142,255},
                fillColor={124,142,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-162,270},{138,230}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                visible=(pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,216},{-164,184}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                visible=(TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-194,162},{-118,118}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                visible=(relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,92},{-104,66}},
                lineColor={0,0,127},
                textString="relHum"),
              Text(
              visible=(winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-196,44},{-110,2}},
                lineColor={0,0,127},
                textString="winSpe"),
              Text(
                visible=(winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-192,-18},{-106,-60}},
                lineColor={0,0,127},
                textString="winDir"),
              Text(
              visible=(HSou ==  Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor),
              extent={{-202,-88},{-112,-108}},
                lineColor={0,0,127},
                textString="HGloHor"),
              Text(visible=(HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-202,-142},{-116,-164}},
                lineColor={0,0,127},
                textString="HDifHor"),
              Text(
              visible=(HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-200,-186},{-126,-214}},
                lineColor={0,0,127},
                textString="HDirNor"),
              Ellipse(
                extent={{-146,154},{28,-20}},
                lineColor={255,220,220},
                lineThickness=1,
                fillPattern=FillPattern.Sphere,
                fillColor={255,255,0}),
              Polygon(
                points={{94,106},{77.9727,42.9844},{78,42},{110,52},{138,50},{164,38},
                    {182,-28},{138,-102},{10,-110},{-140,-106},{-166,-30},{-150,24},{-102,
                    26},{-78.2109,8.1582},{-78,8},{-92,70},{-58,120},{34,140},{94,106}},
                lineColor={220,220,220},
                lineThickness=0.1,
                fillPattern=FillPattern.Sphere,
                smooth=Smooth.Bezier,
                fillColor={230,230,230}),
              Text(
                extent={{140,-106},{-126,-192}},
                textColor={255,255,255},
                textString=DynamicSelect("", String(weaBus.TDryBul-273.15, format=".1f")))}),
          Documentation(info="<html>
<p>
This component reads TMY3 weather data (Wilcox and Marion, 2008) or user specified weather data.
The Modelica built-in variable <code>time</code> determines what row
of the weather file is read.
The value of <code>time</code> is the number of seconds
that have passed since January 1st at midnight (00:00) in the local time zone.
The local time zone value, longitude and latitute are also read from the weather data,
such that the solar position computations are consistent with the weather data.
</p>
<p>
The weather data format is the Typical Meteorological Year (TMY3)
as obtained from the EnergyPlus web site at
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>. These
data, which are in the EnergyPlus format, need to be converted as described
below.
</p>
<!-- ============================================== -->
<h4>Output to weaBus</h4>
<p>
The following variables serve as output and are accessible via <code>weaBus</code>:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Name
  </th>
  <th>Unit
  </th>
  <th>Description
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal diffuse solar radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifNor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Direct normal radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HGloHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal global radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HHorIR</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal infrared irradiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TBlaSky</code>
  </td>
  <td>
    K
  </td>
  <td>
    Output temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDewPoi</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dew point temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDryBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dry bulb temperature at ground level.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TWetBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Wet bulb temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>celHei</code>
  </td>
  <td>
    m
  </td>
  <td>
    Ceiling height.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>cloTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    One-based day number in seconds.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lat</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Latitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lon</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Longitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nOpa</code>
  </td>
  <td>
    1
  </td>
  <td>
  Opaque sky cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nTot</code>
  </td>
  <td>
    1
  </td>
  <td>
   Total sky Cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>pAtm</code>
  </td>
  <td>
    Pa
  </td>
  <td>
    Atmospheric pressure.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>relHum</code>
  </td>
  <td>
    1
  </td>
  <td>
    Relative humidity.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solAlt</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Altitude angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solDec</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Declination angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solHouAng</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Solar hour angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    Solar time.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solZen</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Zenith angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winDir</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Wind direction.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winSpe</code>
  </td>
  <td>
    m/s
  </td>
  <td>
    Wind speed.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Adding new weather data</h4>
<p>
To add new weather data, proceed as follows:
</p>
<ol>
<li>
Download the weather data file with the <code>epw</code> extension from
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>.
</li>
<li>
Add the file to <code>Buildings/Resources/weatherdata</code> (or to any directory
for which you have write permission).
</li>
<li>
On a console window, type<pre>
  cd Buildings/Resources/weatherdata
  java -jar ../bin/ConvertWeatherData.jar inputFile.epw
</pre>
  if inputFile contains space in the name:
<pre>
  java -jar ../bin/ConvertWeatherData.jar \"inputFile .epw\"
</pre>
This will generate the weather data file <code>inputFile.mos</code>, which can be read
by the model
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</li>
</ol>
<!-- ============================================== -->
<h4>Location data that are read automatically from the weather data file</h4>
<p>
The following location data are automatically read from the weather file:
</p>
<ul>
<li>
The latitude of the weather station, <code>lat</code>,
</li>
<li>
the longitude of the weather station, <code>lon</code>, and
</li>
<li>
the time zone relative to Greenwich Mean Time, <code>timZone</code>.
</li>
</ul>
<!-- ============================================== -->
<h4>Wet bulb temperature</h4>
<p>
By default, the data bus contains the wet bulb temperature.
This introduces a nonlinear equation.
However, we have not observed an increase in computing time because
of this equation.
To disable the computation of the wet bulb temperature, set
<code>computeWetBulbTemperature=false</code>.
</p>
<!-- ============================================== -->
<h4>Using constant or user-defined input signals for weather data</h4>
<p>
This model has the option of using a constant value, using the data from the weather file,
or using data from an input connector for the following variables:
</p>
<ul>
<li>
The atmospheric pressure,
</li>
<li>
the ceiling height,
</li>
<li>
the total sky cover,
</li>
<li>
the opaque sky cover,
</li>
<li>
the dry bulb temperature,
</li>
<li>
the dew point temperature,
</li>
<li>
the sky black body temperature,
</li>
<li>
the relative humidity,
</li>
<li>
the wind direction,
</li>
<li>
the wind speed,
</li>
<li>
the global horizontal radiation, direct normal and diffuse horizontal radiation,
and
</li>
<li>
the infrared horizontal radiation.
</li>
</ul>
<p>
By default, all data are obtained from the weather data file,
except for the atmospheric pressure, which is set to the
parameter <code>pAtm=101325</code> Pascals.
</p>
<p>
The parameter <code>*Sou</code> configures the source of the data.
For the atmospheric pressure, temperatures, relative humidity, wind speed and wind direction,
the enumeration
<a href=\"modelica://Buildings.BoundaryConditions.Types.DataSource\">
Buildings.BoundaryConditions.Types.DataSource</a>
is used as follows:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>*Sou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Parameter
  </td>
  <td>
    Use value specified by the parameter.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input
  </td>
  <td>
    Use value from the input connector.
  </td>
</tr>
</table>
<p>
Because global, diffuse and direct radiation are related to each other, the parameter
<code>HSou</code> is treated differently.
It is set to a value of the enumeration
<a href=\"modelica://Buildings.BoundaryConditions.Types.RadiationDataSource\">
Buildings.BoundaryConditions.Types.RadiationDataSource</a>,
and allows the following configurations:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>HSou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input_HGloHor_HDifHor
  </td>
  <td>
    Use global horizontal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HDifHor
  </td>
  <td>
    Use direct normal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HGloHor
  </td>
  <td>
    Use direct normal and global horizontal radiation from input connector.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Length of weather data and simulation period</h4>
<p>
If weather data span a year, which is the default for TMY3 data, or multiple years,
then this model can be used for simulations that span multiple years. The simulation
start time needs to be set to the clock time of the respective start time. For example,
to start at January 2 at 10am, set start time to <code>t=(24+10)*3600</code> seconds.
For this computation, the used date and time (here January 2, 10 am) must be expressed in the same time zone
as the one that is used to define the TMY3 file. This is usually the local (winter) time zone.
The parameter `timZon` represents the TMY3 file time zone, expressed in seconds compared to UTC.
</p>
<p>
Moreover, weather data need not span a whole year, or it can span across New Year.
In this case, the simulation cannot exceed the time of the weather data file. Otherwise,
the simulation stops with an error.
</p>
<p>
As weather data have one entry at the start of the time interval, the end time of the weather
data file is computed as the last time entry plus the average time increment of the file.
For example, an hourly weather data file has 8760 entries, starting on January 1 at 0:00.
The last entry in the file will be for December 31 at 23:00. As the time increment is 1 hour,
the model assumes the weather file to end at December 31 at 23:00 plus 1 hour, e.g., at January 1 at 0:00.
</p>
<!-- ============================================== -->
<h4>Notes</h4>
<ol>
<li>
<p>
In HVAC systems, when the fan is off, changes in atmospheric pressure can cause small air flow rates
in the duct system due to change in pressure and hence in the mass of air that is stored
in air volumes (such as in fluid junctions or in the room model).
This may increase computing time. Therefore, the default value for the atmospheric pressure is set to a constant.
Furthermore, if the initial pressure of air volumes are different
from the atmospheric pressure, then fast pressure transients can happen in the first few seconds of the simulation.
This can cause numerical problems for the solver. To avoid this problem, set the atmospheric pressure to the
same value as the medium default pressure, which is typically set to the parameter <code>Medium.p_default</code>.
For medium models for moist air and dry air, the default is
<code>Medium.p_default=101325</code> Pascals.
</p>
</li>
<li>
<p>
Different units apply depending on whether data are obtained from a file, or
from a parameter or an input connector:
</p>
<ul>
<li>
When using TMY3 data from a file (e.g. <code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos</code>), the units must be the same as the original TMY3 file used by EnergyPlus (e.g.
<code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.epw</code>).
The TMY3 data used by EnergyPlus are in both SI units and non-SI units.
If <code>Resources/bin/ConvertWeatherData.jar</code> is used to convert the <code>.epw</code> file to an <code>.mos</code> file, the units of the TMY3 data are preserved and the file can be directly
used by this data reader.
The data reader will automatically convert units to the SI units used by Modelica.
For example, the dry bulb temperature <code>TDryBul</code> in TMY3 is in degree Celsius.
The data reader will automatically convert the data to Kelvin.
The wind direction <code>winDir</code> in TMY3 is degrees and will be automatically converted to radians.
</li>
<li>
When using data from a parameter or from an input connector,
the data must be in the SI units used by Modelica.
For instance, the unit must be
<code>Pa</code> for pressure,
<code>K</code> for temperature,
<code>W/m2</code> for solar radiations and
<code>rad</code> for wind direction.
</li>
</ul>
</li>
<li>
<p>
Hourly and subhourly timestamp are handled in a different way in <code>.epw</code> files.
From the EnergyPlus Auxiliary Programs Document (v9.3.0, p. 63):
In hourly data the minute field can be <code>00</code> or <code>60</code>. In this case as mentioned in the previous section, the weather data
is reported at the hourly value and the minute field has to be ignored, writing <code>1, 60</code> or <code>1, 00</code> is equivalent.
If the minute field is between <code>00</code> and <code>60</code>, the file becomes subhourly, in this case the timestamp corresponds to the
minute field in the considered hour. For example: <code>1, 30</code> is equivalent to <i>00:30</i> and <code>3, 45</code> is equivalent to <i>02:45</i>.<br/>
(Note the offset in the hour digit.)
</p>
</li>
<li>
The ReaderTMY3 should only be used with TMY3 data. It contains a time shift for solar radiation data
that is explained below. This time shift needs to be removed if the user may want to
use the ReaderTMY3 for other weather data types.
</li>
</ol>
<h4>Implementation</h4>
<h5>Start and end data for annual weather data files</h5>
<p>
The TMY3 weather data, as well as the EnergyPlus weather data, start at 1:00 AM
on January 1, and provide hourly data until midnight on December 31.
Thus, the first entry for temperatures, humidity, wind speed etc. are values
at 1:00 AM and not at midnight. Furthermore, the TMY3 weather data files can have
values at midnight of December 31 that may be significantly different from the values
at 1:00 AM on January 1.
Since annual simulations require weather data that start at 0:00 on January 1,
data need to be provided for this hour. Due to the possibly large change in
weatherdata between 1:00 AM on January 1 and midnight at December 31,
the weather data files in the Buildings library do not use the data entry from
midnight at December 31 as the value for <i>t=0</i>. Rather, the
value from 1:00 AM on January 1 is duplicated and used for 0:00 on January 1.
To maintain a data record with <i>8760</i> hours, the weather data record from
midnight at December 31 is deleted.
These changes in the weather data file are done in the Java program
<code>Buildings/Resources/bin/ConvertWeatherData.jar</code> that converts
EnergyPlus weather data file to Modelica weather data files, and which is described
above.
The length of the weather data is calculated as the
end time stamp minus start time stamp plus average increment, where the
average increment is equal to the end time stamp minus start time stamp divided
by the number of rows minus 1.
This only works correctly for weather files with equidistant time stamps.
</p>
<h5>Time shift for solar radiation data</h5>
<p>
To read weather data from the TMY3 weather data file, there are
two data readers in this model. One data reader obtains all data
except solar radiation, and the other data reader reads only the
solar radiation data, shifted by <i>30</i> minutes.
The reason for this time shift is as follows:
The TMY3 weather data file contains for solar radiation the
\"...radiation received
on a horizontal surface during
the 60-minute period ending at
the timestamp.\"

Thus, as the figure below shows, a more accurate interpolation is obtained if
time is shifted by <i>30</i> minutes prior to reading the weather data.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/BoundaryConditions/WeatherData/RadiationTimeShift.png\"
border=\"1\" />
</p>
<h4>References</h4>
<ul>
<li>
Wilcox S. and W. Marion. <i>Users Manual for TMY3 Data Sets</i>.
Technical Report, NREL/TP-581-43156, revised May 2008.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed alt and lat to real inputs.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Added altitude to parameters.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 4, 2020, by Ettore Zanetti:<br/>
Updated documentation for Java weather file generator.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1396\">#1396</a>.
</li>
<li>
August 20, 2019, by Filip Jorissen:<br/>
Better clarified the meaning of <code>time</code> in the documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1192\">#1192</a>.
</li>
<li>
March 5, 2019, by Michael Wetter:<br/>
Updated documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
<li>
September 20, 2018, by Michael Wetter:<br/>
Corrected documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1022\">#1022</a>.
</li>
<li>
December 4, 2017, by Michael Wetter:<br/>
Removed function call to <code>getAbsolutePath</code>, as this causes in Dymola 2018FD01
the error
\"A call of loadResource with a non-literal string remains in the generated code; it will not work for an URI.\"
when exporting <a href=\"modelica://Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone\">
Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone</a>
as an FMU. Instead, if the weather file is specified as a Modelica, URI, syntax such as
<code>Modelica.Utilities.Files.loadResource(\"modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos\")</code>
should be used.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/867\">#867</a>.
</li>
<li>
February 18, 2017, by Filip Jorissen:<br/>
Infrared radiation on horizontal surface is now delayed by 30 minutes
such that the results in
<a href=\"modelica://Buildings.BoundaryConditions.SkyTemperature.Examples.BlackBody\">TBlaSky</a>
are consistent.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/648\">#648</a>.
</li>
<li>
December 06, 2016, by Thierry S. Nouidui:<br/>
Constrained the direct normal radiation to not be bigger than the solar constant when using
global and diffuse solar radiation data provided via the inputs connectors.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/608\">#608</a>.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Introduced <code>absFilNam</code> to avoid multiple calls to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed output <code>radHorIR</code> to <code>HHorIR</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
January 4, 2016, by Moritz Lauster:<br/>
Added a table in documentation with output variables accessible via <code>weaBus</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
December 15, 2015, by Michael Wetter:<br/>
Added the block <code>cheTemBlaSky</code>. This also allows to graphically
connect the black body sky temperature to the weather bus, which is required
in Dymola 2016 for the variable <code>weaBus.TBlaSky</code> to appear
in the graphical editor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/377\">#377</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed redundant but consistent
<code>connect(TBlaSkyCom.TBlaSky, weaBus.TBlaSky)</code>
statement.
This avoids a warning if
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness\">
Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness</a>
is translated in pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
March 26, 2015, by Michael Wetter:<br/>
Added option to obtain the black body sky temperature
from a parameter or an input signal.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Corrected error that led the total and opaque sky cover to be ten times
too low if its value was obtained from the parameter or the input connector.
For the standard configuration in which the sky cover is obtained from
the weather data file, the model was correct. This error only affected
the other two possible configurations.
</li>
<li>
September 12, 2014, by Michael Wetter:<br/>
Removed redundant connection <code>connect(conHorRad.HOut, cheHorRad.HIn);</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
May 5, 2013, by Thierry S. Nouidui:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the ceiling height, the total sky cover, the opaque sky cover, the dew point temperature,
and the infrared horizontal radiation <code>HInfHor</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Improved the algorithm that determines the absolute path of the file.
Now weather files are searched in the path specified, and if not found, the urls
<code>file://</code>, <code>modelica://</code> and <code>modelica://Buildings</code>
are added in this order to search for the weather file.
This allows using the data reader without having to specify an absolute path,
as long as the <code>Buildings</code> library
is on the <code>MODELICAPATH</code>.
This change was implemented in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
and improves this weather data reader.
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
October 16, 2012, by Michael Wetter:<br/>
Added computation of the wet bulb temperature.
Computing the wet bulb temperature introduces a nonlinear
equation. As we have not observed an increase in computing time
because of computing the wet bulb temperature, it is computed
by default. By setting the parameter
<code>computeWetBulbTemperature=false</code>, the computation of the
wet bulb temperature can be removed.
Revised documentation.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code> and
improved the optional inputs for radiation data.
</li>
<li>
July 24, 2012, by Wangda Zuo:<br/>
Corrected the notes of SI unit requirements for input files.
</li>
<li>
July 13, 2012, by Michael Wetter:<br/>
Removed assignment of <code>HGloHor_in</code> in its declaration,
because this gives an overdetermined system if the input connector
is used.
Removed non-required assignments of attribute <code>displayUnit</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Added subbus for solar position, which is needed by irradition and
shading model.
</li>
<li>
November 29, 2011, by Michael Wetter:<br/>
Fixed wrong display unit for <code>pAtm_in_internal</code> and
made propagation of parameter final.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
<ol>
<li>
Added optional connectors for dry bulb temperature, relative humidity, wind speed, wind direction, global horizontal radiation, diffuse horizontal radiation.<br/>
</li>
<li>
Separate the unit conversion for TMY3 data and data validity check.
</li>
</ol>
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Propagated value for sky temperature calculation to make it accessible as a parameter.
</li>
<li>
July 20, 2011, by Michael Wetter:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the atmospheric pressure.
</li><li>
March 15, 2011, by Wangda Zuo:<br/>
Delete the wet bulb temperature since it may cause numerical problem.
</li>
<li>
March 7, 2011, by Wangda Zuo:<br/>
Added wet bulb temperature. Changed reader to read only needed columns.
Added explanation for 30 minutes shift for radiation data.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
Changed implementation to obtain longitude and time zone directly
from weather file.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=false,
           extent={{-200,-300},{300,300}})));
      end ReaderTMY3;

      package BaseClasses
      "Package with base classes for Buildings.BoundaryConditions.WeatherData"
        extends Modelica.Icons.BasesPackage;

        block CheckBlackBodySkyTemperature
          "Check the validity of the black-body sky temperature data"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.Units.SI.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.Units.SI.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";

          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Black-body sky temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Modelica.Blocks.Interfaces.RealOutput TBlaSky(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Black-body sky temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          TBlaSky = TIn;
          assert(noEvent(TIn > TMin and TIn < TMax),
            "In " + getInstanceName() + ": Weather data black-body sky temperature out of bounds.\n" + "   TIn = " +
             String(TIn));

          annotation (
            defaultComponentName="cheSkyBlaBodTem",
            Documentation(info="<html>
<p>
This component checks the value of the black-body sky temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> and removed output connector.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
January 5, 2015 by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature</a>.
This was implemented to get the corrected documentation string in the weather bus connector.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Ellipse(
                  extent={{-20,-78},{20,-40}},
                  lineColor={99,17,20},
                  lineThickness=0.5,
                  fillColor={99,17,20},
                  fillPattern=FillPattern.Solid),
                Line(points={{-40,40},{-12,40}}),
                Line(points={{-40,10},{-12,10}}),
                Line(points={{-40,-20},{-12,-20}}),
                Rectangle(
                  extent={{-12,40},{12,-44}},
                  lineColor={99,17,20},
                  fillColor={99,17,20},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-12,40},{-12,60},{-10,66},{-6,68},{0,70},{6,68},{10,66},{12,
                      60},{12,40},{-12,40}},
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-45}},
                  thickness=0.5)}));
        end CheckBlackBodySkyTemperature;

        block CheckDewPointTemperature
          "Check the validity of the dew point temperature data"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Input Temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TDewPoi(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Dew point temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          parameter Modelica.Units.SI.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.Units.SI.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";

        equation
          TDewPoi = TIn;
          assert(noEvent(TIn > TMin and TIn < TMax), "In " + getInstanceName() +
             ": Weather data dew point temperature out of bounds.\n" + "   TIn = " + String(
            TIn));
          annotation (
            defaultComponentName="cheTem",
            Documentation(info="<html>
<p>
This component checks the value of temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Ellipse(
                  extent={{-22,-74},{18,-36}},
                  lineColor={0,0,127},
                  lineThickness=0.5,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Line(points={{-42,44},{-14,44}}),
                Line(points={{-42,14},{-14,14}}),
                Line(points={{-42,-16},{-14,-16}}),
                Rectangle(
                  extent={{-14,44},{10,-40}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-14,44},{-14,64},{-12,70},{-8,72},{-2,74},{4,72},{8,70},{10,64},
                      {10,44},{-14,44}},
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-14,44},{-14,-41}},
                  thickness=0.5)}));
        end CheckDewPointTemperature;

        block CheckDryBulbTemperature
          "Check the validity of the dry bulb temperature data"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Input Temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TDryBul(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Dry bulb temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          parameter Modelica.Units.SI.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.Units.SI.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";

        equation
          TDryBul = TIn;
          assert(noEvent(TIn > TMin and TIn < TMax), "In " + getInstanceName() +
             ": Weather data dry bulb temperature out of bounds.\n" + "   TIn = " + String(
            TIn));
          annotation (
            defaultComponentName="cheTem",
            Documentation(info="<html>
<p>
This component checks the value of the dry bulb temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Ellipse(
                  extent={{-18,-72},{22,-34}},
                  lineColor={0,0,0},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{-38,46},{-10,46}}),
                Line(points={{-38,16},{-10,16}}),
                Line(points={{-38,-14},{-10,-14}}),
                Rectangle(
                  extent={{-10,46},{14,-38}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-10,46},{-10,66},{-8,72},{-4,74},{2,76},{8,74},{12,72},{14,66},
                      {14,46},{-10,46}},
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-10,46},{-10,-39}},
                  thickness=0.5)}));
        end CheckDryBulbTemperature;

        block CheckPressure
          "Ensures that the interpolated pressure is between prescribed bounds"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput PIn(
            final quantity="Pressure",
            final unit="Pa") "Atmospheric pressure"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput pAtm(
            final quantity="Pressure",
            final unit="Pa") "Atmospheric pressure"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.Units.SI.Pressure PMin=3100 "Minimum allowed pressure";
          constant Modelica.Units.SI.Pressure PMax=120000 "Maximum allowed pressure";
        equation
          pAtm = PIn;
          assert(noEvent(PIn > PMin and PIn < PMax), "In " + getInstanceName() +
            ": Weather data atmospheric pressure out of bounds.\n" + "   PIn = " + String(PIn));

          annotation (
            defaultComponentName="chePre",
            Documentation(info="<html>
<p>
This component ensures that the interpolated pressure is between <i>31,000</i> Pa and <i>120,000</i> Pa.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> and removed output connector.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  textColor={0,0,255},
                  textString="P")}));
        end CheckPressure;

        block ConvertTime
          "Converts the simulation time to calendar time in scale of 1 year (365 days), or a multiple of a year"
          extends PartialConvertTime;
          Modelica.Blocks.Interfaces.RealInput modTim(
            final quantity="Time",
            final unit="s") "Simulation time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput calTim(
            final quantity="Time",
            final unit="s") "Calendar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      protected
          constant Modelica.Units.SI.Time shiftSolarRad=1800
            "Number of seconds for the shift for solar radiation calculation";


        equation
          calTim = calTimAux;
          modTimAux = modTim;
          assert(canRepeatWeatherFile or noEvent((time - weaDatEndTim) < shiftSolarRad),
            "In " + getInstanceName() + ": Insufficient weather data provided for the desired simulation period.
    The simulation time "         + String(time) +
            " exceeds the end time " + String(weaDatEndTim) + " of the weather data file.",
            AssertionLevel.error);

          assert(canRepeatWeatherFile or noEvent(time >= weaDatStaTim),
            "In " + getInstanceName() + ": Insufficient weather data provided for the desired simulation period.
    The simulation time "         + String(time) +
            " is less than the start time " + String(weaDatStaTim) + " of the weather data file.",
            AssertionLevel.error);

          annotation (
            defaultComponentName="conTim",
            Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days),
or a multiple of it, if this is the length of the weather file.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Updated to use partial class for conversion from simulation time to calendar time.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
<li>
April 15, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> to assertion to remove zero crossing function in OPTIMICA.
</li>
<li>
January 29, 2020, by Filip Jorissen:<br/>
Revised end time assert and added assert that verifies whether the time is before the
start time of the weather file.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1281\">#1281</a>.
</li>
<li>
June 12, 2019, by Michael Wetter:<br/>
Reformulated model to avoid having to evaluate the weather file during compilation
(as it determined the structural parameter <code>lenWea</code>). The new formulation
allows inclusion of the weather file in JModelica-generated FMUs, and it works with
Dymola as well.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1147\">#1147</a>.
</li>
<li>
May 21, 2019, by Michael Wetter:<br/>
Corrected code to avoid wrong type conversion.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1142\">#1142</a>.
</li>
<li>
March 4, 2019, by Michael Wetter:<br/>
Refactored implementation to correctly account for negative start times.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
<li>
July 27, 2018, by Ana Constantin:<br/>
Added shift for multiple time spans.
</li>
<li>
September 27, 2011, by Wangda Zuo and Michael Wetter:<br/>
Modify it to convert negative value of time.
Use the when-then to allow dymola differentiating this model when
conducting index reduction which is not allowed in previous implementation.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
Renamed the component.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-98,6},{-74,-4}},
                  textColor={0,0,127},
                  textString="modTim"),
                Text(
                  extent={{74,6},{98,-4}},
                  textColor={0,0,127},
                  textString="calTim"),
                Rectangle(
                  extent={{-66,76},{60,58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  fillColor={120,120,120}),
                Rectangle(extent={{-66,58},{60,-62}}, lineColor={0,0,0}),
                Line(
                  points={{-24,-62},{-24,58}}),
                Line(
                  points={{18,-62},{18,58}}),
                Line(
                  points={{60,28},{-66,28}}),
                Line(
                  points={{60,-2},{-66,-2}}),
                Line(
                  points={{60,-32},{-66,-32}})}));
        end ConvertTime;

        block EquationOfTime "Equation of time"
          extends PartialConvertTime;
          Modelica.Blocks.Interfaces.RealInput nDay(
            quantity="Time",
            unit="s")
            "Zero-based day number in seconds (January 1=0, January 2=86400)"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput eqnTim(
            final quantity="Time",
            final unit="s",
            displayUnit="min") "Equation of time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real Bt "Intermediate variable";
        equation
          modTimAux = nDay;
          Bt = Modelica.Constants.pi*((calTimAux + 86400)/86400 - 81)/182
            "Our unit is s instead of day in (A.4.2b)";
          eqnTim = 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) - 1.5*
            Modelica.Math.sin(Bt)) "Our unit is s instead of min in (A.4.2a)";
          annotation (
            defaultComponentName="eqnTim",
            Documentation(info="<html>
<p>
This component computes the difference between solar noon and noon of local civil time.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Updated to use partial class for conversion from simulation time to calendar time.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  textColor={0,0,255}),
                Text(
                  extent={{-58,38},{38,-24}},
                  textColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-6,4},{52,-24}},
                  textColor={0,0,255},
                  textString="equ")}));
        end EquationOfTime;

        block LimiterCeilingHeight "Block that limits the relative humidity"
          extends PartialLimiterMin;

          Modelica.Blocks.Interfaces.RealOutput ceiHei(
            final unit="m") = max(0, u) "Cloud cover ceiling height"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (
        defaultComponentName="limMin",
        Documentation(info="<html>
<p>
Block that limits the cloud cover ceiling height to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterCeilingHeight;

        block LimiterHorizontalInfraredIrradiation
          "Block that limits the horizontal infrared irradiation"
          extends PartialLimiterMin;

          Modelica.Blocks.Interfaces.RealOutput HHorIR(
            final unit="W/m2") = max(0, u) "Horizontal infrared irradiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          annotation (
        defaultComponentName="limMin",
        Documentation(info="<html>
<p>
Block that limits the horizontal infrared irradiation to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterHorizontalInfraredIrradiation;

        block LimiterOpaqueSkyCover "Block that limits the opaque sky cover"
          extends PartialLimiter;

          Modelica.Blocks.Interfaces.RealOutput nOpa(
            final unit="1") "Opaque sky cover"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          nOpa = min(uMax, max(uMin, u));

          annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that limits the opaque sky cover.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterOpaqueSkyCover;

        block LimiterRelativeHumidity "Block that limits the relative humidity"
          extends PartialLimiter;

          Modelica.Blocks.Interfaces.RealOutput relHum(
            final unit="1") "Relative humidity"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          relHum = min(uMax, max(uMin, u));

          annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that limits the relative humidity.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterRelativeHumidity;

        block LimiterTotalSkyCover "Block that limits the total sky cover"
          extends PartialLimiter;

          Modelica.Blocks.Interfaces.RealOutput nTot(
            final unit="1") "Total sky cover"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          nTot = min(uMax, max(uMin, u));

          annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that limits the total sky cover.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterTotalSkyCover;

        block LimiterWindDirection "Block that limits the wind direction"
          extends PartialLimiter(
            final uMax=2*Modelica.Constants.pi);

          Modelica.Blocks.Interfaces.RealOutput winDir(
            final unit="rad") "Wind direction"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          winDir = min(uMax, max(uMin, u));

          annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that limits the wind direction.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterWindDirection;

        block LimiterWindSpeed "Block that limits the wind speed"
          extends PartialLimiterMin;

          Modelica.Blocks.Interfaces.RealOutput winSpe(
            final unit="m/s") = max(0, u) "Wind speed"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          annotation (
        defaultComponentName="limMin",
        Documentation(info="<html>
<p>
Block that limits the wind speed to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterWindSpeed;

        block LocalCivilTime "Converts the clock time to local civil time."
          extends PartialConvertTime;
          Modelica.Blocks.Interfaces.RealInput cloTim(
            final quantity="Time",
            final unit="s") "Clock time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          parameter Modelica.Units.SI.Time timZon(displayUnit="h") "Time zone";
          parameter Modelica.Units.SI.Angle lon(displayUnit="deg") "Longitude";
          Modelica.Blocks.Interfaces.RealOutput locTim(
            final quantity="Time",
            final unit="s") "Local civil time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          final parameter Modelica.Units.SI.Time diff=-timZon + lon*43200/Modelica.Constants.pi
            "Difference between local and clock time";
        equation
          modTimAux = cloTim;
          locTim = calTimAux + diff;

          annotation (
            defaultComponentName="locTim",
            Documentation(info="<html>
<p>
This component converts the clock time to local civil time.
The parameter <code>timZon</code> represents the time zone of the facility  (relative to Greenwich Mean Time or the 0th meridian). Time zones west of GMT (e.g. North America) are represented as negative;
east of GMT as positive. Fraction of hours are represented in decimals (e.g. for <i>6:30</i>, use <i>6.5</i>).
</p>
<p>
The formula is based on Michael Wetter's thesis (A4.1):
</p>
<pre>
  locTim = greTim + (lon*180/pi)*86400/360 = cloTim - timZon + lon*43200/pi
</pre>
</html>",         revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Updated to use partial class for conversion from simulation time to calendar time.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
<li>
November 14, 2015, by Michael Wetter:<br/>
Introduced <code>diff</code>.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-98,6},{-60,-6}},
                  textColor={0,0,127},
                  textString="cloTim"), Text(
                  extent={{74,6},{98,-4}},
                  textColor={0,0,127},
                  textString="calTim")}));
        end LocalCivilTime;

        partial block PartialConvertTime
          "Converts the simulation time to calendar time in scale of 1 year (365 days), or a multiple of a year"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.Units.SI.Time weaDatStaTim(displayUnit="d") = 0
            "Start time of weather data";
          parameter Modelica.Units.SI.Time weaDatEndTim(displayUnit="d") = 31536000
            "End time of weather data";
          Modelica.Units.SI.Time modTimAux "Model time";
          Modelica.Units.SI.Time calTimAux "Calendar time";

      protected
          parameter Modelica.Units.SI.Time lenWea=weaDatEndTim - weaDatStaTim
            "Length of weather data";

          parameter Boolean canRepeatWeatherFile = abs(mod(lenWea, 365*24*3600)) < 1E-2
            "=true, if the weather file can be repeated, since it has the length of a year or a multiple of it";

          discrete Modelica.Units.SI.Time tNext(start=0, fixed=true)
            "Start time of next period";

        equation
          when {initial(), canRepeatWeatherFile and modTimAux > pre(tNext)} then
            // simulation time stamp went over the end time of the weather file
            //(last time stamp of the weather file + average increment)
            tNext = if canRepeatWeatherFile then integer(modTimAux/lenWea)*lenWea + lenWea else time;
          end when;
          calTimAux = if canRepeatWeatherFile then modTimAux - tNext + lenWea else modTimAux;


          annotation (
            defaultComponentName="conTim",
            Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days),
or a multiple of it, if this is the length of the weather file.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Added partial class for conversion from simulation time to calendar time, to be
used by solar models that require calendar time for calculations.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}})));
        end PartialConvertTime;

        partial block PartialLimiter
          "Partial block to limit a signal"
          extends Modelica.Blocks.Icons.Block;

          constant Real uMin = 0 "Minimum value";
          constant Real uMax = 1 "Maximum value";

          Modelica.Blocks.Interfaces.RealInput u "Connector of Real input signal" annotation (Placement(
                transformation(extent={{-140,-20},{-100,20}})));

        annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that computes <i>y_internal=min(uMax, max(uMin, u))</i>,
where <code>y_internal</code> is a protected connector.
</p>
<p>
This block is used because interpolation of weather data can lead to
a slight overshoot of values. This block is extended by other blocks
that then provide the output connector.
Extending this block is needed for the output connector to have the correct
comment string in the weather data bus, because the weather
data bus displays the comment string of the output signal
that is connected to the weather data bus.
Without this construct, the weather data bus would simply show
\"Connector of Real output signal\".
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),   Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{0,-90},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-90,0},{68,0}}, color={192,192,192}),
            Polygon(
              points={{90,0},{68,-8},{68,8},{90,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}),
            Text(
              extent={{-150,-150},{150,-110}},
                  textString="%uMin <= u <= %uMax",
                  textColor={0,0,0})}),
            Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}})));
        end PartialLimiter;

        partial block PartialLimiterMin
          "Partial block to limit a signal"
          extends Modelica.Blocks.Icons.Block;

          Modelica.Blocks.Interfaces.RealInput u "Connector of Real input signal"
          annotation (Placement(
                transformation(extent={{-140,-20},{-100,20}})));

        annotation (
        defaultComponentName="limMin",
        Documentation(info="<html>
<p>
Partial block that is used to limit a signal by a minimum value.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values. This block is extended by other blocks
that then provide the output connector.
Extending this block is needed for the output connector to have the correct
comment string in the weather data bus, because the weather
data bus displays the comment string of the output signal
that is connected to the weather data bus.
Without this construct, the weather data bus would simply show
\"Connector of Real output signal\".
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Text(
                  extent={{-100,30},{98,-16}},
                  textColor={0,0,0},
                  textString="0 <= u")}));
        end PartialLimiterMin;

        block SolarTime "Solar time"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput locTim(quantity="Time", unit="s")
            "Local time" annotation (Placement(transformation(extent={{-140,-74},{-100,
                    -34}}), iconTransformation(extent={{-140,-74},{-100,-34}})));
          Modelica.Blocks.Interfaces.RealInput equTim(quantity="Time", unit="s")
            "Equation of time" annotation (Placement(transformation(extent={{-140,40},{
                    -100,80}}), iconTransformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput solTim(
            final quantity="Time",
            final unit="s",
            displayUnit="s") "Solar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solTim = locTim + equTim "Our unit is s in stead of h in (A.4.3)";

          annotation (
            defaultComponentName="solTim",
            Documentation(info="<html>
<p>
This component computes the local solar time.
</p>
<p>
<b>Note:</b> To avoid events, this block does not convert solar time to a scale of 24 hours.
</p>
</html>",         revisions="<html>
<ul>
<li>
Feb. 16, 2012, by Michael Wetter:<br/>
Removed section that limits solar time to
<code>0 &le; solTim &le; 86400</code> as this triggers
events, and is not needed because solar time is used in
trigonometric functions only.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  textColor={0,0,255}),
                Text(
                  extent={{-54,38},{42,-24}},
                  textColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-4,4},{52,-24}},
                  textColor={0,0,255},
                  textString="sol"),
                Text(
                  extent={{-94,66},{-42,50}},
                  textColor={0,0,127},
                  textString="equTim"),
                Text(
                  extent={{-96,-44},{-44,-60}},
                  textColor={0,0,127},
                  textString="locTim")}));
        end SolarTime;

        block SourceSelector
          "Block that selects as its output either a parameter value or its input"
          extends Modelica.Blocks.Interfaces.SO;
          parameter Buildings.BoundaryConditions.Types.DataSource datSou "Data source"
            annotation(Evaluate=true);
          parameter Real p "Parameter value";
          Modelica.Blocks.Interfaces.RealInput uFil
           if datSou == Buildings.BoundaryConditions.Types.DataSource.File
            "Input signal from file reader"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}}),
                iconTransformation(extent={{-120,-90},{-100,-70}})));
          Modelica.Blocks.Interfaces.RealInput uCon
          if datSou == Buildings.BoundaryConditions.Types.DataSource.Input
            "Input signal from input connector"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}}),
                iconTransformation(extent={{-120,70},{-100,90}})));
        equation
          if datSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
            y = p;
          end if;
          connect(uCon, y);
          connect(uFil, y);
          annotation (
          defaultComponentName="souSel",
        Documentation(info="<html>
<p>
Block that produces at its output the input value <code>uCon</code>, <code>uFil</code>
or the parameter value <code>p</code> depending on the parameter value
<code>datSou</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
              Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Line(points={{12,0},{100,0}},
                  color={0,0,127}),
                Line(points={{-100,-80},{-40,-80},{-40,-80}},
                  color={0,0,127}),
                Line(points={{-100,80},{-38,80}},
                  color={0,0,127}),
                Line(points={{-38,80},{6,2}},
                  color={0,0,127},
                  visible=datSou == Buildings.BoundaryConditions.Types.DataSource.File,
                  thickness=1),
                Line(points={{-40,-80},{8,0}},
                  color={0,0,127},
                  visible=datSou == Buildings.BoundaryConditions.Types.DataSource.Input,
                  thickness=1),
                Ellipse(lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{2,-8},{18,8}})}));
        end SourceSelector;

        block SourceSelectorRadiation
          "Block that selects the solar radiation source and outputs the solar radiation quantities"
          extends Modelica.Blocks.Icons.Block;
          parameter Buildings.BoundaryConditions.Types.RadiationDataSource datSou "Data source"
            annotation(Evaluate=true);

          Modelica.Blocks.Interfaces.RealInput HDirNorFil(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
           if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.File
            "Direct normal solar irradiation from weather data file" annotation (Placement(transformation(extent={{-140,
                    -10},{-100,30}}), iconTransformation(extent={{-120,10},{-100,30}})));

          Modelica.Blocks.Interfaces.RealInput HDirNorIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
           if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor or
              datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor
            "Direct normal solar irradiation from input connector" annotation (Placement(transformation(extent={{-140,
                    -40},{-100,0}}),  iconTransformation(extent={{-120,-30},{-100,-10}})));

          Modelica.Blocks.Interfaces.RealInput HDifHorFil(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
          if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.File
            "Diffuse horizontal solar irradiation from weather data file" annotation (Placement(transformation(
                  extent={{-140,60},{-100,100}}), iconTransformation(extent={{-120,80},{
                    -100,100}})));

          Modelica.Blocks.Interfaces.RealInput HDifHorIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
          if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or
             datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor
            "Diffuse horizontal solar irradiation from input connector" annotation (Placement(transformation(
                  extent={{-140,30},{-100,70}}),  iconTransformation(extent={{-120,50},{
                    -100,70}})));

          Modelica.Blocks.Interfaces.RealInput HGloHorFil(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
           if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.File
            "Global horizontal solar irradiation from weather data file" annotation (Placement(transformation(extent={{-140,
                    -70},{-100,-30}}),        iconTransformation(extent={{-120,-70},{-100,
                    -50}})));

          Modelica.Blocks.Interfaces.RealInput HGloHorIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
           if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or
              datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor
            "Global horizontal solar irradiation from input connector" annotation (Placement(transformation(extent={{-140,
                    -98},{-100,-58}}),        iconTransformation(extent={{-120,-100},{-100,
                    -80}})));

          Modelica.Blocks.Interfaces.RealInput zen(
            final quantity="Angle",
            final unit="rad")
            "Zenith angle"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-60,-110})));

          Modelica.Blocks.Interfaces.RealOutput HDirNor(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
            "Direct normal solar irradiation" annotation (Placement(
                transformation(extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},
                    {120,10}})));
          Modelica.Blocks.Interfaces.RealOutput HDifHor(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
            "Diffuse horizontal solar irradiation" annotation (Placement(
                transformation(extent={{100,60},{120,80}}),  iconTransformation(extent={{100,68},
                    {120,88}})));
          Modelica.Blocks.Interfaces.RealOutput HGloHor(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
            "Global horizontal solar irradiation" annotation (Placement(
                transformation(extent={{100,-80},{120,-60}}),iconTransformation(extent={{100,-90},
                    {120,-70}})));

      protected
          constant Real epsCos = 1e-6 "Small value to avoid division by 0";
          constant Modelica.Units.SI.HeatFlux solCon=1367.7 "Solar constant";

          // Conditional connectors
          Modelica.Blocks.Interfaces.RealInput HGloHor_in_internal(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput HDifHor_in_internal(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput HDirNor_in_internal(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Needed to connect to conditional connector";

        equation
          // Conditional connect statements
          connect(HGloHor_in_internal, HGloHorFil);
          connect(HDifHor_in_internal, HDifHorFil);
          connect(HDirNor_in_internal, HDirNorFil);
          connect(HGloHor_in_internal, HGloHorIn);
          connect(HDifHor_in_internal, HDifHorIn);
          connect(HDirNor_in_internal, HDirNorIn);

          //---------------------------------------------------------------------------
          // Select global horizontal radiation connector
          if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
            HGloHor = max(0, HDirNor_in_internal*cos(zen)+HDifHor_in_internal)
              "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
            HGloHor_in_internal = 0;
          else
            HGloHor = max(0, HGloHor_in_internal)
              "Get HGloHor using weather data file or input connector of weather data reader";
          end if;

          //---------------------------------------------------------------------------
          // Select diffuse horizontal radiation connector
          if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
            HDifHor = max(0, HGloHor_in_internal - HDirNor_in_internal*cos(zen))
              "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
            HDifHor_in_internal = 0;
          else
            HDifHor = max(0, HDifHor_in_internal)
              "Get HDifHor using weather data file or input connector of weather data reader";
          end if;

          //---------------------------------------------------------------------------
          // Select direct normal radiation connector
          if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor then
              HDirNor = max(0, min(
                solCon,
                (HGloHor_in_internal -HDifHor_in_internal)*
                  Buildings.Utilities.Math.Functions.spliceFunction(
                    x=cos(zen),
                    pos=Buildings.Utilities.Math.Functions.inverseXRegularized(cos(zen), epsCos),
                    neg=0,
                    deltax=epsCos)))
              "Calculate the HDirNor using HGloHor and HDifHor according to (A.4.14) and (A.4.15)";
            HDirNor_in_internal = 0;
          else
            HDirNor = max(0, HDirNor_in_internal)
              "Get HDirNor using weather data file or input connector of weather data reader";
          end if;

          annotation (
          defaultComponentName="souSel",
        Documentation(info="<html>
<p>
Block that outputs the direct normal, diffuse horizontal and diffuse global
solar irradiation.
This block computes these output quantities based on conditionally provided
input signals.
</p>
<p>
The computations are based on Wetter (2004).
</p>
<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
              Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Line(points={{12,0},{100,0}},
                  color={0,0,127}),
                Line(points={{40,-80},{100,-80},{100,-80}},
                  color={0,0,127}),
                Line(points={{40,80},{100,78}},
                  color={0,0,127}),
                Line(points={{6,0},{40,-82},{40,-80}},
                  color={0,0,127}),
                Line(points={{40,80},{6,0},{6,0}},
                  color={0,0,127}),
                Ellipse(lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{-2,-8},{14,8}})}));
        end SourceSelectorRadiation;

        impure function getAltitudeLocationTMY3 "Gets the altitude from TMY3 file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
          output Modelica.Units.SI.Length alt "Altitude of TMY3 location";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getLastHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "Altitude");
           (nexInd, alt) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);

          annotation (Documentation(info="<html>
This function returns the altitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getAltitudeLocationTMY3;

        impure function getHeaderElementTMY3
          "Gets an element from the header of a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         input String start "Start of the string that contains the elements";
         input String name "Name of data element, used in error reporting";
         input Integer position(min=1)
            "Position of the element on the line that contains 'start'";
         output String element
            "Element at position 'pos' of the line that starts with 'start'";
      protected
         String lin "Line that is used in parser";
         Integer iLin "Line number";
         Integer index =  0 "Index of string #LOCATION";
         Integer staInd "Start index used when parsing a real number";
         Integer nexInd "Next index used when parsing a real number";
         Boolean found "Flag, true if #LOCATION has been found";
         Boolean EOF "Flag, true if EOF has been reached";
         String fouDel "Found delimiter";
        algorithm
          // Get line that starts with 'start'
          iLin :=0;
          EOF :=false;
          while (not EOF) and (index == 0) loop
            iLin:=iLin + 1;
            (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=filNam,
              lineNumber=iLin);
            index :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=start,
              startIndex=1,
              caseSensitive=false);
          end while;
          assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                              + "\n   Check for correct weather file syntax.");
          // Loop over the tokens until the position is reached
          nexInd :=1;
          for i in 1:position-1 loop
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString = ",",
              startIndex=nexInd+1);
           assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                lin + "'.");
          end for;
          staInd := nexInd;
          // Find the next delimiter
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString = ",",
              startIndex=nexInd+1);
          assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                 lin + "'.");
          // Get the element
          element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=nexInd-1);
          annotation (Inline=false,
          Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",         revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed call to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
because this function calls
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">
Modelica.Utilities.Files.loadResource</a>, which needs to be resolved at compilation
time, which is difficult if it is inside a function.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Removed default value for parameter <code>name</code>.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getHeaderElementTMY3;

        impure function getLastHeaderElementTMY3
          "Gets last element from the header of a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         input String start "Start of the string that contains the elements";
         input String name "Name of data element, used in error reporting";
         output String element
            "Element at position 'pos' of the line that starts with 'start'";
      protected
         String lin "Line that is used in parser";
         Integer iLin "Line number";
         Integer index =  0 "Index of string #LOCATION";
         Integer staInd "Start index used when parsing a real number";
         Integer lasInd "Next index used when parsing a real number";
         Boolean EOF "Flag, true if EOF has been reached";
        algorithm
          // Get line that starts with 'start'
          iLin :=0;
          EOF :=false;
          while (not EOF) and (index == 0) loop
            iLin:=iLin + 1;
            (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=filNam,
              lineNumber=iLin);
            index :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=start,
              startIndex=1,
              caseSensitive=false);
          end while;
          assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                              + "\n   Check for correct weather file syntax.");
            // gest first and last index of the last string header element
            staInd := Modelica.Utilities.Strings.findLast(
                string=lin,
                searchString = ",",
                startIndex=0);
            lasInd := integer(Modelica.Utilities.Strings.length(lin));
          // Get the element
          element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=lasInd);
          annotation (Inline=false,
          Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",         revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed call to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
because this function calls
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">
Modelica.Utilities.Files.loadResource</a>, which needs to be resolved at compilation
time, which is difficult if it is inside a function.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Removed default value for parameter <code>name</code>.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLastHeaderElementTMY3;

        impure function getLatitudeTMY3 "Gets the latitude from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
          output Modelica.Units.SI.Angle lat "Latitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "latitude",
              position=7);
           (nexInd, lat) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the latitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lat :=lat*Modelica.Constants.pi/180;
           // Check if latitude is valid
           assert(abs(lat) <= Modelica.Constants.pi+Modelica.Constants.eps,
               "Wrong value for latitude. Received lat = " +
               String(lat) + " (= " + String(lat*180/Modelica.Constants.pi) + " degrees).");

          annotation (Documentation(info="<html>
This function returns the latitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLatitudeTMY3;

        impure function getLongitudeTMY3 "Gets the longitude from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
          output Modelica.Units.SI.Angle lon "Longitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=8);
           (nexInd, lon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the longitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lon :=lon*Modelica.Constants.pi/180;
           // Check if longitude is valid
           assert(abs(lon) < 2*Modelica.Constants.pi,
               "Wrong value for longitude. Received lon = " +
               String(lon) + " (= " + String(lon*180/Modelica.Constants.pi) + " degrees).");

          annotation (Documentation(info="<html>
This function returns the longitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLongitudeTMY3;

        impure function getTimeSpanTMY3
            "Get the time span of the weather data from the file"
          extends Modelica.Icons.Function;

          input String filNam "Name of weather data file";
          input String tabNam "Name of table on weather file";
          output Modelica.Units.SI.Time[2] timeSpan
            "Start time, end time of weather data";

        external "C" getTimeSpan(filNam, tabNam, timeSpan)
          annotation (
          Include="#include <getTimeSpan.c>",
          IncludeDirectory="modelica://Buildings/Resources/C-Sources");

          annotation (Documentation(info="<html>
<p>
This function returns the start time (first time stamp) and end time
(last time stamp plus average increment) of the TMY3 weather data file.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
April 16, 2019, by Jianjun Hu:<br/>
Reimplemented to use a C function, this is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1108\">#1108</a>.
</li>
<li>
November 15, 2017, by Ana Constantin:<br/>
First implementation, as part of solution to <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
</ul>
</html>"));
        end getTimeSpanTMY3;

        impure function getTimeZoneTMY3 "Gets the time zone from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
          output Modelica.Units.SI.Time timZon "Time zone from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=9);
           (nexInd, timZon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the time zone '" +
                              element + "' from a String to a Real.");
           timZon :=timZon*3600;
           // Check if time zone is valid
           assert(abs(timZon) < 24*3600,
               "Wrong value for time zone. Received timZon = " +
               String(timZon) + " (= " + String(timZon/3600) + " hours).");

          annotation (Documentation(info="<html>
This function returns the time zone of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getTimeZoneTMY3;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">Buildings.BoundaryConditions.WeatherData</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to read weather data. It also contains
the <code>expandable connector</code>
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.Bus\">
Buildings.BoundaryConditions.WeatherData.Bus</a>
that is used in the library to provide weather data to the different models.
</html>"));
    end WeatherData;

    package Types "Package with type definitions"
     extends Modelica.Icons.TypesPackage;

      type DataSource = enumeration(
          File "Use data from file",
          Parameter "Use parameter",
          Input "Use input connector") "Enumeration to define data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions="<html>
<ul>
<li>
July 20, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type RadiationDataSource = enumeration(
          File "Use data from file",
          Input_HGloHor_HDifHor
            "Global horizontal and diffuse horizontal radiation from connector",
          Input_HDirNor_HDifHor
            "Direct normal and diffuse horizontal radiation from connector",
          Input_HDirNor_HGloHor
            "Direct normal and global horizontal radiation from connector")
        "Enumeration to define solar radiation data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 13, 2012, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));

      type SkyTemperatureCalculation = enumeration(
          HorizontalRadiation
            "Use horizontal irradiation",
          TemperaturesAndSkyCover
            "Use dry-bulb and dew-point temperatures and sky cover")
        "Enumeration for computation of sky temperature" annotation (Documentation(
            info =                 "<html>
<p>
Enumeration to define the method used to compute the sky temperature.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 3, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models to compute boundary conditions such as weather data.
For models that set boundary conditions for fluid flow systems,
see
<a href=\"modelica://Buildings.Fluid.Sources\">
Buildings.Fluid.Sources</a>.
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
        graphics={
          Ellipse(
          extent={{-76,80},{6,-2}},
          lineColor={255,255,255},
          lineThickness=1,
          fillPattern=FillPattern.Sphere,
          fillColor={255,255,255}),
        Line(
          points={{32,-24},{76,-82}},
          color={95, 95, 95}),
        Line(
          points={{4,-24},{48,-82}},
          color={95, 95, 95}),
        Line(
          points={{-26,-24},{18,-82}},
          color={95, 95, 95}),
        Line(
          points={{-56,-24},{-12,-82}},
          color={95, 95, 95}),
        Polygon(
          points={{64,6},{50,-2},{40,-18},{70,-24},{78,-52},{26,-52},{-6,-54},{
              -72,-52},{-72,-22},{-52,-10},{-42,10},{-78,34},{-44,52},{40,56},{76,
              40},{64,6}},
          lineColor={150,150,150},
          lineThickness=0.1,
          fillPattern=FillPattern.Sphere,
          smooth=Smooth.Bezier,
          fillColor={150,150,150})}));
  end BoundaryConditions;

  package Controls "Package with models for controls"
    extends Modelica.Icons.Package;

    package Continuous "Package with models for discrete time controls"
      extends Modelica.Icons.Package;

      block LimPID
        "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting"

        extends Modelica.Blocks.Interfaces.SVcontrol;
        output Real controlError = u_s - u_m
          "Control error (set point - measurement)";

        parameter Modelica.Blocks.Types.SimpleController controllerType=
               Modelica.Blocks.Types.SimpleController.PI "Type of controller";
        parameter Real k(min=0) = 1 "Gain of controller";
        parameter Modelica.Units.SI.Time Ti(min=Modelica.Constants.small) = 0.5
          "Time constant of Integrator block" annotation (Dialog(enable=
                controllerType == Modelica.Blocks.Types.SimpleController.PI or
                controllerType == Modelica.Blocks.Types.SimpleController.PID));
        parameter Modelica.Units.SI.Time Td(min=0) = 0.1
          "Time constant of Derivative block" annotation (Dialog(enable=
                controllerType == Modelica.Blocks.Types.SimpleController.PD or
                controllerType == Modelica.Blocks.Types.SimpleController.PID));
        parameter Real yMax(start=1)=1 "Upper limit of output";
        parameter Real yMin=0 "Lower limit of output";
        parameter Real wp(min=0) = 1 "Set-point weight for Proportional block (0..1)";
        parameter Real wd(min=0) = 0 "Set-point weight for Derivative block (0..1)"
             annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real Ni(min=100*Modelica.Constants.eps) = 0.9
          "Ni*Ti is time constant of anti-windup compensation"
           annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PI or
                                    controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real Nd(min=100*Modelica.Constants.eps) = 10
          "The higher Nd, the more ideal the derivative block"
             annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.InitialState
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
          annotation (Evaluate=true, Dialog(group="Initialization"));
            // Removed as the Limiter block no longer uses this parameter.
            // parameter Boolean limitsAtInit = true
            //  "= false, if limits are ignored during initialization"
            // annotation(Evaluate=true, Dialog(group="Initialization"));
        parameter Real xi_start=0
          "Initial or guess value value for integrator output (= integrator state)"
          annotation (Dialog(group="Initialization",
                      enable=controllerType==.Modelica.Blocks.Types.SimpleController.PI or
                             controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real xd_start=0
          "Initial or guess value for state of derivative block"
          annotation (Dialog(group="Initialization",
                               enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real y_start=0 "Initial value of output"
          annotation(Dialog(enable=initType == Modelica.Blocks.Types.Init.InitialOutput,    group=
                "Initialization"));
        parameter Boolean strict=true "= true, if strict limits with noEvent(..)"
          annotation (Evaluate=true, choices(checkBox=true), Dialog(tab="Advanced"));

        parameter Boolean reverseActing = true
          "Set to true for reverse acting, or false for direct acting control action";

        parameter Buildings.Types.Reset reset = Buildings.Types.Reset.Disabled
          "Type of controller output reset"
          annotation(Evaluate=true, Dialog(group="Integrator reset"));

        parameter Real y_reset=xi_start
          "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == Buildings.Types.Reset.Parameter"
          annotation(Dialog(enable=reset == Buildings.Types.Reset.Parameter,
                            group="Integrator reset"));

        Modelica.Blocks.Interfaces.BooleanInput trigger
          if reset <> Buildings.Types.Reset.Disabled
          "Resets the controller output when trigger becomes true"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-120})));

        Modelica.Blocks.Interfaces.RealInput y_reset_in
          if reset == Buildings.Types.Reset.Input
          "Input signal for state to which integrator is reset, enabled if reset = Buildings.Types.Reset.Input"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

        Modelica.Blocks.Math.Add addP(k1=revAct*wp, k2=-revAct) "Adder for P gain"
         annotation (Placement(
              transformation(extent={{-80,40},{-60,60}})));
        Modelica.Blocks.Math.Add addD(k1=revAct*wd, k2=-revAct) if with_D
          "Adder for D gain"
          annotation (Placement(
              transformation(extent={{-80,-10},{-60,10}})));
        Modelica.Blocks.Math.Gain P(k=1) "Proportional term"
          annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
        Utilities.Math.IntegratorWithReset I(
          final reset=if reset == Buildings.Types.Reset.Disabled then reset else Buildings.Types.Reset.Input,
          final y_reset=y_reset,
          final k=unitTime/Ti,
          final y_start=xi_start,
          final initType=if initType == Modelica.Blocks.Types.Init.SteadyState then
              Modelica.Blocks.Types.Init.SteadyState else if initType == Modelica.Blocks.Types.Init.InitialState
               or initType == Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.InitialState
               else Modelica.Blocks.Types.Init.NoInit) if with_I "Integral term"
          annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));

        Modelica.Blocks.Continuous.Derivative D(
          final k=Td/unitTime,
          final T=max([Td/Nd,1.e-14]),
          final x_start=xd_start,
          final initType=if initType == Modelica.Blocks.Types.Init.SteadyState or
              initType == Modelica.Blocks.Types.Init.InitialOutput then Modelica.Blocks.Types.Init.SteadyState
               else if initType == Modelica.Blocks.Types.Init.InitialState then
              Modelica.Blocks.Types.Init.InitialState else Modelica.Blocks.Types.Init.NoInit)
          if with_D "Derivative term"
          annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));

        Modelica.Blocks.Math.Add3 addPID(
          final k1=1,
          final k2=1,
          final k3=1) "Adder for the gains"
          annotation (Placement(transformation(extent={{0,-10},{20,10}})));

    protected
        constant Modelica.Units.SI.Time unitTime=1 annotation (HideResult=true);

        final parameter Real revAct = if reverseActing then 1 else -1
          "Switch for sign for reverse or direct acting controller";

        parameter Boolean with_I = controllerType==Modelica.Blocks.Types.SimpleController.PI or
                                   controllerType==Modelica.Blocks.Types.SimpleController.PID
          "Boolean flag to enable integral action"
          annotation(Evaluate=true, HideResult=true);
        parameter Boolean with_D = controllerType==Modelica.Blocks.Types.SimpleController.PD or
                                   controllerType==Modelica.Blocks.Types.SimpleController.PID
          "Boolean flag to enable derivative action"
          annotation(Evaluate=true, HideResult=true);

        Modelica.Blocks.Sources.Constant Dzero(final k=0) if not with_D
          "Zero input signal"
          annotation(Evaluate=true, HideResult=true,
                     Placement(transformation(extent={{-30,20},{-20,30}})));

        Modelica.Blocks.Sources.Constant Izero(final k=0) if not with_I
          "Zero input signal"
          annotation(Evaluate=true, HideResult=true,
                     Placement(transformation(extent={{10,-55},{0,-45}})));

        Modelica.Blocks.Interfaces.RealInput y_reset_internal
         "Internal connector for controller output reset"
         annotation(Evaluate=true);

        Modelica.Blocks.Math.Add3 addI(
          final k1=revAct,
          final k2=-revAct) if with_I
          "Adder for I gain"
             annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));

        Modelica.Blocks.Math.Add addSat(
          final k1=+1,
          final k2=-1) if with_I
          "Adder for integrator feedback"
          annotation (Placement(
              transformation(
              origin={80,-50},
              extent={{-10,-10},{10,10}},
              rotation=270)));

        Modelica.Blocks.Math.Gain gainPID(final k=k) "Multiplier for control gain"
         annotation (Placement(transformation(
                extent={{30,-10},{50,10}})));

        Modelica.Blocks.Math.Gain gainTrack(k=1/(k*Ni)) if with_I
          "Gain for anti-windup compensation"
          annotation (
            Placement(transformation(extent={{60,-80},{40,-60}})));

        Limiter limiter(
          final uMax=yMax,
          final uMin=yMin,
          final strict=strict)
          "Output limiter"
          annotation (Placement(transformation(extent={{70,-10},{90,10}})));


        Modelica.Blocks.Sources.RealExpression intRes(
          final y=y_reset_internal/k - addPID.u1 - addPID.u2)
          if reset <> Buildings.Types.Reset.Disabled
          "Signal source for integrator reset"
          annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));

        // The block Limiter below has been implemented as it is introduced in MSL 3.2.3, but
        // not all tools include MSL 3.2.3.
        // See https://github.com/ibpsa/modelica-ibpsa/pull/1222#issuecomment-554114617
      block Limiter "Limit the range of a signal"
        parameter Real uMax(start=1) "Upper limits of input signals";
        parameter Real uMin= -uMax "Lower limits of input signals";
        parameter Boolean strict=false "= true, if strict limits with noEvent(..)"
          annotation (Evaluate=true, choices(checkBox=true), Dialog(tab="Advanced"));
        parameter Boolean limitsAtInit=true
          "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)"
          annotation (Dialog(tab="Dummy"),Evaluate=true, choices(checkBox=true));
        extends Modelica.Blocks.Interfaces.SISO;

      equation
        assert(uMax >= uMin, "Limiter: Limits must be consistent. However, uMax (=" + String(uMax) +
                             ") < uMin (=" + String(uMin) + ")");

        if strict then
          y = smooth(0, noEvent(if u > uMax then uMax else if u < uMin then uMin else u));
        else
          y = smooth(0,if u > uMax then uMax else if u < uMin then uMin else u);
        end if;
        annotation (
           Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{0,-90},{0,68}}, color={192,192,192}),
          Polygon(
            points={{0,90},{-8,68},{8,68},{0,90}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,-8},{68,8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}),
          Text(
            extent={{-150,-150},{150,-110}},
            textString="uMax=%uMax"),
          Line(
            visible=strict,
            points={{50,70},{80,70}},
            color={255,0,0}),
          Line(
            visible=strict,
            points={{-80,-70},{-50,-70}},
            color={255,0,0})}),
          Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{0,-60},{0,50}}, color={192,192,192}),
          Polygon(
            points={{0,60},{-5,50},{5,50},{0,60}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-60,0},{50,0}}, color={192,192,192}),
          Polygon(
            points={{60,0},{50,-5},{50,5},{60,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-50,-40},{-30,-40},{30,40},{50,40}}),
          Text(
            extent={{46,-6},{68,-18}},
            textColor={128,128,128},
            textString="u"),
          Text(
            extent={{-30,70},{-5,50}},
            textColor={128,128,128},
            textString="y"),
          Text(
            extent={{-58,-54},{-28,-42}},
            textColor={128,128,128},
            textString="uMin"),
          Text(
            extent={{26,40},{66,56}},
            textColor={128,128,128},
            textString="uMax")}));
      end Limiter;


      initial equation
        if initType == Modelica.Blocks.Types.Init.InitialOutput then
           gainPID.y = y_start;
        end if;

      equation
        assert(yMax >= yMin, "LimPID: Limits must be consistent. However, yMax (=" + String(yMax) +
                             ") < yMin (=" + String(yMin) + ")");
        if initType == Modelica.Blocks.Types.Init.InitialOutput and (y_start < yMin
             or y_start > yMax) then
            Modelica.Utilities.Streams.error("LimPID: Start value y_start (=" + String(y_start) +
               ") is outside of the limits of yMin (=" + String(yMin) +") and yMax (=" + String(yMax) + ")");
        end if;

        // Equations for conditional connectors
        connect(y_reset_in, y_reset_internal);

        if reset <> Buildings.Types.Reset.Input then
          y_reset_internal = y_reset;
        end if;

        connect(u_s, addP.u1) annotation (Line(points={{-120,0},{-96,0},{-96,56},{
                -82,56}}, color={0,0,127}));
        connect(u_s, addD.u1) annotation (Line(points={{-120,0},{-96,0},{-96,6},{
                -82,6}}, color={0,0,127}));
        connect(u_s, addI.u1) annotation (Line(points={{-120,0},{-96,0},{-96,-42},{
                -82,-42}}, color={0,0,127}));
        connect(addP.y, P.u) annotation (Line(points={{-59,50},{-42,50}}, color={0,
                0,127}));
        connect(addD.y, D.u)
          annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
        connect(addI.y, I.u) annotation (Line(points={{-59,-50},{-42,-50}}, color={
                0,0,127}));
        connect(P.y, addPID.u1) annotation (Line(points={{-19,50},{-10,50},{-10,8},
                {-2,8}}, color={0,0,127}));
        connect(D.y, addPID.u2)
          annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
        connect(I.y, addPID.u3) annotation (Line(points={{-19,-50},{-10,-50},{-10,
                -8},{-2,-8}}, color={0,0,127}));
        connect(addPID.y, gainPID.u)
          annotation (Line(points={{21,0},{28,0}}, color={0,0,127}));
        connect(gainPID.y, addSat.u2) annotation (Line(points={{51,0},{60,0},{60,
                -20},{74,-20},{74,-38}}, color={0,0,127}));
        connect(gainPID.y, limiter.u)
          annotation (Line(points={{51,0},{68,0}}, color={0,0,127}));
        connect(limiter.y, addSat.u1) annotation (Line(points={{91,0},{94,0},{94,
                -20},{86,-20},{86,-38}}, color={0,0,127}));
        connect(limiter.y, y)
          annotation (Line(points={{91,0},{110,0}}, color={0,0,127}));
        connect(addSat.y, gainTrack.u) annotation (Line(points={{80,-61},{80,-70},{62,
                -70}},    color={0,0,127}));
        connect(gainTrack.y, addI.u3) annotation (Line(points={{39,-70},{-88,-70},{-88,
                -58},{-82,-58}},     color={0,0,127}));
        connect(u_m, addP.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,44},{-82,44}},
            color={0,0,127},
            thickness=0.5));
        connect(u_m, addD.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,-6},{-82,-6}},
            color={0,0,127},
            thickness=0.5));
        connect(u_m, addI.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,-50},{-82,-50}},
            color={0,0,127},
            thickness=0.5));
        connect(Dzero.y, addPID.u2) annotation (Line(points={{-19.5,25},{-14,25},{
                -14,0},{-2,0}}, color={0,0,127}));
        connect(Izero.y, addPID.u3) annotation (Line(points={{-0.5,-50},{-10,-50},{
                -10,-8},{-2,-8}}, color={0,0,127}));
        connect(trigger, I.trigger) annotation (Line(points={{-80,-120},{-80,-88},{-30,
                -88},{-30,-62}}, color={255,0,255}));
        connect(intRes.y, I.y_reset_in) annotation (Line(points={{-59,-80},{-50,-80},{
                -50,-58},{-42,-58}}, color={0,0,127}));
         annotation (
      defaultComponentName="conPID",
      Documentation(info="<html>
<p>
PID controller in the standard form
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = k &nbsp; ( e(t) + 1 &frasl; T<sub>i</sub> &nbsp; &int; e(s) ds + T<sub>d</sub> de(t)&frasl;dt ),
</p>
<p>
where
<i>y</i> is the control signal,
<i>e(t) = u<sub>s</sub> - u<sub>m</sub></i> is the control error,
with <i>u<sub>s</sub></i> being the set point and <i>u<sub>m</sub></i> being
the measured quantity,
<i>k</i> is the gain,
<i>T<sub>i</sub></i> is the time constant of the integral term and
<i>T<sub>d</sub></i> is the time constant of the derivative term.
</p>
<p>
Note that the units of <i>k</i> are the inverse of the units of the control error,
while the units of <i>T<sub>i</sub></i> and <i>T<sub>d</sub></i> are seconds.
</p>
<p>
For detailed treatment of integrator anti-windup, set-point weights and output limitation, see
<a href=\"modelica://Modelica.Blocks.Continuous.LimPID\">Modelica.Blocks.Continuous.LimPID</a>.
</p>
<h4>Options</h4>
This controller can be configured as follows.
<h5>P, PI, PD, or PID action</h5>
<p>
Through the parameter <code>controllerType</code>, the controller can be configured
as P, PI, PD or PID controller. The default configuration is PI.
</p>
<h5>Direct or reverse acting</h5>
<p>
Through the parameter <code>reverseActing</code>, the controller can be configured to
be reverse or direct acting.
The above standard form is reverse acting, which is the default configuration.
For a reverse acting controller, for a constant set point,
an increase in measurement signal <code>u_m</code> decreases the control output signal <code>y</code>
(Montgomery and McDowall, 2008).
Thus,
</p>
<ul>
  <li>
  for a heating coil with a two-way valve, leave <code>reverseActing = true</code>, but
  </li>
  <li>
  for a cooling coil with a two-way valve, set <code>reverseActing = false</code>.
  </li>
</ul>
<h5>Reset of the controller output</h5>
<p>
The controller can be configured to enable an input port that allows resetting the controller
output. The controller output can be reset as follows:
</p>
<ul>
  <li>
  If <code>reset = Buildings.Types.Reset.Disabled</code>, which is the default,
  then the controller output is never reset.
  </li>
  <li>
  If <code>reset = Buildings.Types.Reset.Parameter</code>, then a boolean
  input signal <code>trigger</code> is enabled. Whenever the value of
  this input changes from <code>false</code> to <code>true</code>,
  the controller output is reset by setting <code>y</code>
  to the value of the parameter <code>y_reset</code>.
  </li>
  <li>
  If <code>reset = Buildings.Types.Reset.Input</code>, then a boolean
  input signal <code>trigger</code> and a real input signal <code>y_reset_in</code>
  are enabled. Whenever the value of
  <code>trigger</code> changes from <code>false</code> to <code>true</code>,
  the controller output is reset by setting the value of <code>y</code>
  to <code>y_reset_in</code>.
  </li>
</ul>
<p>
Note that this controller implements an integrator anti-windup. Therefore,
for most applications, keeping the default setting of
<code>reset = Buildings.Types.Reset.Disabled</code> is sufficient.
However, if the controller is used in conjuction with equipment that is being
switched on, better control performance may be achieved by resetting the controller
output when the equipment is switched on.
This is in particular the case in situations
where the equipment control input should continuously increase as the equipment is
switched on, such as a light dimmer that may slowly increase the luminance, or
a variable speed drive of a motor that should continuously increase the speed.
</p>
<h4>References</h4>
<p>
R. Montgomery and R. McDowall (2008).
\"Fundamentals of HVAC Control Systems.\"
American Society of Heating Refrigerating and Air-Conditioning Engineers Inc. Atlanta, GA.
</p>

</html>",
      revisions="<html>
<ul>
<li>
June 1, 2020, by Michael Wetter:<br/>
Corrected wrong convention of reverse and direct action.<br/>
Changed default configuration from PID to PI.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1365\">issue 1365</a>.
</li>
<li>
March 9, 2020, by Michael Wetter:<br/>
Corrected wrong unit declaration for parameter <code>k</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1316\">issue 1316</a>.
</li>
<li>
October 19, 2019, by Filip Jorissen:<br/>
Disabled homotopy to ensure bounded outputs
by copying the implementation from MSL 3.2.3 and by
hardcoding the implementation for <code>homotopyType=NoHomotopy</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1221\">issue 1221</a>.
</li>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model.
</li>
<li>
August 25, 2016, by Michael Wetter:<br/>
Removed parameter <code>limitsAtInit</code> because it was only propagated to
the instance <code>limiter</code>, but this block no longer makes use of this parameter.
This is a non-backward compatible change.<br/>
Revised implemenentation, added comments, made some parameter in the instances final.
</li>
<li>July 18, 2016, by Philipp Mehrfeld:<br/>
Added integrator reset.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/494\">issue 494</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Changed the default value to <code>strict=true</code> in order to avoid events
when the controller saturates.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/433\">issue 433</a>.
</li>
<li>
February 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                extent={{-6,-20},{66,-66}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.P),
                extent={{-32,-22},{68,-62}},
                lineColor={0,0,0},
                textString="P",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PI),
                extent={{-28,-22},{72,-62}},
                lineColor={0,0,0},
                textString="PI",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PD),
                extent={{-16,-22},{88,-62}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175},
                textString="P D"),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PID),
                extent={{-14,-22},{86,-62}},
                lineColor={0,0,0},
                textString="PID",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
              Line(points={{-80,-80},{-80,-20},{30,60},{80,60}}, color={0,0,127}),
              Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
              Polygon(
                points={{90,-80},{68,-72},{68,-88},{90,-80}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(
                visible=strict,
                points={{30,60},{81,60}},
                color={255,0,0},
                smooth=Smooth.None)}));
      end LimPID;
    annotation (
    preferredView="info", Documentation(info="<html>
This package contains component models for continuous time controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks.Continuous\">
Modelica.Blocks.Discrete</a>.
</html>"),
    Icon(graphics={Line(
              origin={0.061,4.184},
              points={{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,
                  113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Continuous;

    package OBC "Blocks and preconfigured control sequences"
      extends Modelica.Icons.Package;

      package CDL
      "Package with blocks, examples and validation tests for control description language"

        package Constants "Package with constants"

          final constant Real eps=1E-15
            "Biggest number such that 1.0 + eps = 1.0";
          annotation (
            Documentation(
              info="<html>
<p>
This package provides often needed constants.
</p>
</html>",     revisions="<html>
<ul>
<li>
March 12, 2024, by Michael Wetter:<br/>
Changed <code>small</code> to <i>1E-37</i>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3695\">issue 3695</a>.
</li>
<li>
March 27, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              coordinateSystem(
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={-9.2597,25.6673},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
                  smooth=Smooth.Bezier),
                Polygon(
                  origin={-19.9923,-8.3993},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
                  smooth=Smooth.Bezier),
                Polygon(
                  origin={23.753,-11.5422},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
                  smooth=Smooth.Bezier),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0)}));
        end Constants;

        package Conversions "Package with blocks for type conversion"

          block BooleanToReal
            "Convert Boolean to Real signal"
            parameter Real realTrue=1.0
              "Output signal for true Boolean input";
            parameter Real realFalse=0.0
              "Output signal for false Boolean input";
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput u
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=if u then
                realTrue
              else
                realFalse;
            annotation (
              defaultComponentName="booToRea",
              Documentation(
                info="<html>
<p>
Block that outputs the <code>Real</code>
equivalent of the <code>Boolean</code> input.
</p>
<pre>
  y = if u then realTrue else realFalse;
</pre>
<p>
where <code>u</code> is of <code>Boolean</code> and <code>y</code>
of <code>Real</code> type,
and <code>realTrue</code> and <code>realFalse</code> are parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 17, 2022, by Hongxiang Fu:<br/>
Corrected documentation texts where the variables were described with wrong types.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3016\">#3016</a>.
</li>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{-71,7},{-85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    textColor={0,0,255}),
                  Text(
                    extent={{-68,-86},{70,-38}},
                    textColor={0,0,0},
                    textString="%realFalse"),
                  Text(
                    extent={{-68,-26},{70,22}},
                    textColor={0,0,0},
                    textString="%realTrue"),
                  Text(
                    extent={{-86,78},{-34,26}},
                    textColor={255,0,255},
                    textString="B"),
                  Polygon(
                    points={{26,48},{6,68},{6,58},{-26,58},{-26,38},{6,38},{6,28},{26,48}},
                    lineColor={0,0,127},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{34,82},{86,24}},
                    textColor={0,0,127},
                    textString="R")}));
          end BooleanToReal;
          annotation (
            Documentation(
              info="<html>
<p>
Package with blocks for type conversions.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0)}));
        end Conversions;

        package Logical "Package with logical blocks"

          block Not
            "Logical not"
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput u
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=not u;
            annotation (
              defaultComponentName="not1",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-56,28},{72,-24}},
                    textColor={0,0,0},
                    textString="not"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the input is <code>false</code>,
and <code>false</code> if the input is <code>true</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Not;

          block Or
            "Logical 'or': y = u1 or u2"
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput u1
              "Connector of first Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput u2
              "Connector of second Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1 or u2;
            annotation (
              defaultComponentName="or2",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-90,40},{90,-40}},
                    textColor={0,0,0},
                    textString="or"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-75,-6},{-89,8}},
                    lineColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-75,-73},{-89,-87}},
                    lineColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if at least one input
is <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Or;

          package Sources "Package with blocks that generate source signals"

            block Constant
              "Output constant signal of type Boolean"
              parameter Boolean k
                "Constant output value";
              Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput y
                "Connector of Boolean output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=k;
              annotation (
                defaultComponentName="con",
                Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}),
                  graphics={
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      textColor={0,0,255}),
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      fillColor={210,210,210},
                      lineThickness=5.0,
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Ellipse(
                      extent={{71,7},{85,-7}},
                      lineColor=DynamicSelect({235,235,235},
                        if y then
                          {0,255,0}
                        else
                          {235,235,235}),
                      fillColor=DynamicSelect({235,235,235},
                        if y then
                          {0,255,0}
                        else
                          {235,235,235}),
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-90,-70},{72,-70}},
                      color={255,0,255}),
                    Polygon(
                      points={{90,-70},{68,-62},{68,-78},{90,-70}},
                      lineColor={255,0,255},
                      fillColor={255,0,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-80,88},{-88,66},{-72,66},{-80,88}},
                      lineColor={255,0,255},
                      fillColor={255,0,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80,66},{-80,-82}},
                      color={255,0,255}),
                    Line(
                      points={{-80,0},{64,0}}),
                    Text(
                      extent={{-150,-140},{150,-110}},
                      textColor={0,0,0},
                      textString="%k")}),
                Documentation(
                  info="<html>
<p>
Block that outputs a constant signal <code>y = k</code>,
where <code>k</code> is a Boolean-valued parameter.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/Constant.png\"
     alt=\"Constant.png\" />
</p>
</html>"));
            end Constant;
            annotation (
              Documentation(
                info="<html>
<p>
Package with blocks that generate signals.
</p>
</html>"),    Icon(
                graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Polygon(
                    origin={23.3333,0.0},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
                  Rectangle(
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{-70,-4.5},{0,4.5}})}));
          end Sources;
          annotation (
            Documentation(
              info="<html>
<p>
Package with blocks for elementary mathematical functions
for boolean variables.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Line(
                  points={{-86,-22},{-50,-22},{-50,22},{48,22},{48,-22},{88,-24}},
                  color={255,0,255})}));
        end Logical;

        package Reals "Package with blocks for continuous variables"

          block Add
            "Output the sum of the two inputs"
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1+u2;
            annotation (
              defaultComponentName="add2",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y</code> as the sum of the
two input signals <code>u1</code> and <code>u2</code>,
</p>
<pre>
    y = u1 + u2.
</pre>
</html>", revisions="<html>
<ul>
<li>
January 27, 2022, by Jianjun Hu:<br/>
Removed gain factors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2865\">issue 2865</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    lineColor={0,0,127},
                    extent={{-50,-50},{50,50}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    textColor={0,0,255}),
                  Line(
                    points={{-100,60},{-74,24},{-44,24}},
                    color={0,0,127}),
                  Line(
                    points={{-100,-60},{-74,-28},{-42,-28}},
                    color={0,0,127}),
                  Line(
                    points={{50,0},{100,0}},
                    color={0,0,127}),
                  Text(
                    extent={{-36,-26},{40,42}},
                    textString="+"),
                  Text(
                    extent={{226,60},{106,10}},
                    textColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftJustified=false,
                      significantDigits=3)))}));
          end Add;

          block Derivative
            "Block that approximates the derivative of the input"
            parameter Real y_start=0
              "Initial value of output (= state)"
              annotation (Dialog(group="Initialization"));

            Buildings.Controls.OBC.CDL.Interfaces.RealInput k
              "Connector for gain signal"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput T(
              final quantity="Time",
              final unit="s",
              min=100*Buildings.Controls.OBC.CDL.Constants.eps)
              "Time constant (T>0 required; T=0 is ideal derivative block)"
              annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u
              "Input to be differentiated"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Approximation of derivative du/dt"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));
        protected
            Real T_nonZero(final unit="s") "Non-zero value for T";

            output Real x
              "State of block";

          initial equation
            x= if abs(k) < Buildings.Controls.OBC.CDL.Constants.eps then u else u - T*y_start/k;

          equation
            T_nonZero = max(T, 100*Buildings.Controls.OBC.CDL.Constants.eps);
            der(x) = (u-x)/T_nonZero;
            y = (k/T_nonZero)*(u-x);

            annotation (
              defaultComponentName="der",
              Documentation(
                info="<html>
<p>
This blocks defines the transfer function between the
input <code>u</code> and the output <code>y</code>
as <i>approximated derivative</i>:
</p>
<pre>
                s
  y = k * ------------ * u
            T * s + 1
</pre>
<p>
If <code>k=0</code>, the block reduces to <code>y=0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 20, 2022, by Michael Wetter:<br/>
First implementation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3022\">issue 3022</a>.
</li>
</ul>
</html>"),      Icon(
                  coordinateSystem(
                    extent={{-100.0,-100.0},{100.0,100.0}}),
                  graphics={
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-56,78},{-56,-90}},
                      color={192,192,192}),
                    Polygon(
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid,
                      points={{-56,90},{-64,68},{-48,68},{-56,90}}),
                    Line(
                      points={{-64,-80},{82,-80}},
                      color={192,192,192}),
                    Polygon(
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid,
                      points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
                    Line(
                      origin={-24.667,-27.333},
                      points={{-31.333,89.333},{-19.333,-40.667},{86.667,-52.667}},
                      color={0,0,127},
                      smooth=Smooth.Bezier),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      textColor={0,0,255}),
                    Text(
                      extent={{226,60},{106,10}},
                      textColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftJustified=false,
                        significantDigits=3))),
                  Text(
                    extent={{-106,14},{-62,-12}},
                    textColor={0,0,0},
                    textString="u"),
                  Text(
                    extent={{46,14},{90,-12}},
                    textColor={0,0,0},
                    textString="y=du/dt"),
                  Text(
                    extent={{-108,94},{-64,68}},
                    textColor={0,0,0},
                    textString="k"),
                  Text(
                    extent={{-108,54},{-64,28}},
                    textColor={0,0,0},
                    textString="T")}));
          end Derivative;

          block IntegratorWithReset
            "Output the integral of the input signal"
            parameter Real k=1
              "Integrator gain";
            parameter Real y_start=0
              "Initial or guess value of output (= state)"
              annotation (Dialog(group="Initialization"));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput y_reset_in
              "Input signal for state to which integrator is reset"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput trigger
              "Resets the integrator output when trigger becomes true"
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},rotation=90,origin={0,-120}),iconTransformation(extent={{-20,-20},{20,20}},rotation=90,origin={0,-120})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          initial equation
            y=y_start;

          equation
            der(y)=k*u;
            when trigger then
              reinit(
                y,
                y_reset_in);
            end when;
            annotation (
              defaultComponentName="intWitRes",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-88,-94},{212,-54}},
                    textColor={0,0,0},
                    textString="y_reset_in",
                    horizontalAlignment=TextAlignment.Left),
                  Bitmap(
                    extent={{-54,-50},{60,50}},
                    fileName="modelica://Buildings/Resources/Images/Controls/OBC/CDL/Reals/int.png"),
                  Text(
                    extent={{-88,56},{206,92}},
                    textColor={0,0,0},
                    textString="k=%k",
                    horizontalAlignment=TextAlignment.Left),
                  Text(
                    extent={{-92,-12},{208,28}},
                    textColor={0,0,0},
                    horizontalAlignment=TextAlignment.Left,
                    textString="u"),
                  Text(
                    extent={{70,-14},{370,26}},
                    textColor={0,0,0},
                    horizontalAlignment=TextAlignment.Left,
                    textString="y"),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    textColor={0,0,255}),
                  Text(
                    extent={{226,60},{106,10}},
                    textColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftJustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Block that outputs
</p>
<p align=\"center\" style=\"font-style:italic;\">
y(t) = y<sub>start</sub> + &int;<sub>t<sub>0</sub></sub><sup>t</sup> u(s) ds.
</p>
<p>
Whenever the input signal <code>trigger</code> changes from <code>false</code>
to <code>true</code>,
the integrator is reset by setting <i>y<sub>start</sub></i>
to the value of the input signal <code>y_reset_in</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 8, 2023, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
February 2, 2022, by Michael Wetter:<br/>
Removed <code>unit=\"1\"</code> declaration for gain <code>k</code>.
This is to avoid the warning observed in
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/2872\">#2872</a>.
</li>
<li>
October 21, 2021, by Michael Wetter:<br/>
Removed errorneous <code>visible</code> attribute in icon.
</li>
<li>
August 3, 2020, by Jianjun:<br/>
Fixed the input <code>y_reset_in</code>.
<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2056\">issue 2056</a>.
</li>
<li>
April 21, 2020, by Michael Wetter:<br/>
Removed parameter <code>initType</code>.
<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1887\">issue 1887</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
November 6, 2017, by Michael Wetter:<br/>
Explicitly declared types from CDL.
</li>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of
<a href=\"modelica://Buildings.Utilities.Math.IntegratorWithReset\">
Buildings.Utilities.Math.IntegratorWithReset</a>.
</li>
</ul>
</html>"));
          end IntegratorWithReset;

          block Limiter
            "Limit the range of a signal"
            parameter Real uMax
              "Upper limit of input signal";
            parameter Real uMin
              "Lower limit of input signal";
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          initial equation
            assert(
              uMin < uMax,
              "uMin must be smaller than uMax. Check parameters.");

          equation
            y=homotopy(
              actual=smooth(0,noEvent(
                if u > uMax then
                  uMax
                else
                  if u < uMin then
                    uMin
                  else
                    u)),
              simplified=u);
            annotation (
              defaultComponentName="lim",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = min(uMax, max(uMin, u))</code>,
where
<code>u</code> is an input
and
<code>uMax</code> and <code>uMin</code> are parameters.
</p>
<p>
If <code>uMax &lt; uMin</code>, an error occurs.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 15, 2024, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
July 17, 2017, by Michael Wetter:<br/>
Removed cyclical definition.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                graphics={
                  Text(
                    textColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{0,-90},{0,68}},
                    color={192,192,192}),
                  Polygon(
                    points={{0,90},{-8,68},{8,68},{0,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-90,0},{68,0}},
                    color={192,192,192}),
                  Polygon(
                    points={{90,0},{68,-8},{68,8},{90,0}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-80,-70},{-50,-70},{50,70},{80,70}}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    textColor={0,0,255}),
                  Line(
                    points={{50,70},{80,70}}),
                  Line(
                    points={{-80,-70},{-50,-70}}),
                  Text(
                    extent={{12,72},{94,98}},
                    textColor={0,0,0},
                    textString="%uMax"),
                  Text(
                    extent={{-100,-98},{-18,-72}},
                    textColor={0,0,0},
                    textString="%uMin"),
                  Text(
                    extent={{226,60},{106,10}},
                    textColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftJustified=false,
                      significantDigits=3)))}));
          end Limiter;

          block MultiplyByParameter
            "Output the product of a gain value with the input signal"
            parameter Real k
              "Gain value multiplied with input signal";
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u
              "Input signal connector"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Output signal connector"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=k*u;
            annotation (
              defaultComponentName="gai",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = k * u</code>,
where
<code>k</code> is a parameter and
<code>u</code> is an input.
</p>
</html>", revisions="<html>
<ul>
<li>
January 27, 2022, by Jianjun Hu:<br/>
Renamed the block name from Gain to MultiplyByParameter.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2865\">issue 2865</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Polygon(
                    points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-140},{150,-100}},
                    textColor={0,0,0},
                    textString="k=%k"),
                  Text(
                    extent={{-150,144},{150,104}},
                    textString="%name",
                    textColor={0,0,255}),
                  Text(
                    extent={{226,60},{106,10}},
                    textColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftJustified=false,
                      significantDigits=3)))}));
          end MultiplyByParameter;

          block PIDWithReset
            "P, PI, PD, and PID controller with output reset"
            parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerType=Buildings.Controls.OBC.CDL.Types.SimpleController.PI
              "Type of controller";
            parameter Real k(
              min=100*Constants.eps)=1
              "Gain of controller"
              annotation (Dialog(group="Control gains"));
            parameter Real Ti(
              final quantity="Time",
              final unit="s",
              min=100*Constants.eps)=0.5
              "Time constant of integrator block"
              annotation (Dialog(group="Control gains",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real Td(
              final quantity="Time",
              final unit="s",
              min=100*Constants.eps)=0.1
              "Time constant of derivative block"
              annotation (Dialog(group="Control gains",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Real r(
              min=100*Constants.eps)=1
              "Typical range of control error, used for scaling the control error";
            parameter Real yMax=1
              "Upper limit of output"
              annotation (Dialog(group="Limits"));
            parameter Real yMin=0
              "Lower limit of output"
              annotation (Dialog(group="Limits"));
            parameter Real Ni(
              min=100*Constants.eps)=0.9
              "Ni*Ti is time constant of anti-windup compensation"
              annotation (Dialog(tab="Advanced",group="Integrator anti-windup",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real Nd(
              min=100*Constants.eps)=10
              "The higher Nd, the more ideal the derivative block"
              annotation (Dialog(tab="Advanced",group="Derivative block",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Real xi_start=0
              "Initial value of integrator state"
              annotation (Dialog(tab="Advanced",group="Initialization",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real yd_start=0
              "Initial value of derivative output"
              annotation (Dialog(tab="Advanced",group="Initialization",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Boolean reverseActing=true
              "Set to true for reverse acting, or false for direct acting control action";
            parameter Real y_reset=xi_start
              "Value to which the controller output is reset if the boolean trigger has a rising edge"
              annotation (Dialog(enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID,group="Integrator reset"));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u_s
              "Connector of setpoint input signal"
              annotation (Placement(transformation(extent={{-260,-20},{-220,20}}),iconTransformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u_m
              "Connector of measurement input signal"
              annotation (Placement(transformation(origin={0,-220},extent={{20,-20},{-20,20}},rotation=270),iconTransformation(extent={{20,-20},{-20,20}},rotation=270,origin={0,-120})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of actuator output signal"
              annotation (Placement(transformation(extent={{220,-20},{260,20}}),iconTransformation(extent={{100,-20},{140,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput trigger
              "Resets the controller output when trigger becomes true"
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},rotation=90,origin={-160,-220}),iconTransformation(extent={{-20,-20},{20,20}},rotation=90,origin={-60,-120})));
            Buildings.Controls.OBC.CDL.Reals.Subtract controlError
              "Control error (set point - measurement)"
              annotation (Placement(transformation(extent={{-200,-16},{-180,4}})));
            Buildings.Controls.OBC.CDL.Reals.MultiplyByParameter P(final k=k) "Proportional action"
              annotation (Placement(transformation(extent={{-50,130},{-30,150}})));
            Buildings.Controls.OBC.CDL.Reals.IntegratorWithReset I(
              final k=k/Ti,
              final y_start=xi_start) if with_I
              "Integral term"
              annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
            Buildings.Controls.OBC.CDL.Reals.Derivative D(
              final y_start=yd_start) if with_D
              "Derivative term"
              annotation (Placement(transformation(extent={{-50,60},{-30,80}})));
            Buildings.Controls.OBC.CDL.Reals.Subtract errP
              "P error"
              annotation (Placement(transformation(extent={{-140,130},{-120,150}})));
            Buildings.Controls.OBC.CDL.Reals.Subtract errD if with_D
              "D error"
              annotation (Placement(transformation(extent={{-140,60},{-120,80}})));
            Buildings.Controls.OBC.CDL.Reals.Subtract errI1 if with_I
              "I error (before anti-windup compensation)"
              annotation (Placement(transformation(extent={{-140,-4},{-120,16}})));
            Buildings.Controls.OBC.CDL.Reals.Subtract errI2 if with_I
              "I error (after anti-windup compensation)"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Buildings.Controls.OBC.CDL.Reals.Limiter lim(
              final uMax=yMax,
              final uMin=yMin)
              "Limiter"
              annotation (Placement(transformation(extent={{120,80},{140,100}})));
        protected
            final parameter Real revAct=
              if reverseActing then
                1
              else
                -1
              "Switch for sign for reverse or direct acting controller";
            final parameter Boolean with_I=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID
              "Boolean flag to enable integral action"
              annotation (Evaluate=true,HideResult=true);
            final parameter Boolean with_D=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID
              "Boolean flag to enable derivative action"
              annotation (Evaluate=true,HideResult=true);
            Sources.Constant kDer(k=k*Td) if with_D
              "Gain for derivative block"
              annotation (Placement(transformation(extent={{-100,110},{-80,130}})));
            Sources.Constant TDer(k=Td/Nd) if with_D
              "Time constant for approximation in derivative block"
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            Buildings.Controls.OBC.CDL.Reals.Sources.Constant Dzero(
              final k=0) if not with_D
              "Zero input signal"
              annotation (Evaluate=true,HideResult=true,Placement(transformation(extent={{-50,90},
                      {-30,110}})));
            Buildings.Controls.OBC.CDL.Reals.Sources.Constant Izero(
              final k=0) if not with_I
              "Zero input signal"
              annotation (Placement(transformation(extent={{-50,20},{-30,40}})));
            Buildings.Controls.OBC.CDL.Reals.MultiplyByParameter uS_revAct(
              final k=revAct/r)
              "Set point multiplied by reverse action sign"
              annotation (Placement(transformation(extent={{-200,30},{-180,50}})));
            Buildings.Controls.OBC.CDL.Reals.MultiplyByParameter uMea_revAct(
              final k=revAct/r)
              "Set point multiplied by reverse action sign"
              annotation (Placement(transformation(extent={{-200,-50},{-180,-30}})));
            Buildings.Controls.OBC.CDL.Reals.Add addPD
              "Outputs P and D gains added"
              annotation (Placement(transformation(extent={{20,124},{40,144}})));
            Buildings.Controls.OBC.CDL.Reals.Add addPID
              "Outputs P, I and D gains added"
              annotation (Placement(transformation(extent={{80,80},{100,100}})));
            Buildings.Controls.OBC.CDL.Reals.Subtract antWinErr if with_I
              "Error for anti-windup compensation"
              annotation (Placement(transformation(extent={{160,50},{180,70}})));
            Buildings.Controls.OBC.CDL.Reals.MultiplyByParameter antWinGai(
              k=1/(k*Ni)) if with_I
              "Gain for anti-windup compensation"
              annotation (Placement(transformation(extent={{180,-30},{160,-10}})));
            Buildings.Controls.OBC.CDL.Reals.Sources.Constant yResSig(
              final k=y_reset) if with_I
              "Signal for y_reset"
              annotation (Placement(transformation(extent={{-140,-84},{-120,-64}})));
            Buildings.Controls.OBC.CDL.Reals.Subtract addRes if with_I
              "Adder for integrator reset"
              annotation (Placement(transformation(extent={{-100,-90},{-80,-70}})));
            Buildings.Controls.OBC.CDL.Logical.Sources.Constant cheYMinMax(
              final k=yMin < yMax)
              "Check for values of yMin and yMax"
              annotation (Placement(transformation(extent={{120,-160},{140,-140}})));
            Buildings.Controls.OBC.CDL.Utilities.Assert assMesYMinMax(
              message="LimPID: Limits must be yMin < yMax")
              "Assertion on yMin and yMax"
              annotation (Placement(transformation(extent={{160,-160},{180,-140}})));

          equation
            connect(trigger,I.trigger)
              annotation (Line(points={{-160,-220},{-160,-140},{-40,-140},{-40,-12}},color={255,0,255}));
            connect(u_s,uS_revAct.u)
              annotation (Line(points={{-240,0},{-210,0},{-210,40},{-202,40}},color={0,0,127}));
            connect(u_m,uMea_revAct.u)
              annotation (Line(points={{0,-220},{0,-160},{-210,-160},{-210,-40},{-202,-40}},color={0,0,127}));
            connect(errD.u2,uMea_revAct.y)
              annotation (Line(points={{-142,64},{-150,64},{-150,-40},{-178,-40}}, color={0,0,127}));
            connect(D.u,errD.y)
              annotation (Line(points={{-52,70},{-118,70}}, color={0,0,127}));
            connect(errI1.u1,uS_revAct.y)
              annotation (Line(points={{-142,12},{-170,12},{-170,40},{-178,40}},
                                                                              color={0,0,127}));
            connect(addPID.u1,addPD.y)
              annotation (Line(points={{78,96},{50,96},{50,134},{42,134}},color={0,0,127}));
            connect(lim.y,y)
              annotation (Line(points={{142,90},{200,90},{200,0},{240,0}},color={0,0,127}));
            connect(antWinErr.y,antWinGai.u)
              annotation (Line(points={{182,60},{190,60},{190,-20},{182,-20}},color={0,0,127}));
            connect(addPD.u2,Dzero.y)
              annotation (Line(points={{18,128},{-10,128},{-10,100},{-28,100}},
                                                          color={0,0,127}));
            connect(D.y,addPD.u2)
              annotation (Line(points={{-28,70},{-10,70},{-10,128},{18,128}},color={0,0,127}));
            connect(addPID.u2,I.y)
              annotation (Line(points={{78,84},{60,84},{60,0},{-28,0}},color={0,0,127}));
            connect(addRes.y,I.y_reset_in)
              annotation (Line(points={{-78,-80},{-60,-80},{-60,-8},{-52,-8}},color={0,0,127}));
            connect(antWinErr.u2,lim.y)
              annotation (Line(points={{158,54},{150,54},{150,90},{142,90}},  color={0,0,127}));
            connect(I.u,errI2.y)
              annotation (Line(points={{-52,0},{-78,0}},color={0,0,127}));
            connect(errI1.y,errI2.u1)
              annotation (Line(points={{-118,6},{-102,6}},                  color={0,0,127}));
            connect(controlError.u1,u_s)
              annotation (Line(points={{-202,0},{-240,0}},                   color={0,0,127}));
            connect(cheYMinMax.y,assMesYMinMax.u)
              annotation (Line(points={{142,-150},{158,-150}},color={255,0,255}));
            connect(Izero.y,addPID.u2)
              annotation (Line(points={{-28,30},{60,30},{60,84},{78,84}},
                                                         color={0,0,127}));
            connect(errP.u1,uS_revAct.y)
              annotation (Line(points={{-142,146},{-170,146},{-170,40},{-178,40}},color={0,0,127}));
            connect(errD.u1,uS_revAct.y)
              annotation (Line(points={{-142,76},{-170,76},{-170,40},{-178,40}},color={0,0,127}));
            connect(addPD.u1, P.y)
              annotation (Line(points={{18,140},{-28,140}},                   color={0,0,127}));
            connect(P.u, errP.y)
              annotation (Line(points={{-52,140},{-118,140}},color={0,0,127}));
            connect(addPID.y, lim.u)
              annotation (Line(points={{102,90},{118,90}},color={0,0,127}));
            connect(addPID.y, antWinErr.u1) annotation (Line(points={{102,90},{114,90},{
                    114,66},{158,66}}, color={0,0,127}));
            connect(addRes.u1, yResSig.y)
              annotation (Line(points={{-102,-74},{-118,-74}},                       color={0,0,127}));
            connect(u_m, controlError.u2) annotation (Line(points={{0,-220},{0,-160},{
                    -210,-160},{-210,-12},{-202,-12}},
                                                color={0,0,127}));
            connect(uMea_revAct.y, errP.u2) annotation (Line(points={{-178,-40},{-150,-40},
                    {-150,134},{-142,134}}, color={0,0,127}));
            connect(uMea_revAct.y, errI1.u2) annotation (Line(points={{-178,-40},{-150,
                    -40},{-150,0},{-142,0}},
                                          color={0,0,127}));
            connect(antWinGai.y, errI2.u2) annotation (Line(points={{158,-20},{-110,-20},
                    {-110,-6},{-102,-6}},
                                        color={0,0,127}));
            connect(addPD.y, addRes.u2) annotation (Line(points={{42,134},{50,134},{50,
                    -100},{-110,-100},{-110,-86},{-102,-86}},
                                                        color={0,0,127}));
            connect(kDer.y, D.k) annotation (Line(points={{-78,120},{-58,120},{-58,78},{
                    -52,78}}, color={0,0,127}));
            connect(TDer.y, D.T) annotation (Line(points={{-78,90},{-60,90},{-60,74},{-52,
                    74}}, color={0,0,127}));

            annotation (
              defaultComponentName="conPID",
              Icon(
                coordinateSystem(
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-6,-20},{66,-66}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.P),
                    extent={{-32,-22},{68,-62}},
                    textColor={0,0,0},
                    textString="P",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI),
                    extent={{-26,-22},{74,-62}},
                    textColor={0,0,0},
                    textString="PI",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD),
                    extent={{-16,-22},{88,-62}},
                    textColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175},
                    textString="P D"),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID),
                    extent={{-14,-22},{86,-62}},
                    textColor={0,0,0},
                    textString="PID",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Polygon(
                    points={{-80,82},{-88,60},{-72,60},{-80,82}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-80,68},{-80,-100}},
                    color={192,192,192}),
                  Line(
                    points={{-90,-80},{70,-80}},
                    color={192,192,192}),
                  Polygon(
                    points={{74,-80},{52,-72},{52,-88},{74,-80}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    textColor={0,0,255}),
                  Line(
                    points={{-80,-80},{-80,-22}},
                    color={0,0,0}),
                  Line(
                    points={{-80,-22},{6,56}},
                    color={0,0,0}),
                  Line(
                    points={{6,56},{68,56}},
                    color={0,0,0}),
                  Rectangle(
                    extent=DynamicSelect({{100,-100},{84,-100}},{{100,-100},{84,-100+(y-yMin)/(yMax-yMin)*200}}),
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0})}),
              Diagram(
                coordinateSystem(
                  extent={{-220,-200},{220,200}}), graphics={Rectangle(
                    extent={{-56,180},{-24,-16}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None), Text(
                    extent={{-52,184},{-28,156}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    textColor={0,0,0},
                    textString="PID")}),
              Documentation(
                info="<html>
<p>
PID controller in the standard form
</p>
<p align=\"center\" style=\"font-style:italic;\">
y<sub>u</sub> = k/r &nbsp; (e(t) + 1 &frasl; T<sub>i</sub> &nbsp; &int; e(&tau;) d&tau; + T<sub>d</sub> d&frasl;dt e(t)),
</p>
<p>
with output reset,
where
<i>y<sub>u</sub></i> is the control signal before output limitation,
<i>e(t) = u<sub>s</sub>(t) - u<sub>m</sub>(t)</i> is the control error,
with <i>u<sub>s</sub></i> being the set point and <i>u<sub>m</sub></i> being
the measured quantity,
<i>k</i> is the gain,
<i>T<sub>i</sub></i> is the time constant of the integral term,
<i>T<sub>d</sub></i> is the time constant of the derivative term,
and
<i>r</i> is a scaling factor, with default <i>r=1</i>.
The scaling factor should be set to the typical order of magnitude of the range of the error <i>e</i>.
For example, you may set <i>r=100</i> to <i>r=1000</i>
if the control input is a pressure of a heating water circulation pump in units of Pascal, or
leave <i>r=1</i> if the control input is a room temperature.
</p>
<p>
Note that the units of <i>k</i> are the inverse of the units of the control error,
while the units of <i>T<sub>i</sub></i> and <i>T<sub>d</sub></i> are seconds.
</p>
<p>
The actual control output is
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = min( y<sub>max</sub>, max( y<sub>min</sub>, y)),
</p>
<p>
where <i>y<sub>min</sub></i> and <i>y<sub>max</sub></i> are limits for the control signal.
</p>
<h4>P, PI, PD, or PID action</h4>
<p>
Through the parameter <code>controllerType</code>, the controller can be configured
as P, PI, PD or PID controller. The default configuration is PI.
</p>
<h4>Reverse or direct action</h4>
<p>
Through the parameter <code>reverseActing</code>, the controller can be configured to
be reverse or direct acting.
The above standard form is reverse acting, which is the default configuration.
For a reverse acting controller, for a constant set point,
an increase in measurement signal <code>u_m</code> decreases the control output signal <code>y</code>
(Montgomery and McDowall, 2008).
Thus,
</p>
<ul>
  <li>
  for a heating coil with a two-way valve, leave <code>reverseActing = true</code>, but
  </li>
  <li>
  for a cooling coil with a two-way valve, set <code>reverseActing = false</code>.
  </li>
</ul>
<p>
If <code>reverseAction=false</code>, then the error <i>e</i> above is multiplied by <i>-1</i>.
</p>
<h4>Anti-windup compensation</h4>
<p>
The controller anti-windup compensation is as follows:
Instead of the above basic control law, the implementation is
</p>
<p align=\"center\" style=\"font-style:italic;\">
y<sub>u</sub> = k &nbsp; (e(t) &frasl; r + 1 &frasl; T<sub>i</sub> &nbsp; &int; (-&Delta;y + e(&tau;) &frasl; r) d&tau; + T<sub>d</sub> &frasl; r d&frasl;dt e(t)),
</p>
<p>
where the anti-windup compensation <i>&Delta;y</i> is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&Delta;y = (y<sub>u</sub> - y) &frasl; (k N<sub>i</sub>),
</p>
<p>
where
<i>N<sub>i</sub> &gt; 0</i> is the time constant for the anti-windup compensation.
To accelerate the anti-windup, decrease <i>N<sub>i</sub></i>.
</p>
<p>
Note that the anti-windup term <i>(-&Delta;y + e(&tau;) &frasl; r)</i> shows that the range of
the typical control error <i>r</i> should be set to a reasonable value so that
</p>
<p align=\"center\" style=\"font-style:italic;\">
e(&tau;) &frasl; r = (u<sub>s</sub>(&tau;) - u<sub>m</sub>(&tau;)) &frasl; r
</p>
<p>
has order of magnitude one, and hence the anti-windup compensation should work well.
</p>
<h4>Reset of the controller output</h4>
<p>
Whenever the value of boolean input signal <code>trigger</code> changes from
<code>false</code> to <code>true</code>, the controller output is reset by setting
<code>y</code> to the value of the parameter <code>y_reset</code>.
</p>
<h4>Approximation of the derivative term</h4>
<p>
The derivative of the control error <i>d &frasl; dt e(t)</i> is approximated using
</p>
<p align=\"center\" style=\"font-style:italic;\">
d&frasl;dt x(t) = (e(t)-x(t)) N<sub>d</sub> &frasl; T<sub>d</sub>,
</p>
<p>
and
</p>
<p align=\"center\" style=\"font-style:italic;\">
d&frasl;dt e(t) &asymp; N<sub>d</sub> (e(t)-x(t)),
</p>
<p>
where <i>x(t)</i> is an internal state.
</p>
<h4>Guidance for tuning the control gains</h4>
<p>
The parameters of the controller can be manually adjusted by performing
closed loop tests (= controller + plant connected
together) and using the following strategy:
</p>
<ol>
<li> Set very large limits, e.g., set <i>y<sub>max</sub> = 1000</i>.
</li>
<li>
Select a <strong>P</strong>-controller and manually enlarge the parameter <code>k</code>
(the total gain of the controller) until the closed-loop response
cannot be improved any more.
</li>
<li>
Select a <strong>PI</strong>-controller and manually adjust the parameters
<code>k</code> and <code>Ti</code> (the time constant of the integrator).
The first value of <code>Ti</code> can be selected such that it is in the
order of the time constant of the oscillations occurring with
the P-controller. If, e.g., oscillations in the order of <i>100</i> seconds
occur in the previous step, start with <code>Ti=1/100</code> seconds.
</li>
<li>
If you want to make the reaction of the control loop faster
(but probably less robust against disturbances and measurement noise)
select a <strong>PID</strong>-controller and manually adjust parameters
<code>k</code>, <code>Ti</code>, <code>Td</code> (time constant of derivative block).
</li>
<li>
Set the limits <code>yMax</code> and <code>yMin</code> according to your specification.
</li>
<li>
Perform simulations such that the output of the PID controller
goes in its limits. Tune <code>Ni</code> (<i>N<sub>i</sub> T<sub>i</sub></i> is the time constant of
the anti-windup compensation) such that the input to the limiter
block (= <code>lim.u</code>) goes quickly enough back to its limits.
If <code>Ni</code> is decreased, this happens faster. If <code>Ni</code> is very large, the
anti-windup compensation is not effective and the controller works bad.
</li>
</ol>
<h4>References</h4>
<p>
R. Montgomery and R. McDowall (2008).
\"Fundamentals of HVAC Control Systems.\"
American Society of Heating Refrigerating and Air-Conditioning Engineers Inc. Atlanta, GA.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 20, 2022, by Michael Wetter:<br/>
Refactored implementation to use new derivative block from CDL package.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3022\">issue 3022</a>.
</li>
<li>
May 6, 2022, by Michael Wetter:<br/>
Corrected wrong documentation in how the derivative of the control error is approximated.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2994\">issue 2994</a>.
</li>
<li>
April 30, 2021, by Michael Wetter:<br/>
Corrected error in non-released development version
when reset trigger is <code>true</code>.<br/>
Refactored implementation to have separate blocks that show the P, I and D contribution,
each with the control gain applied.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2475\">issue 2475</a>.
</li>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.Units.SI</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
October 15, 2020, by Michael Wetter:<br/>
Added scaling factor <code>r</code>, removed set point weights <code>wp</code> and <code>wd</code>.
Revised documentation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2182\">issue 2182</a>.
</li>
<li>
August 4, 2020, by Jianjun Hu:<br/>
Removed the input <code>y_reset_in</code>.
Refactored to internally implement the derivative block.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2056\">issue 2056</a>.
</li>
<li>
June 1, 2020, by Michael Wetter:<br/>
Corrected wrong convention of reverse and direct action.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1365\">issue 1365</a>.
</li>
<li>
April 23, 2020, by Michael Wetter:<br/>
Changed default parameters for limits <code>yMax</code> from unspecified to <code>1</code>
and <code>yMin</code> from <code>-yMax</code> to <code>0</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1888\">issue 1888</a>.
</li>
<li>
April 7, 2020, by Michael Wetter:<br/>
Reimplemented block using only CDL constructs.
This refactoring removes the no longer use parameters <code>xd_start</code> that was
used to initialize the state of the derivative term. This state is now initialized
based on the requested initial output <code>yd_start</code> which is a new parameter
with a default of <code>0</code>.
Also, removed the parameters <code>y_start</code> and <code>initType</code> because
the initial output of the controller can be set by using <code>xi_start</code>
and <code>yd_start</code>.
This is a non-backward compatible change, made to simplify the controller through
the removal of options that can be realized differently and are hardly ever used.
This refactoring also removes the parameter <code>strict</code> that
was used in the output limiter. The new implementation enforces a strict check by default.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1878\">issue 1878</a>.
</li>
<li>
March 9, 2020, by Michael Wetter:<br/>
Corrected unit declaration for gain <code>k</code>.<br/>
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1821\">issue 1821</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display the output value.
</li>
<li>
October 19, 2019, by Michael Wetter:<br/>
Disabled homotopy to ensure bounded outputs
by copying the implementation from MSL 3.2.3 and by
hardcoding the implementation for <code>homotopyType=NoHomotopy</code>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1221\">issue 1221</a>.
</li>
<li>
November 13, 2017, by Michael Wetter:<br/>
Changed default controller type from PID to PI.
</li>
<li>
November 6, 2017, by Michael Wetter:<br/>
Explicitly declared types and used integrator with reset from CDL.
</li>
<li>
October 22, 2017, by Michael Wetter:<br/>
Added to CDL to have a PI controller with integrator reset.
</li>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model.
</li>
<li>
August 25, 2016, by Michael Wetter:<br/>
Removed parameter <code>limitsAtInit</code> because it was only propagated to
the instance <code>limiter</code>, but this block no longer makes use of this parameter.
This is a non-backward compatible change.<br/>
Revised implemenentation, added comments, made some parameter in the instances final.
</li>
<li>July 18, 2016, by Philipp Mehrfeld:<br/>
Added integrator reset.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/494\">issue 494</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Changed the default value to <code>strict=true</code> in order to avoid events
when the controller saturates.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/433\">issue 433</a>.
</li>
<li>
February 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PIDWithReset;

          block Subtract "Output the difference of the two inputs"
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1-u2;
            annotation (
              defaultComponentName="sub",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y</code> as the difference of the
two input signals <code>u1</code> and <code>u2</code>,
</p>
<pre>
    y = u1 - u2
</pre>
</html>", revisions="<html>
<ul>
<li>
January 28, 2022, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    lineColor={0,0,127},
                    extent={{-50,-50},{50,50}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    textColor={0,0,255}),
                  Line(
                    points={{-100,60},{-74,24},{-44,24}},
                    color={0,0,127}),
                  Line(
                    points={{-100,-60},{-74,-28},{-42,-28}},
                    color={0,0,127}),
                  Line(
                    points={{50,0},{100,0}},
                    color={0,0,127}),
                  Text(
                    extent={{-38,-28},{38,40}},
                    textString="-",
                    textColor={0,0,0}),
                  Text(
                    extent={{226,60},{106,10}},
                    textColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftJustified=false,
                      significantDigits=3)))}));
          end Subtract;

          package Sources "Package with blocks that generate source signals"

            block Constant
              "Output constant signal of type Real"
              parameter Real k
                "Constant output value";
              Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
                "Connector of Real output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=k;
              annotation (
                defaultComponentName="con",
                Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}),
                  graphics={
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      textColor={0,0,255},
                      extent={{-150,110},{150,150}},
                      textString="%name"),
                    Line(
                      points={{-80,68},{-80,-80}},
                      color={192,192,192}),
                    Polygon(
                      points={{-80,90},{-88,68},{-72,68},{-80,90}},
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-90,-70},{82,-70}},
                      color={192,192,192}),
                    Polygon(
                      points={{90,-70},{68,-62},{68,-78},{90,-70}},
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80,0},{80,0}}),
                    Text(
                      extent={{-150,-150},{150,-110}},
                      textColor={0,0,0},
                      textString="k=%k"),
                    Text(
                      extent={{226,60},{106,10}},
                      textColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftJustified=false,
                        significantDigits=3)))}),
                Documentation(
                  info="<html>
<p>
Block that outputs a constant signal <code>y = k</code>,
where <code>k</code> is a real-valued parameter.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Reals/Constant.png\"
     alt=\"Constant.png\" />
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 16, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
            end Constant;
            annotation (
              Documentation(
                info="<html>
<p>
Package with blocks that generate signals.
</p>
</html>"),    Icon(
                graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{-70,-4.5},{0,4.5}}),
                  Polygon(
                    origin={23.3333,0.0},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0)}));
          end Sources;
          annotation (
            Documentation(
              info="<html>
<p>
Package with blocks for elementary mathematical functions
for continuous variables.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Text(
                  extent={{-52,86},{52,-92}},
                  textColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="R"),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0)}));
        end Reals;

        package Utilities "Package with utility functions"

          block Assert
            "Print a warning message when input becomes false"
            parameter String message
              "Message written when u becomes false";
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput u
              "Boolean input that triggers assert when it becomes false"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          equation
            assert(
              u,
              message,
              AssertionLevel.warning);
            annotation (
              defaultComponentName="assMes",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{0,80},{-80,-60},{80,-60},{0,80}},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Text(
                    extent={{-100,160},{100,106}},
                    textColor={0,0,255},
                    textString="%name"),
                  Polygon(
                    points={{0,72},{-72,-56},{72,-56},{0,72}},
                    lineColor={0,0,0},
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-4,38},{2,-24}},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Ellipse(
                    extent={{-6,-32},{4,-42}},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid)}),
              Documentation(
                info="<html>
<p>
Block that writes a warning if the input becomes <code>false</code>.
</p>
<p>
Tools or control systems are expected to write <code>message</code> together
with a time stamp to an output device and/or a log file.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 6, 2017, by Michael Wetter:<br/>
Simplified implementation.
</li>
<li>
November 3, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
          end Assert;
          annotation (
            preferredView="info",
            Documentation(
              info="<html>
<p>
This package contains utility models
that are used throughout the library.
</p>
</html>"),  Icon(
              coordinateSystem(
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={1.3835,-4.1418},
                  rotation=45.0,
                  fillColor={64,64,64},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
                Polygon(
                  origin={10.1018,5.218},
                  rotation=-45.0,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
        end Utilities;

        package Types "Package with type definitions"

          type SimpleController = enumeration(
              P
            "P controller",
              PI
            "PI controller",
              PD
            "PD controller",
              PID
            "PID controller")
            "Enumeration defining P, PI, PD, or PID simple controller type"
            annotation (Evaluate=true,Documentation(info="<html>
<p>
Enumeration to define the type of the controller.
Possible values are:
</p>
<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td><code>P</code></td>
<td>
Controller with proportional term.
</td></tr>
<tr><td><code>PI</code></td>
<td>
Controller with proportional and integral terms.
</td></tr>
<tr><td><code>PD</code></td>
<td>
Controller with proportional and derivative term.
</td></tr>
<tr><td><code>PID</code></td>
<td>
Controller with proportional, integral and derivative terms.
</td></tr>
</table>
</html>",          revisions="<html>
<ul>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
          annotation (
            Documentation(
              info="<html>
<p>
This package contains type definitions.
</p>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={-12.167,-23},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},{14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,-30},{4.167,20},{12.167,65}},
                  smooth=Smooth.Bezier,
                  lineColor={0,0,0}),
                Polygon(
                  origin={2.7403,1.6673},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
                  smooth=Smooth.Bezier)}));
        end Types;

        package Interfaces
        "Package with connectors for input and output signals"

          connector BooleanInput=input Boolean
            "Boolean input connector"
          annotation (defaultComponentName="u",
           Icon(graphics={Polygon(lineColor={255,0,255},
                                  fillColor={255,0,255},
                                  fillPattern = FillPattern.Solid,
                                  points={{0,50},{100,0},{0,-50}})},
                coordinateSystem(extent={{-100,-100},{100,100}},
                                 preserveAspectRatio=true,
                                 initialScale=0.2)),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100,-100},{100,100}}),
                   graphics={Polygon(points={{0,50},{100,0},{0,-50},{0,50}},
                                     lineColor={255,0,255},
                                     fillColor={255,0,255},fillPattern = FillPattern.Solid),
                             Text(extent={{-10,85},{-10,60}},
                                  textColor={255,0,255},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>",          revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));

          connector BooleanOutput=output Boolean
            "Boolean output connector"
          annotation (defaultComponentName="y",
           Icon(coordinateSystem(preserveAspectRatio=true,
                                 initialScale=0.2,
                                 extent={{-100,-100},{100,100}}),
                graphics={Polygon(lineColor={255,0,255},
                                  fillColor={255,255,255},
                                  fillPattern= FillPattern.Solid,
                                  points={{-100,50},{0,0},{-100,-50}})}),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100,-100},{100,100}}),
                   graphics={Polygon(points={{-100,50},{0,0},{-100,-50},{-100,50}},
                                     lineColor={255,0,255},
                                     fillColor={255,255,255},
                                     fillPattern= FillPattern.Solid),
                             Text(extent={{30,110},{30,60}},
                                  textColor={255,0,255},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>",          revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));

          connector RealInput=input Real
            "Real input connector"
          annotation (defaultComponentName="u",
           Icon(graphics={Polygon(lineColor={0,0,127},
                                  fillColor={0,0,127},
                                  fillPattern=FillPattern.Solid,
                                  points={{0,50},{100,0},{0,-50}})},
                coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
                                 preserveAspectRatio=true,
                                 initialScale=0.2)),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100.0,-100.0},{100.0,100.0}}),
                   graphics={Polygon(lineColor={0,0,127},
                                     fillColor={0,0,127},
                                     fillPattern=FillPattern.Solid,
                                     points={{0.0,50.0},{100.0,0.0},{0.0,-50.0},{0.0,50.0}}),
                             Text(textColor={0,0,127},
                                  extent={{-10.0,60.0},{-10.0,85.0}},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>",          revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));

          connector RealOutput=output Real
            "Real output connector"
          annotation (defaultComponentName="y",
           Icon(coordinateSystem(preserveAspectRatio=true,
                                 initialScale=0.2,
                                 extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={Polygon(lineColor={0,0,127},
                                  fillColor={255,255,255},
                                  fillPattern=FillPattern.Solid,
                                  points={{-100,50},{0,0},{-100,-50}})}),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100.0,-100.0},{100.0,100.0}}),
                   graphics={Polygon(lineColor={0,0,127},
                                     fillColor={255,255,255},
                                     fillPattern=FillPattern.Solid,
                                     points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
                             Text(textColor={0,0,127},
                                  extent={{30.0,60.0},{30.0,110.0}},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>",          revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          annotation (
            preferredView="info",
            Documentation(
              info="<html>
<p>
This package contains implementations of connectors for input
and output signals of blocks.
</p>
<p>
The connectors are compatible with, and equivalent to,
the connectors from the Modelica Standard Library.
They are here implemented to make the <code>CDL</code>
package a self-contained package.
</p>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={20.0,0.0},
                  lineColor={64,64,64},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  points={{-10.0,70.0},{10.0,70.0},{40.0,20.0},{80.0,20.0},{80.0,-20.0},{40.0,-20.0},{10.0,-70.0},{-10.0,-70.0}}),
                Polygon(
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-100.0,20.0},{-60.0,20.0},{-30.0,70.0},{-10.0,70.0},{-10.0,-70.0},{-30.0,-70.0},{-60.0,-20.0},{-100.0,-20.0}})}));
        end Interfaces;
        annotation (
          Documentation(
            info="<html>
<p>
Package that has elementary input-output blocks
that form the Control Description Language (CDL).
The implementation is structured into sub-packages.
The packages <code>Validation</code> and <code>Examples</code>
contain validation and example models.
These are not part of the CDL specification, but rather
implemented to provide reference responses computed by the CDL blocks.
For a specification of CDL, see
<a href=\"https://obc.lbl.gov/specification/cdl.html\">
https://obc.lbl.gov/specification/cdl.html</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),Icon(
            graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Ellipse(
                origin={10.0,10.0},
                fillColor={76,76,76},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{-80.0,-80.0},{-20.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,-80.0},{60.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                fillColor={128,128,128},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,0.0},{60.0,60.0}}),
              Ellipse(
                origin={10.0,10.0},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-80.0,0.0},{-20.0,60.0}})}));
      end CDL;
    annotation (
    Documentation(info="<html>
<p>
Package that contains a library of elementary control blocks
and a library that implements control sequences from the ASHRAE Guideline 36.
</p>
<p>
These implementations have been developed
through the OpenBuildingControl (<a href=\"https://obc.lbl.gov\">obc.lbl.gov</a>) project
that develops a process and tools for the
performance evaluation, specification and verification
of building control sequences.
</p>
<p>
For a tutorial for how to implement control sequences using the
Control Description Language (CDL), see
<a href=\"modelica://Buildings.Examples.Tutorial.CDL\">
Buildings.Examples.Tutorial.CDL</a>.
</p>
</html>"),
    Icon(graphics={Bitmap(extent={{-92,-98},{104,96}},
    fileName="modelica://Buildings/Resources/Images/Controls/OBC/OBC_logo-only_150dpi.png")}));
    end OBC;

    package SetPoints "Package with models for control set points"
      extends Modelica.Icons.VariantsPackage;

      model Table
        "Model for a set point that is interpolated based on a user-specified table"
        extends Modelica.Blocks.Interfaces.SISO;
        parameter Real table[:,2]=fill(0.0, 1, 2)
          "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])";

        parameter Real offset=0 "Offset of output signal";

        parameter Boolean constantExtrapolation = true
          "If true, then y=y1 for u<u1, and y=yMax for u>uMax";

    protected
        final parameter Integer nRow = if constantExtrapolation then
                              size(table,1)+2 else
                              size(table,1) "Number of rows";
        final parameter Real[nRow,2] offsetVector = [zeros(nRow), offset*ones(nRow)]
          "Vector to take offset of output signal into account";
        Modelica.Blocks.Tables.CombiTable1Dv tab(tableOnFile=false, final table=(if
              constantExtrapolation then cat(
              1,
              [table[1, 1] - 1,table[1, 2]],
              table,
              [table[end, 1] + 1,table[end, 2]]) else table) + offsetVector)
          "Table used for interpolation"
          annotation (Placement(transformation(extent={{-20,-10},{2,10}})));
      equation
        connect(u, tab.u[1]) annotation (Line(
            points={{-120,0},{-70,0},{-70,0},{-22,0}},
            color={0,0,127}));

        connect(tab.y[1], y) annotation (Line(
            points={{3.1,0},{53.55,0},{53.55,0},{110,0}},
            color={0,0,127}));

        annotation (
      defaultComponentName="tab",
      Documentation(info="<html>
<p>
This block can be used to schedule a set-point by using piecewise linear functions.
For example, the instances
</p>
<pre>
Buildings.Controls.SetPoints.Table tabLinExt(constantExtrapolation=false,
                                             table=[20, 0.0;
                                                    22, 0.5;
                                                    25, 0.5;
                                                    26, 1.0]);
Buildings.Controls.SetPoints.Table tabConExt(constantExtrapolation=true,
                                             table=[20, 0.0;
                                                    22, 0.5;
                                                    25, 0.5;
                                                    26, 1.0]);
</pre>
<p>
will cause the following output:
</p>
<p>
<img src=\"modelica://Buildings/Resources/Images/Controls/SetPoints/Table.png\" border=\"1\" alt=\"Table output.\"/>
</p>
<p>
For the default setting <code>constantExtrapolation=true</code>, the
block outputs
<code>y=y1+offset</code> for <code>u &le; u1</code>, and
<code>y=yMax+offset</code> for <code>u &ge; uMax</code>.
Otherwise, the table is linearly extrapolated with a constant derivative.
</p>
<p>
Note that the first column must be strictly increasing.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 30, 2016, by Michael Wetter:<br/>
Changed protected final parameter <code>nCol</code> to <code>nRow</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/555\">issue 555</a>.
</li>
<li>
April 5, 2011, by Michael Wetter:<br/>
Fixed wrong table declaration.
</li>
<li>
July 13, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={
          Text(
            extent={{-78,-45},{-40,-56}},
            textColor={0,0,0},
            textString="offset"),
          Line(
            points={{-42,-24},{-42,-74}},
            color={95,95,95},
            thickness=0.25,
            arrow={Arrow.None,Arrow.None}),
          Line(
            points={{-82,-24},{-22,-24},{26,24}},
            color={0,0,255},
            thickness=0.5),
          Line(points={{-82,64},{-82,-84}}, color={95,95,95}),
          Text(
            extent={{-80,88},{-39,68}},
            textColor={0,0,0},
            textString="y"),
          Polygon(
            points={{-82,86},{-88,64},{-76,64},{-82,86}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Polygon(
            points={{88,-74},{66,-68},{66,-80},{88,-74}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(points={{-92,-74},{80,-74}}, color={95,95,95}),
          Text(
            extent={{68,-84},{92,-95}},
            textColor={0,0,0},
                textString="u"),
          Polygon(
            points={{-42,-24},{-44,-34},{-39,-34},{-42,-24}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Polygon(
            points={{-42,-74},{-45,-64},{-40,-64},{-42,-74},{-42,-74}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{26,24},{77,24}},
            color={0,0,255},
            thickness=0.5)}));
      end Table;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models to compute set points of control systems.
For additional models, see also
<a href=\"modelica://Modelica.Blocks.Continuous\">
Modelica.Blocks.Continuous</a>.
</html>"));
    end SetPoints;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains component models for controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}));
  end Controls;

  package Fluid "Package with models for fluid flow systems"
    extends Modelica.Icons.Package;

    package Actuators "Package with actuator models such as valves and dampers"
      extends Modelica.Icons.VariantsPackage;

      package Valves "Package with valve models"
        extends Modelica.Icons.VariantsPackage;

        model ThreeWayLinear "Three way valve with linear characteristics"
            extends BaseClasses.PartialThreeWayValve(
              redeclare TwoWayLinear res1(
                final l=l[1]),
              redeclare TwoWayLinear res3(
                final l=l[2]));

        equation
          connect(inv.y, res3.y) annotation (Line(points={{-62.6,46},{30,46},{30,-50},{
                  12,-50}},      color={0,0,127}));
          connect(y_actual, inv.u2) annotation (Line(points={{50,70},{88,70},{88,34},{
                  -68,34},{-68,41.2}},
                                 color={0,0,127}));
          connect(y_actual, res1.y) annotation (Line(points={{50,70},{88,70},{88,34},{
                  -50,34},{-50,12}},
                color={0,0,127}));
          annotation (defaultComponentName="val",
        Documentation(info="<html>
<p>
Three way valve with linear opening characteristic.
</p><p>
This model is based on the partial valve models
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a> and
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>
for the implementation of the three way valve
and see
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
for the implementation of the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 7, 2022, by Michael Wetter:<br/>
Set <code>final massDynamics=energyDynamics</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">#1542</a>.
</li>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
November 5, 2019, by Michael Wetter:<br/>
Moved assignment of leakage from <a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>
to the parent classes.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1227\">#1227</a>.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
Added filter to approximate the travel time of the actuator.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 16, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ThreeWayLinear;

        model TwoWayLinear "Two way valve with linear flow characteristics"
          extends BaseClasses.PartialTwoWayValveKv(phi=max(0.1*l, l + y_actual*(1 - l)));

        initial equation
          // Since the flow model Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow computes
          // 1/k^2, the parameter l must not be zero.
          assert(l > 0, "Valve leakage parameter l must be bigger than zero.");
        annotation (
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Two way valve with linear opening characteristic.
</p><p>
This model is based on the partial valve model
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
August 7, 2020, by Ettore Zanetti:<br/>
changed the computation of <code>phi</code> using
<code>max(0.1*l, . )</code> to avoid
phi=0.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1376\">
issue 1376</a>.
</li>
<li>
November 9, 2019, by Filip Jorissen:<br/>
Guarded the computation of <code>phi</code> using
<code>max(0, . )</code> to avoid
negative phi.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1223\">
issue 1223</a>.
</li>
<li>
April 4, 2014, by Michael Wetter:<br/>
Moved the assignment of the flow function <code>phi</code>
to the model instantiation because in its base class,
the keyword <code>input</code>
has been added to the variable <code>phi</code>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal=0</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayLinear;
      annotation (preferredView="info", Documentation(info="<html>
This package contains component models for two- and three-way valves.
For motor models, see
<a href=\"modelica://Buildings.Fluid.Actuators.Motors\">Buildings.Fluid.Actuators.Motors</a>.
</html>"));
      end Valves;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Actuators"
        extends Modelica.Icons.BasesPackage;

        model ActuatorSignal
          "Partial model that implements the filtered opening for valves and dampers"

          constant Integer order(min=1) = 2 "Order of filter";

          parameter Boolean use_inputFilter=true
            "= true, if opening is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered opening"));
          parameter Modelica.Units.SI.Time riseTime=120
            "Rise time of the filter (time to reach 99.6 % of an opening step)"
            annotation (Dialog(
              tab="Dynamics",
              group="Filtered opening",
              enable=use_inputFilter));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Real y_start=1 "Initial position of actuator"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));

          Modelica.Blocks.Interfaces.RealInput y(min=0, max=1)
            "Actuator position (0: closed, 1: open)"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                  rotation=270,
                origin={0,120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));

          Modelica.Blocks.Interfaces.RealOutput y_actual
            "Actual actuator position"
            annotation (Placement(transformation(extent={{40,60},{60,80}})));

          // Classes used to implement the filtered opening
      protected
          final parameter Modelica.Units.SI.Frequency fCut=5/(2*Modelica.Constants.pi*
              riseTime) "Cut-off frequency of filter";

          parameter Boolean casePreInd = false
            "In case of PressureIndependent the model I/O is modified"
            annotation(Evaluate=true);
          Modelica.Blocks.Interfaces.RealOutput y_internal(unit="1")
            "Output connector for internal use (= y_actual if not casePreInd)";
          Modelica.Blocks.Interfaces.RealOutput y_filtered if use_inputFilter
            "Filtered valve position in the range 0..1"
            annotation (Placement(transformation(extent={{40,78},{60,98}}),
                iconTransformation(extent={{60,50},{80,70}})));

          Buildings.Fluid.BaseClasses.ActuatorFilter filter(
            final n=order,
            final f=fCut,
            final normalized=true,
            final initType=init,
            final y_start=y_start) if use_inputFilter
            "Second order filter to approximate actuator opening time, and to improve numerics"
            annotation (Placement(transformation(extent={{6,81},{20,95}})));

        equation
          connect(filter.y, y_filtered)
            annotation (Line(points={{20.7,88},{50,88}}, color={0,0,127}));
          if use_inputFilter then
            connect(y, filter.u) annotation (Line(points={{1.11022e-15,120},{1.11022e-15,
                    88},{4.6,88}}, color={0,0,127}));
            connect(filter.y, y_internal) annotation (Line(points={{20.7,88},{30,88},{30,
                    70},{50,70}}, color={0,0,127}));
          else
            connect(y, y_internal) annotation (Line(
              points={{1.11022e-15,120},{0,120},{0,70},{50,70}},
              color={0,0,127}));
          end if;
          if not casePreInd then
            connect(y_internal, y_actual);
          end if;
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={
                Line(
                  points={{0,48},{0,108}}),
                Line(
                  points={{0,70},{40,70}}),
                Rectangle(
                  visible=use_inputFilter,
                  extent={{-32,40},{34,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=use_inputFilter,
                  extent={{-32,100},{34,40}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=use_inputFilter,
                  extent={{-20,94},{22,48}},
                  textColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold}),
                Text(
                  extent={{-40,126},{-160,76}},
                  textColor={0,0,0},
                  textString=DynamicSelect("", String(y, format=".2f")))}),
        Documentation(info="<html>
<p>
This model implements the filter that is used to approximate the travel
time of the actuator.
Models that extend this model use the signal
<code>y_actual</code> to obtain the
current position of the actuator.
</p>
<p>
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>
for a description of the filter.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
April 6, 2020, by Antoine Gautier:<br/>
Add the boolean parameter <code>casePreInd</code>.<br/>
This is needed for the computation of the damper opening in
<a href=\"modelica://Buildings.Fluid.Actuators.Dampers.PressureIndependent\">
Buildings.Fluid.Actuators.Dampers.PressureIndependent</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
November 14, 2019, by Michael Wetter:<br/>
Set <code>start</code> attribute for <code>filter.x</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1252\">#1252</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
February 16, 2018, by Filip Jorissen:<br/>
Propagated parameter <code>order</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/891\">#891</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ActuatorSignal;

        partial model PartialThreeWayValve "Partial three way valve"
          extends Buildings.Fluid.BaseClasses.PartialThreeWayResistance(
            m_flow_small = m_flow_nominal*1e-4,
            final mDyn_flow_nominal = m_flow_nominal,
              redeclare replaceable
              Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve res1
                constrainedby
            Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve(
                  deltaM=deltaM,
                  from_dp=from_dp,
                  final linearized=linearized[1],
                  final homotopyInitialization=homotopyInitialization,
                  final CvData=Buildings.Fluid.Types.CvTypes.OpPoint,
                  final m_flow_nominal=m_flow_nominal,
                  final dpValve_nominal=dpValve_nominal,
                  final dpFixed_nominal=dpFixed_nominal[1],
                  final use_inputFilter=false,
                  final riseTime=riseTime),
              redeclare FixedResistances.LosslessPipe res2(
                m_flow_nominal=m_flow_nominal),
              redeclare replaceable
              Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve res3
                constrainedby
            Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve(
                  deltaM=deltaM,
                  from_dp=from_dp,
                  final linearized=linearized[2],
                  final homotopyInitialization=homotopyInitialization,
                  final CvData=Buildings.Fluid.Types.CvTypes.OpPoint,
                  final m_flow_nominal=m_flow_nominal,
                  final dpValve_nominal=dpValve_nominal/fraK^2,
                  final dpFixed_nominal=dpFixed_nominal[2],
                  final use_inputFilter=false,
                  final riseTime=riseTime));
            extends Buildings.Fluid.Actuators.BaseClasses.ActuatorSignal;
            extends Buildings.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default));

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Modelica.Units.SI.PressureDifference dpFixed_nominal[2](
            each displayUnit="Pa",
            each min=0) = {0,0}
            "Nominal pressure drop of pipes and other equipment in flow legs at port_1 and port_3"
            annotation (Dialog(group="Nominal condition"));

          parameter Real fraK(min=0, max=1) = 0.7
            "Fraction Kv(port_3&rarr;port_2)/Kv(port_1&rarr;port_2)";
          parameter Real[2] l(each min=0, each max=1) = {0.0001, 0.0001}
            "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          parameter Real deltaM = 0.02
            "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));

          parameter Boolean[2] linearized = {false, false}
            "= true, use linear relation between m_flow and dp for any flow rate"
            annotation(Dialog(tab="Advanced"));

      protected
          Modelica.Blocks.Math.Feedback inv "Inversion of control signal"
            annotation (Placement(transformation(extent={{-74,40},{-62,52}})));
          Modelica.Blocks.Sources.Constant uni(final k=1)
            "Outputs one for bypass valve"
            annotation (Placement(transformation(extent={{-92,40},{-80,52}})));

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          connect(uni.y, inv.u1)
            annotation (Line(points={{-79.4,46},{-72.8,46}},
                             color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,40},{100,-40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Rectangle(
              extent={{-100,22},{100,-22}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255}),
            Rectangle(
              extent={{-60,40},{60,-40}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{0,0},{-76,60},{-76,-60},{0,0}},
              lineColor={0,0,0},
              fillColor=DynamicSelect({0,0,0}, y*{255,255,255}),
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{0,0},{76,60},{76,-60},{0,0}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-40,-56},{40,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.VerticalCylinder,
              fillColor={192,192,192}),
            Rectangle(
              extent={{-22,-56},{22,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.VerticalCylinder,
              fillColor={0,127,255}),
            Polygon(
                  points={{0,0},{60,-76},{-60,-76},{0,0}},
                  lineColor={0,0,0},
                  fillColor=DynamicSelect({0,0,0}, (1-y)*{255,255,255}),
                  fillPattern=FillPattern.Solid),
            Line(
              visible=use_inputFilter,
              points={{-30,40},{30,40}}),
                    Line(
              points={{0,40},{0,0}}),
            Line(
              visible=not use_inputFilter,
              points={{0,100},{0,40}})}),
            Documentation(info="<html>
<p>
Partial model of a three way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage
or quick opening. The three way valve model consists of a mixer where
valves are placed in two of the flow legs. The third flow leg
has no friction.
The flow coefficient <code>Kv</code> for flow from <code>port_1 &rarr; port_2</code> is
a parameter.
The flow coefficient for the bypass flow from <code>port_3 &rarr; port_2</code>
is computed as
</p>
<pre>
         Kv(port_3 &rarr; port_2)
  fraK = ----------------------
         Kv(port_1 &rarr; port_2)
</pre>
<p>
where <code>0 &lt; fraK &le; 1</code> is a parameter with a default value
of <code>fraK=0.7</code>.
</p>
<p>
Since this model uses two way valves to construct a three way valve, see
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
for details regarding the valve implementation.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 3, 2023, by Michael Wetter:<br/>
Removed start value for <code>dp</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3231\">Buildings, #3231</a>.
</li>
<li>
November 16, 2022, by Michael Wetter:<br/>
Propagated parameter <code>riseTime</code> to valves. The value is not used as the filter is disabled,
but it will show in the result file. Having a consistent value for all these parameters in the result filter
helps during debugging.
</li>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
November 5, 2019, by Michael Wetter:<br/>
Moved assignment of leakage from <a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>
to the parent classes.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1227\">#1227</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
December 17, 2015, by Michael Wetter:<br/>
Removed assignment <code>redeclare final package Medium=Medium</code>
as this is now done in the base class.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/475\">
https://github.com/lbl-srg/modelica-buildings/issues/475</a>.
</li>
<li>
November 23, 2015 by Filip Jorissen:<br/>
Corrected valve leakage value to avoid warnings.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters.
Removed default value for <code>dpValve_nominal</code>, as this
parameter has the attribute <code>fixed=false</code> for some values
of <code>CvData</code>. In this case, assigning a value is not allowed.
Corrected wrong documentation of parameter <code>fraK(min=0, max=1) = 0.7</code>.
The documenation was
<i>Fraction Kv(port_1&rarr;port_2)/Kv(port_3&rarr;port_2)</i> instead of
<i>Fraction Kv(port_3&rarr;port_2)/Kv(port_1&rarr;port_2)</i>.
Because the parameter set correctly its attributes <code>min=0</code> and <code>max=1</code>,
instances of this model used the correct value.
</li>
<li>
April 12, 2012 by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal=0</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialThreeWayValve;

        partial model PartialTwoWayValve "Partial model for a two way valve"

          extends Buildings.Fluid.BaseClasses.PartialResistance(
               final dp_nominal=dpValve_nominal + dpFixed_nominal,
               dp(nominal=6000),
               final m_flow_turbulent = deltaM * abs(m_flow_nominal));

          extends Buildings.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default));

          extends Buildings.Fluid.Actuators.BaseClasses.ActuatorSignal;
          parameter Modelica.Units.SI.PressureDifference dpFixed_nominal(
            displayUnit="Pa",
            min=0) = 0 "Pressure drop of pipe and other resistances that are in series"
            annotation (Dialog(group="Nominal condition"));

          parameter Real l(min=1e-10, max=1) = 0.0001
            "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real phi
            "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)";
          parameter Real kFixed(unit="", min=0) = if dpFixed_nominal > Modelica.Constants.eps
            then m_flow_nominal / sqrt(dpFixed_nominal) else 0
            "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real kVal(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real k(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
        initial equation
          assert(dpFixed_nominal > -Modelica.Constants.eps, "In " + getInstanceName() +
          ": Model requires dpFixed_nominal >= 0 but received dpFixed_nominal = "
                + String(dpFixed_nominal) + " Pa.");
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),       graphics={Rectangle(
              extent={{-60,40},{60,-40}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{0,0},{-76,60},{-76,-60},{0,0}},
              lineColor={0,0,0},
              fillColor=DynamicSelect({0,0,0}, y*{255,255,255}),
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{0,-0},{76,60},{76,-60},{0,0}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              visible=use_inputFilter,
              points={{-30,40},{30,40}}),
            Line(
              points={{0,40},{0,0}}),
            Line(
              visible=not use_inputFilter,
              points={{0,100},{0,40}})}),
        Documentation(info="<html>
<p>
Partial model for a two way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage,
quick opening or pressure-independent.
</p>
<p>
To prevent the derivative <code>d/dP (m_flow)</code> to be infinite near
the origin, this model linearizes the pressure drop versus flow relation
ship. The region in which it is linearized is parameterized by
</p>
<pre>
  m_turbulent_flow = deltaM * m_flow_nominal
</pre>
<p>
Because the parameterization contains <code>Kv_SI</code>, the values for
<code>deltaM</code> and <code>dp_nominal</code> need not be changed if the valve size
changes.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
</p>
<h4>Options</h4>
<p>
This model allows different parameterization of the flow resistance.
The different parameterizations are described in
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.ValveParameters\">
Buildings.Fluid.Actuators.BaseClasses.ValveParameters</a>.
</p>
<h4>Implementation</h4>
<p>
The two way valve models are implemented using this partial model, as opposed to using
different functions for the valve opening characteristics, because
each valve opening characteristics has different parameters.
</p>
</html>",
        revisions="<html>
<ul>

<li>
April 2, 2020, by Filip Jorissen:<br/>
Added model name in assert message.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1334\">#1334</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating stage.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
November 9, 2019, by Filip Jorissen:<br/>
Removed assert for <code>phi>-0.2</code>
since the valve control input is now lower limited
to zero.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1223\">
issue 1223</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
November 16, 2017, by Michael Wetter:<br/>
Relaxed assertion on <code>phi</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/592\">#592</a>.
</li>
<li>
October 27, 2016, by Filip Jorissen:<br/>
Added assert for <code>phi &gt; 0</code>.
This fixes a bug that caused valves to behave
like pumps for negative control signals.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/558\">#558</a>.
</li>
<li>
April 23, 2016, by Michael Wetter:<br/>
Changed test in assertion from <code>dpFixed_nominal > -Modelica.Constants.small</code>
to
<code>dpFixed_nominal > -Modelica.Constants.eps</code>.
Otherwise, JModelica evaluates it as <code>true</code> in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.Examples.TwoWayValves\">
Buildings.Fluid.Actuators.Valves.Examples.TwoWayValves</a>.
See also
<a href=\"https://trac.jmodelica.org/ticket/4932\">https://trac.jmodelica.org/ticket/4932</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/510\">Buildings, issue 510</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
January 29, 2015, by Filip Jorissen:<br/>
Moved the governing equations to
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValveKv\">
PartialTwoWayValveKv</a>
in order to be able to extend from this partial in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.TwoWayPressureIndependent\">
TwoWayPressureIndependent</a>
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Reformulated the computation of <code>k</code> to make the model
work in OpenModelica.
</li>
<li>
April 4, 2014, by Michael Wetter:<br/>
Added keyword <code>input</code> to variable <code>phi</code>
to require models that extend this model to provide a binding equation.
This is done to use the same modeling concept as is used for example in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Set <code>dp(nominal=6000)</code> as the previous formulation gives an error during model check
in Dymola 2014. The reason is that the previous formulation used <code>dpValve_nominal</code>, which
is not known at translation time.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters.
Removed default value for <code>dpValve_nominal</code>, as this
parameter has the attribute <code>fixed=false</code> for some values
of <code>CvData</code>. In this case, assigning a value is not allowed.
Changed assignment of nominal attribute of <code>dp</code> to avoid assigning
a non-literal value.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 12, 2011 by Michael Wetter:<br/>
Added <code>assert</code> statement to prevent <code>l=0</code> due to the
implementation of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>.
</li>
<li>
April 4, 2011 by Michael Wetter:<br/>
Revised implementation to use new base class for actuators.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
Implemented parameterization of flow coefficient as in
<code>Modelica.Fluid</code>.
</li>
<li>
August 15, 2008 by Michael Wetter:<br/>
Set valve leakage to nonzero value.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValve;

        partial model PartialTwoWayValveKv
          "Partial model for a two way valve using a Kv characteristic"
          extends Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve;

        equation
         kVal = phi*Kv_SI;
         if (dpFixed_nominal > Modelica.Constants.eps) then
           k = sqrt(1/(1/kFixed^2 + 1/kVal^2));
         else
           k = kVal;
         end if;

         if linearized then
           // This implementation yields m_flow_nominal = phi*kv_SI * sqrt(dp_nominal)
           // if m_flow = m_flow_nominal and dp = dp_nominal
           m_flow*m_flow_nominal_pos = k^2 * dp;
         else
           if homotopyInitialization then
             if from_dp then
                 m_flow=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                 dp=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
             end if;
           else // do not use homotopy
             if from_dp then
               m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                        m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                        m_flow_turbulent=m_flow_turbulent);
              end if;
            end if; // homotopyInitialization
         end if; // linearized
          annotation (
        Documentation(info="<html>
<p>
Partial model for valves with different opening characteristics,
such as linear, equal percentage or quick opening. This partial extends from
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
and also contains the governing equations for these three two way valve models.
</p>
<h4>Implementation</h4>
<p>
Models that extend this model need to provide a binding equation
for the flow function <code>phi</code>.
An example of such a code can be found in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.TwoWayLinear\">
Buildings.Fluid.Actuators.Valves.TwoWayLinear</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Removed icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
January 29, 2015 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValveKv;

        partial model ValveParameters "Model with parameters for valves"

          parameter Buildings.Fluid.Types.CvTypes CvData=Buildings.Fluid.Types.CvTypes.OpPoint
            "Selection of flow coefficient"
           annotation(Dialog(group = "Flow Coefficient"));
          parameter Real Kv(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Kv then true else false)
            "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.Kv)));
          parameter Real Cv(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Cv then true else false)
            "Cv (US) flow coefficient [USG/min/(psi)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.Cv)));
          parameter Modelica.Units.SI.Area Av(fixed=if CvData == Buildings.Fluid.Types.CvTypes.Av
                 then true else false) "Av (metric) flow coefficient" annotation (
              Dialog(group="Flow Coefficient", enable=(CvData == Buildings.Fluid.Types.CvTypes.Av)));

          parameter Real deltaM = 0.02
            "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));
          parameter Modelica.Units.SI.MassFlowRate m_flow_nominal
            "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
          parameter Modelica.Units.SI.PressureDifference dpValve_nominal(
            displayUnit="Pa",
            min=0,
            fixed=if CvData == Buildings.Fluid.Types.CvTypes.OpPoint then true else false)
            "Nominal pressure drop of fully open valve, used if CvData=Buildings.Fluid.Types.CvTypes.OpPoint"
            annotation (Dialog(group="Nominal condition", enable=(CvData == Buildings.Fluid.Types.CvTypes.OpPoint)));

          parameter Modelica.Units.SI.Density rhoStd
            "Inlet density for which valve coefficients are defined"
            annotation (Dialog(group="Nominal condition", tab="Advanced"));

      protected
          parameter Real Kv_SI(
            min=0,
            fixed= false)
            "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.OpPoint)));
        initial equation
          if  CvData == Buildings.Fluid.Types.CvTypes.OpPoint then
            Kv_SI =           m_flow_nominal/sqrt(dpValve_nominal);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
          elseif CvData == Buildings.Fluid.Types.CvTypes.Kv then
            Kv_SI =           Kv*rhoStd/3600/sqrt(1E5)
              "Unit conversion m3/(h*sqrt(bar)) to kg/(s*sqrt(Pa))";
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          elseif CvData == Buildings.Fluid.Types.CvTypes.Cv then
            Kv_SI =           Cv*rhoStd*0.0631/1000/sqrt(6895)
              "Unit conversion USG/(min*sqrt(psi)) to kg/(s*sqrt(Pa))";
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          else
            assert(CvData == Buildings.Fluid.Types.CvTypes.Av, "Invalid value for CvData.
Obtained CvData = "         + String(CvData) + ".");
            Kv_SI =           Av*sqrt(rhoStd);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          end if;

          annotation (Documentation(info="<html>
<p>
Model that computes the flow coefficients of valves. This base class allows the following modeling options,
which have been adapted from the valve implementation
in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
to specify the valve flow coefficient in fully open conditions:
</p>
<ul>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Av</code>: the flow coefficient is given by the metric <code>Av</code> coefficient (m^2).</li>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Kv</code>: the flow coefficient is given by the metric <code>Kv</code> coefficient (m^3/h).</li>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Cv</code>: the flow coefficient is given by the US <code>Cv</code> coefficient (USG/min).</li>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.OpPoint</code>: the flow is computed from the nominal operating point specified by <code>dp_nominal</code> and <code>m_flow_nominal</code>.</li>
</ul>
<p>
The treatment of parameters <code>Kv</code> and <code>Cv</code> is
explained in detail in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">Users Guide</a>.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the protected parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
The value of <code>Kv_SI</code> is computed based on the parameters
<code>Av</code>,
<code>Kv</code>,
<code>Cv</code>, or, if
<code>CvData = Buildings.Fluid.Types.CvTypes.OpPoint</code>, based on
<code>m_flow_nominal</code> and <code>dpValve_nominal</code>.
Conversely, if
<code>CvData &lt;&gt; Buildings.Fluid.Types.CvTypes.OpPoint</code>, then
<code>dpValve_nominal</code> is computed based on
<code>Av</code>,
<code>Kv</code>, or
<code>Cv</code>, and the nominal mass flow rate <code>m_flow_nominal</code>.
Therefore, if
<code>CvData &lt;&gt; Buildings.Fluid.Types.CvTypes.OpPoint</code>,
then specifying a value for <code>dpValve_nominal</code> is a syntax error.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 12, 2014, by Michael Wetter:<br/>
Changed attribute <code>min</code> of <code>dpValve_nominal</code>
to <code>0</code>.
This is needed as for example in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.Examples.TwoWayValveTable\">
Buildings.Fluid.Actuators.Valves.Examples.TwoWayValveTable</a>,
<code>dpValve_nominal=0</code>.
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Changed the <code>initial algorithm</code> to an <code>initial equation</code>
section. Otherwise, OpenModelica attempts to solve for the parameter
values using numerical iteration, and fails in doing so.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 25, 2013, by Michael Wetter:<br/>
Removed stray backslash in write statement.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters, and removed <code>Kv_SI</code> as
a public parameter because it is always computed based on other parameters.
This change avoids a translation error in Dymola 2014 beta1 in
the pedantic mode, and a translation warning otherwise.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ValveParameters;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Actuators\">Buildings.Fluid.Actuators</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models for actuators.
</html>"));
    end Actuators;

    package Chillers "Package with chiller models"
      extends Modelica.Icons.VariantsPackage;

      model ElectricEIR "Electric chiller based on the DOE-2.1 model"
        extends Buildings.Fluid.Chillers.BaseClasses.PartialElectric(
        final QEva_flow_nominal = per.QEva_flow_nominal,
        final COP_nominal= per.COP_nominal,
        final PLRMax= per.PLRMax,
        final PLRMinUnl= per.PLRMinUnl,
        final PLRMin= per.PLRMin,
        final etaMotor= per.etaMotor,
        final mEva_flow_nominal= per.mEva_flow_nominal,
        final mCon_flow_nominal= per.mCon_flow_nominal,
        final TEvaLvg_nominal= per.TEvaLvg_nominal);

        parameter Buildings.Fluid.Chillers.Data.ElectricEIR.Generic per
          "Performance data"
          annotation (choicesAllMatching = true,
                      Placement(transformation(extent={{40,80},{60,100}})));

    protected
        final parameter Modelica.Units.NonSI.Temperature_degC TConEnt_nominal_degC=
            Modelica.Units.Conversions.to_degC(per.TConEnt_nominal)
          "Temperature of fluid entering condenser at nominal condition";

        Modelica.Units.NonSI.Temperature_degC TConEnt_degC
          "Temperature of fluid entering condenser";
      initial equation
        // Verify correctness of performance curves, and write warning if error is bigger than 10%
        Buildings.Fluid.Chillers.BaseClasses.warnIfPerformanceOutOfBounds(
           Buildings.Utilities.Math.Functions.biquadratic(a=per.capFunT,
           x1=TEvaLvg_nominal_degC, x2=TConEnt_nominal_degC),
           "Capacity as function of temperature ",
           "per.capFunT");
      equation
        TConEnt_degC=Modelica.Units.Conversions.to_degC(TConEnt);

        if on then
          // Compute the chiller capacity fraction, using a biquadratic curve.
          // Since the regression for capacity can have negative values (for unreasonable temperatures),
          // we constrain its return value to be non-negative. This prevents the solver to pick the
          // unrealistic solution.
          capFunT = Buildings.Utilities.Math.Functions.smoothMax(
             x1 = 1E-6,
             x2 = Buildings.Utilities.Math.Functions.biquadratic(a=per.capFunT, x1=TEvaLvg_degC, x2=TConEnt_degC),
             deltaX = 1E-7);
      /*    assert(capFunT > 0.1, "Error: Received capFunT = " + String(capFunT)  + ".\n"
           + "Coefficient for polynomial seem to be not valid for the encountered temperature range.\n"
           + "Temperatures are TConEnt_degC = " + String(TConEnt_degC) + " degC\n"
           + "                 TEvaLvg_degC = " + String(TEvaLvg_degC) + " degC");
*/
          // Chiller energy input ratio biquadratic curve.
          EIRFunT = Buildings.Utilities.Math.Functions.biquadratic(a=per.EIRFunT, x1=TEvaLvg_degC, x2=TConEnt_degC);
          // Chiller energy input ratio quadratic curve
          EIRFunPLR   = per.EIRFunPLR[1]+per.EIRFunPLR[2]*PLR2+per.EIRFunPLR[3]*PLR2^2;
        else
          capFunT   = 0;
          EIRFunT   = 0;
          EIRFunPLR = 0;
        end if;

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}),
                         graphics={
              Rectangle(
                extent={{-99,-54},{102,-66}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-66},{0,-54}},
                lineColor={0,0,127},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-104,66},{98,54}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-2,54},{98,66}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-44,52},{-40,12}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-56,70},{58,52}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-42,2},{-52,12},{-32,12},{-42,2}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-42,2},{-52,-10},{-32,-10},{-42,2}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-44,-10},{-40,-50}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{38,52},{42,-50}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-56,-50},{58,-68}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{18,24},{62,-18}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{40,24},{22,-8},{58,-8},{40,24}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
      defaultComponentName="chi",
      Documentation(info="<html>
<p>
Model of an electric chiller, based on the DOE-2.1 chiller model and
the EnergyPlus chiller model <code>Chiller:Electric:EIR</code>.
</p>
<p> This model uses three functions to predict capacity and power consumption:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<thead>
  <tr>
    <th rowspan=\"2\">Function</th>
    <th rowspan=\"2\">Description</th>
    <th colspan=\"2\">Formulation</th>
  </tr>
  <tr>
  <th><code><a href=\"Modelica://Buildings.Fluid.Chillers.ElectricEIR\">ElectricEIR</a></code> (this model)</th>
    <th><code><a href=\"Modelica://Buildings.Fluid.Chillers.ElectricReformulatedEIR\">ElectricReformulatedEIR</a></code></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><code>capFunT</code></td>
    <td>Adjusts cooling capacity for current fluid temperatures</td>
    <td>Biquadratic on <code>TConEnt</code> and <code>TEvaLvg</code></td>
    <td>Biquadratic on <code>TConLvg</code> and <code>TEvaLvg</code></td>
  </tr>
  <tr>
    <td><code>EIRFunPLR</code></td>
    <td>Adjusts EIR for the current PLR</td>
    <td>Quadratic on PLR</td>
    <td>Bicubic on <code>TConLvg</code> and PLR</td>
  </tr>
  <tr>
    <td><code>EIRFunT</code></td>
    <td>Adjusts EIR for current fluid temperatures</td>
    <td>Biquadratic on <code>TConEnt</code> and <code>TEvaLvg</code></td>
    <td>Biquadratic on <code>TConLvg</code> and <code>TEvaLvg</code></td>
  </tr>
</tbody>
</table>
<p>
These functions take the same form as documented in
<a href=\"https://energyplus.net/assets/nrel_custom/pdfs/pdfs_v22.1.0/EngineeringReference.pdf\">
EnergyPlus v22.1.0 Engineering Reference</a>
section 14.3.9.2 (equations 14.231 through 14.233).
These curves are stored in the data record <code>per</code> and are available from
<a href=\"modelica://Buildings.Fluid.Chillers.Data.ElectricEIR\">
Buildings.Fluid.Chillers.Data.ElectricEIR</a>.
How they are used to compute the adjusted capacity and compressor power
can be found in the documentation of
<a href=\"modelica://Buildings.Fluid.Chillers.BaseClasses.PartialElectric\">
Buildings.Fluid.Chillers.BaseClasses.PartialElectric</a>.
Additional performance curves can be developed using
two available techniques (Hydeman and Gillespie, 2002). The first technique is called the
Least-squares Linear Regression method and is used when sufficient performance data exist
to employ standard least-square linear regression techniques. The second technique is called
Reference Curve Method and is used when insufficient performance data exist to apply linear
regression techniques. A detailed description of both techniques can be found in
Hydeman and Gillespie (2002).
</p>
<p>
The model takes as an input the set point for the leaving chilled water temperature,
which is met if the chiller has sufficient capacity.
Thus, the model has a built-in, ideal temperature control.
The model has three tests on the part load ratio and the cycling ratio:
</p>
<ol>
<li>
The test<pre>
  PLR1 =min(QEva_flow_set/QEva_flow_ava, per.PLRMax);
</pre>
ensures that the chiller capacity does not exceed the chiller capacity specified
by the parameter <code>per.PLRMax</code>.
</li>
<li>
The test <pre>
  CR = min(PLR1/per.PRLMin, 1.0);
</pre>
computes a cycling ratio. This ratio expresses the fraction of time
that a chiller would run if it were to cycle because its load is smaller than the
minimal load at which it can operate.
Note that this model continuously operates even if the part load ratio is below the minimum part load ratio.
Its leaving evaporator and condenser temperature can therefore be considered as an
average temperature between the modes where the compressor is off and on.
</li>
<li>
The test <pre>
  PLR2 = max(per.PLRMinUnl, PLR1);
</pre>
computes the part load ratio of the compressor.
The assumption is that for a part load ratio below <code>per.PLRMinUnl</code>,
the chiller uses hot gas bypass to reduce the capacity, while the compressor
power draw does not change.
</li>
</ol>
<p>
The electric power only contains the power for the compressor, but not any power for pumps or fans.
</p>
<p>
The model can be parametrized to compute a transient
or steady-state response.
The transient response of the chiller is computed using a first
order differential equation for the evaporator and condenser fluid volumes.
The chiller outlet temperatures are equal to the temperatures of these lumped volumes.
</p>
<p>
Optionally, the model can be configured to represent heat recovery chillers with
a switchover option by setting the parameter <code>have_switchover</code> to
<code>true</code>.
In that case an additional Boolean input connector <code>coo</code> is used.
The chiller is tracking a chilled water supply temperature setpoint at the
outlet of the evaporator barrel if <code>coo</code> is <code>true</code>.
Otherwise, if <code>coo</code> is <code>false</code>, the chiller is tracking
a hot water supply temperature setpoint at the outlet of the condenser barrel.
See
<a href=\"modelica://Buildings.Fluid.Chillers.Examples.ElectricEIR_HeatRecovery\">
Buildings.Fluid.Chillers.Examples.ElectricEIR_HeatRecovery</a>
for an example with a chiller operating in heating mode.
</p>
<h4>References</h4>
<ul>
<li>
Hydeman, M. and K.L. Gillespie. 2002. Tools and Techniques to Calibrate Electric Chiller
Component Models. <i>ASHRAE Transactions</i>, AC-02-9-1.
</li>
<li>
<a href=\"https://energyplus.net/assets/nrel_custom/pdfs/pdfs_v22.1.0/EngineeringReference.pdf\">
EnergyPlus v22.1.0 Engineering Reference</a>
</li>
</ul>
</html>",
      revisions="<html>
<ul>
<li>
March 12, 2015, by Michael Wetter:<br/>
Refactored model to make it once continuously differentiable.
This is for issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/373\">373</a>.
</li>
<li>
Jan. 9, 2011, by Michael Wetter:<br/>
Added input signal to switch chiller off.
</li>
<li>
Sep. 8, 2010, by Michael Wetter:<br/>
Revised model and included it in the Buildings library.
</li>
<li>
October 13, 2008, by Brandon Hencey:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ElectricEIR;

      package Data "Performance data for electric chillers"
        extends Modelica.Icons.MaterialPropertiesPackage;

        package BaseClasses "Base classes for package Data"
          extends Modelica.Icons.BasesPackage;

          record Chiller "Base classes for chiller models"
            extends Modelica.Icons.Record;
            parameter Modelica.Units.SI.HeatFlowRate QEva_flow_nominal(max=0)
              "Reference capacity (negative number)"
              annotation (Dialog(group="Nominal condition"));
            parameter Real COP_nominal "Reference coefficient of performance"
              annotation (Dialog(group="Nominal condition"));

            parameter Real PLRMax(min=0) "Maximum part load ratio";
            parameter Real PLRMinUnl(min=0) "Minimum part unload ratio";
            parameter Real PLRMin(min=0) "Minimum part load ratio";

            parameter Real etaMotor(min=0, max=1)
              "Fraction of compressor motor heat entering refrigerant";

            parameter Modelica.Units.SI.MassFlowRate mEva_flow_nominal
              "Nominal mass flow at evaporator"
              annotation (Dialog(group="Nominal condition"));
            parameter Modelica.Units.SI.MassFlowRate mCon_flow_nominal
              "Nominal mass flow at condenser"
              annotation (Dialog(group="Nominal condition"));
            parameter Modelica.Units.SI.Temperature TEvaLvg_nominal
              "Temperature of fluid leaving evaporator at nominal condition"
              annotation (Dialog(group="Nominal condition"));

            constant Integer nCapFunT "Number of coefficients for capFunT"
              annotation (Dialog(group="Performance curves"));
            constant Integer nEIRFunT "Number of coefficients for EIRFunT"
              annotation (Dialog(group="Performance curves"));
            constant Integer nEIRFunPLR "Number of coefficients for EIRFunPLR"
              annotation (Dialog(group="Performance curves"));
            parameter Real capFunT[nCapFunT] "Biquadratic coefficients for capFunT"
              annotation (Dialog(group="Performance curves"));
            parameter Real EIRFunT[nEIRFunT] "Biquadratic coefficients for EIRFunT"
              annotation (Dialog(group="Performance curves"));
            parameter Real EIRFunPLR[nEIRFunPLR] "Coefficients for EIRFunPLR"
              annotation (Dialog(group="Performance curves"));
            parameter Modelica.Units.SI.Temperature TEvaLvgMin
              "Minimum value for leaving evaporator temperature"
              annotation (Dialog(group="Performance curves"));
            parameter Modelica.Units.SI.Temperature TEvaLvgMax
              "Maximum value for leaving evaporator temperature"
              annotation (Dialog(group="Performance curves"));

            annotation (preferredView="info",
            Documentation(info="<html>
<p>
This is the base record for chiller models.
</p>
</html>", revisions="<html>
<ul>
<li>
July 27, 2016, by Michael Wetter:<br/>
Corrected wrong documentation for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/545\">issue 545</a>.
</li>
<li>
September 15, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Text(
                    extent={{-95,53},{-12,-2}},
                    textColor={0,0,255},
                    textString="COP"),
                  Text(
                    extent={{7,55},{90,0}},
                    textColor={0,0,255},
                    textString="%COP_nominal"),
                  Text(
                    extent={{-105,-9},{-48,-48}},
                    textColor={0,0,255},
                    textString="Q"),
                  Text(
                    extent={{2,-16},{94,-38}},
                    textColor={0,0,255},
                    textString="%QEva_flow_nominal"),
                  Text(
                    extent={{-95,-49},{-12,-104}},
                    textColor={0,0,255},
                    textString="PLR_minUnl"),
                  Text(
                    extent={{7,-53},{84,-94}},
                    textColor={0,0,255},
                    textString="%PLRMinUnl")}));
          end Chiller;
          annotation(preferredView="info",
          Documentation(info="<html>
This package contains the common parameters that are used
to specify the performance data
for the chiller models
<a href=\"modelica://Buildings.Fluid.Chillers.ElectricEIR\">
Buildings.Fluid.Chillers.ElectricEIR</a>
and
<a href=\"modelica://Buildings.Fluid.Chillers.ElectricReformulatedEIR\">
Buildings.Fluid.Chillers.ElectricReformulatedEIR</a>.
</html>",         revisions="<html>
<ul>
<li>
September 17, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end BaseClasses;

        package ElectricEIR "Performance data for chiller ElectricEIR"
          extends Modelica.Icons.MaterialPropertiesPackage;

          record Generic "Generic data record for chiller ElectricEIR"
            extends Buildings.Fluid.Chillers.Data.BaseClasses.Chiller(
                final nCapFunT=6,
                final nEIRFunT=6,
                final nEIRFunPLR=3);
            parameter Modelica.Units.SI.Temperature TConEnt_nominal
              "Temperature of fluid entering condenser at nominal condition"
              annotation (Dialog(group="Nominal condition"));

            parameter Modelica.Units.SI.Temperature TConEntMin
              "Minimum value for entering condenser temperature"
              annotation (Dialog(group="Performance curves"));
            parameter Modelica.Units.SI.Temperature TConEntMax
              "Maximum value for entering condenser temperature"
              annotation (Dialog(group="Performance curves"));

            annotation (
              defaultComponentName="datChi",
              defaultComponentPrefixes="parameter",
              Documentation(info=
                           "<html>
<p>This record is used as a template for performance data
for the chiller model
<a href=\"modelica://Buildings.Fluid.Chillers.ElectricEIR\">
Buildings.Fluid.Chillers.ElectricEIR</a>.
To provide performance data for
<a href=\"modelica://Buildings.Fluid.Chillers.ElectricReformulatedEIR\">
Buildings.Fluid.Chillers.ElectricReformulatedEIR</a>, use
<a href=\"modelica://Buildings.Fluid.Chillers.Data.ElectricReformulatedEIR.Generic\">
Buildings.Fluid.Chillers.Data.ElectricReformulatedEIR.Generic</a> instead.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 19, 2014 by Michael Wetter:<br/>
Added <code>defaultComponentName</code> and <code>defaultComponentPrefixes</code>.
</li><li>
September 17, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end Generic;

          record ElectricEIRChiller_McQuay_WSC_471kW_5_89COP_Vanes =
            Buildings.Fluid.Chillers.Data.ElectricEIR.Generic (
              QEva_flow_nominal =  -471200,
              COP_nominal =         5.89,
              PLRMin =              0.10,
              PLRMinUnl =           0.10,
              PLRMax =              1.15,
              mEva_flow_nominal =   1000 * 0.01035,
              mCon_flow_nominal =   1000 * 0.01924,
              TEvaLvg_nominal =     273.15 + 8.89,
              TConEnt_nominal =     273.15 + 26.67,
              TEvaLvgMin =          273.15 + 7.22,
              TEvaLvgMax =          273.15 + 12.78,
              TConEntMin =          273.15 + 12.78,
              TConEntMax =          273.15 + 26.67,
              capFunT =             {2.521130E-01,1.324053E-02,-8.637329E-03,8.581056E-02,-4.261176E-03,8.661899E-03},
              EIRFunT =             {4.475238E-01,-2.588210E-02,-1.459053E-03,4.342595E-02,-1.000651E-03,1.920106E-03},
              EIRFunPLR =           {2.778889E-01,2.338363E-01,4.883748E-01},
              etaMotor =            1.0)
            "ElectricEIRChiller McQuay WSC 471kW/5.89COP/Vanes" annotation (
            defaultComponentName="datChi",
            defaultComponentPrefixes="parameter",
            Documentation(info=
                           "<html>
Performance data for chiller model.
This data corresponds to the following EnergyPlus model:
<pre>
Chiller:Electric:EIR,
    ElectricEIRChiller McQuay WSC 471kW/5.89COP/Vanes,  !- Name
    471200,                  !- Reference Capacity {W}
    5.89,                    !- Reference COP {W/W}
    8.89,                    !- Reference Leaving Chilled Water Temperature {C}
    26.67,                   !- Reference Entering Condenser Fluid Temperature {C}
    0.01035,                 !- Reference Chilled Water Flow Rate {m3/s}
    0.01924,                 !- Reference Condenser Water Flow Rate {m3/s}
    ElectricEIRChiller McQuay WSC 471kW/5.89COP/Vanes CAPFT,  !- Cooling Capacity Function of Temperature Curve Name
    ElectricEIRChiller McQuay WSC 471kW/5.89COP/Vanes EIRFT,  !- Electric Input to Cooling Output Ratio Function of Temperature Curve Name
    ElectricEIRChiller McQuay WSC 471kW/5.89COP/Vanes EIRFPLR,  !- Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name
    0.10,                    !- Minimum Part Load Ratio
    1.15,                    !- Maximum Part Load Ratio
    1.0,                     !- Optimum Part Load Ratio
    0.10,                    !- Minimum Unloading Ratio
    Chilled Water Side Inlet Node,  !- Chilled Water Inlet Node Name
    Chilled Water Side Outlet Node,  !- Chilled Water Outlet Node Name
    Condenser Side Inlet Node,  !- Condenser Inlet Node Name
    Condenser Side Outlet Node,  !- Condenser Outlet Node Name
    WaterCooled,             !- Condenser Type
    ,                        !- Condenser Fan Power Ratio {W/W}
    1.0,                     !- Compressor Motor Efficiency
    2.0,                     !- Leaving Chilled Water Lower Temperature Limit {C}
    ConstantFlow,            !- Chiller Flow Mode
    0.0;                     !- Design Heat Recovery Water Flow Rate {m3/s}
</pre>
</html>"));

          record ElectricEIRChiller_York_YT_563kW_10_61COP_Vanes =
            Buildings.Fluid.Chillers.Data.ElectricEIR.Generic (
              QEva_flow_nominal =  -562600,
              COP_nominal =         10.61,
              PLRMin =              0.09,
              PLRMinUnl =           0.09,
              PLRMax =              1.03,
              mEva_flow_nominal =   1000 * 0.01514,
              mCon_flow_nominal =   1000 * 0.0241,
              TEvaLvg_nominal =     273.15 + 6.11,
              TConEnt_nominal =     273.15 + 12.78,
              TEvaLvgMin =          273.15 + 6.11,
              TEvaLvgMax =          273.15 + 12.78,
              TConEntMin =          273.15 + 12.78,
              TConEntMax =          273.15 + 23.89,
              capFunT =             {-1.288612E-01,-8.919540E-02,-2.190195E-03,1.538357E-01,-5.129402E-03,7.813636E-03},
              EIRFunT =             {-5.781003E-01,-1.169130E-01,-4.760535E-03,2.230082E-01,-5.313649E-03,6.846644E-03},
              EIRFunPLR =           {5.203969E-01,-7.775900E-01,1.255394E+00},
              etaMotor =            1.0)
            "ElectricEIRChiller York YT 563kW/10.61COP/Vanes" annotation (
            defaultComponentName="datChi",
            defaultComponentPrefixes="parameter",
            Documentation(info=
                           "<html>
Performance data for chiller model.
This data corresponds to the following EnergyPlus model:
<pre>
Chiller:Electric:EIR,
    ElectricEIRChiller York YT 563kW/10.61COP/Vanes,  !- Name
    562600,                  !- Reference Capacity {W}
    10.61,                   !- Reference COP {W/W}
    6.11,                    !- Reference Leaving Chilled Water Temperature {C}
    12.78,                   !- Reference Entering Condenser Fluid Temperature {C}
    0.01514,                 !- Reference Chilled Water Flow Rate {m3/s}
    0.0241,                  !- Reference Condenser Water Flow Rate {m3/s}
    ElectricEIRChiller York YT 563kW/10.61COP/Vanes CAPFT,  !- Cooling Capacity Function of Temperature Curve Name
    ElectricEIRChiller York YT 563kW/10.61COP/Vanes EIRFT,  !- Electric Input to Cooling Output Ratio Function of Temperature Curve Name
    ElectricEIRChiller York YT 563kW/10.61COP/Vanes EIRFPLR,  !- Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name
    0.09,                    !- Minimum Part Load Ratio
    1.03,                    !- Maximum Part Load Ratio
    1.0,                     !- Optimum Part Load Ratio
    0.09,                    !- Minimum Unloading Ratio
    Chilled Water Side Inlet Node,  !- Chilled Water Inlet Node Name
    Chilled Water Side Outlet Node,  !- Chilled Water Outlet Node Name
    Condenser Side Inlet Node,  !- Condenser Inlet Node Name
    Condenser Side Outlet Node,  !- Condenser Outlet Node Name
    WaterCooled,             !- Condenser Type
    ,                        !- Condenser Fan Power Ratio {W/W}
    1.0,                     !- Compressor Motor Efficiency
    2.0,                     !- Leaving Chilled Water Lower Temperature Limit {C}
    ConstantFlow,            !- Chiller Flow Mode
    0.0;                     !- Design Heat Recovery Water Flow Rate {m3/s}
</pre>
</html>"));
        annotation(preferredView="info",
         Documentation(info="<html>
<p>
Package with performance data for chillers.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 19, 2021 by David Blum:<br/>
Added air-cooled chiller YCAL0033EE.
</li>
<li>
April 25, 2016 by Thierry Nouidui:<br/>
Generated.
</li>
</ul>
</html>"));
        end ElectricEIR;
        annotation (preferredView="info", Documentation(info="<html>
Package with performance data for chillers.
</html>"));
      end Data;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Chillers"
        extends Modelica.Icons.BasesPackage;

        partial model PartialElectric
          "Partial model for electric chiller based on the model in DOE-2, CoolTools and EnergyPlus"
          extends Buildings.Fluid.Interfaces.FourPortHeatMassExchanger(
           m1_flow_nominal = mCon_flow_nominal,
           m2_flow_nominal = mEva_flow_nominal,
           T1_start = 273.15+25,
           T2_start = 273.15+5,
           redeclare final Buildings.Fluid.MixingVolumes.MixingVolume vol2(
              V=m2_flow_nominal*tau2/rho2_nominal,
              nPorts=2,
              final prescribedHeatFlowRate=true),
            vol1(
              final prescribedHeatFlowRate=true));

          parameter Boolean have_switchover=false
            "Set to true for heat recovery chiller with built-in switchover"
            annotation(Evaluate=true);

          Modelica.Blocks.Interfaces.BooleanInput on
            "Set to true to enable compressor, or false to disable compressor"
            annotation (Placement(transformation(extent={{-140,10},{-100,50}}),
                iconTransformation(extent={{-140,10},{-100,50}})));
          Modelica.Blocks.Interfaces.RealInput TSet(unit="K", displayUnit="degC")
            "Set point for leaving chilled water temperature (condenser water if have_switchover=true and coo=false)"
            annotation (Placement(transformation(extent={{-140,-50},{-100,-10}}),
                iconTransformation(extent={{-140,-50},{-100,-10}})));
          Modelica.Blocks.Interfaces.RealOutput P(final quantity="Power", unit="W")
            "Electric power consumed by compressor"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));
          Modelica.Blocks.Interfaces.RealOutput COP_h(final unit="1") if have_switchover
            "Coefficient of performance of heating";

          Modelica.Units.SI.Temperature TEvaEnt "Evaporator entering temperature";
          Modelica.Units.SI.Temperature TEvaLvg "Evaporator leaving temperature";
          Modelica.Units.SI.Temperature TConEnt "Condenser entering temperature";
          Modelica.Units.SI.Temperature TConLvg "Condenser leaving temperature";

          Modelica.Units.SI.Efficiency COP "Coefficient of performance";
          Modelica.Units.SI.HeatFlowRate QCon_flow "Condenser heat input";
          Modelica.Units.SI.HeatFlowRate QEva_flow "Evaporator heat input";


          Real capFunT(min=0, unit="1")
            "Cooling capacity factor function of temperature curve";
          Modelica.Units.SI.Efficiency EIRFunT
            "Power input to cooling capacity ratio function of temperature curve";
          Modelica.Units.SI.Efficiency EIRFunPLR
            "Power input to cooling capacity ratio function of part load ratio";
          Real PLR1(min=0, unit="1", start=0) "Part load ratio";
          Real PLR2(min=0, unit="1") "Part load ratio";
          Real CR(min=0, unit="1") "Cycling ratio";

          Controls.OBC.CDL.Interfaces.BooleanInput coo if have_switchover
            "Switchover signal: true for cooling, false for heating" annotation (
              Placement(transformation(extent={{-140,-20},{-100,20}}),
                iconTransformation(
                extent={{-40,-40},{40,40}},
                rotation=-90,
                origin={-80,140})));
          Controls.OBC.CDL.Logical.Sources.Constant tru(
            final k=true) if not have_switchover
            "Constant true signal"
            annotation (Placement(transformation(extent={{-20,-10},{-40,10}})));
      protected
          Controls.OBC.CDL.Interfaces.BooleanInput coo_internal
            "Internal switchover signal: true for cooling, false for heating"
            annotation (Placement(transformation(extent={{-100,-20},{-60,20}}),
                iconTransformation(extent={{-140,-20},{-100,20}})));

          Modelica.Units.SI.HeatFlowRate QEva_flow_ava(nominal=QEva_flow_nominal, start
              =QEva_flow_nominal) "Cooling capacity available at evaporator";
          Modelica.Units.SI.HeatFlowRate QEva_flow_set(nominal=QEva_flow_nominal, start
              =QEva_flow_nominal)
            "Cooling capacity required to cool to set point temperature";
          Modelica.Units.SI.HeatFlowRate QCon_flow_set(
            nominal=-QEva_flow_nominal * (1 + 1 / COP_nominal * etaMotor),
            start=-QEva_flow_nominal * (1 + 1 / COP_nominal * etaMotor))
            "Heating capacity required to heat up condenser water to setpoint";
          Modelica.Units.SI.SpecificEnthalpy hSet
            "Enthalpy setpoint for leaving chilled water";
          // Performance data
          parameter Modelica.Units.SI.HeatFlowRate QEva_flow_nominal(max=0)
            "Reference capacity (negative number)";
          parameter Modelica.Units.SI.Efficiency COP_nominal
            "Reference coefficient of performance";
          parameter Real PLRMax(min=0, unit="1") "Maximum part load ratio";
          parameter Real PLRMinUnl(min=0, unit="1") "Minimum part unload ratio";
          parameter Real PLRMin(min=0, unit="1") "Minimum part load ratio";
          parameter Modelica.Units.SI.Efficiency etaMotor(max=1)
            "Fraction of compressor motor heat entering refrigerant";
          parameter Modelica.Units.SI.MassFlowRate mEva_flow_nominal
            "Nominal mass flow at evaporator";
          parameter Modelica.Units.SI.MassFlowRate mCon_flow_nominal
            "Nominal mass flow at condenser";
          parameter Modelica.Units.SI.Temperature TEvaLvg_nominal
            "Temperature of fluid leaving evaporator at nominal condition";
          final parameter Modelica.Units.NonSI.Temperature_degC TEvaLvg_nominal_degC=
              Modelica.Units.Conversions.to_degC(TEvaLvg_nominal)
            "Temperature of fluid leaving evaporator at nominal condition";
          Modelica.Units.NonSI.Temperature_degC TEvaLvg_degC
            "Temperature of fluid leaving evaporator";
          parameter Modelica.Units.SI.HeatFlowRate Q_flow_small=QEva_flow_nominal*1E-9
            "Small value for heat flow rate or power, used to avoid division by zero";
          Buildings.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloEva
            "Prescribed heat flow rate"
            annotation (Placement(transformation(extent={{-39,-50},{-19,-30}})));
          Buildings.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloCon
            "Prescribed heat flow rate"
            annotation (Placement(transformation(extent={{-39,30},{-19,50}})));
          Modelica.Blocks.Sources.RealExpression QEva_flow_in(y=QEva_flow)
            "Evaporator heat flow rate"
            annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
          Modelica.Blocks.Sources.RealExpression QCon_flow_in(y=QCon_flow)
            "Condenser heat flow rate"
            annotation (Placement(transformation(extent={{-80,30},{-60,50}})));
          Modelica.Blocks.Sources.RealExpression calCOPHea(
            final y=QCon_flow/(P - Q_flow_small)) if have_switchover
            "Compute heating COP"
            annotation (Placement(transformation(extent={{60,-10},{80,10}})));
        initial equation
          assert(QEva_flow_nominal < 0, "Parameter QEva_flow_nominal must be smaller than zero.");
          assert(Q_flow_small < 0, "Parameter Q_flow_small must be smaller than zero.");
          assert(PLRMinUnl >= PLRMin, "Parameter PLRMinUnl must be bigger or equal to PLRMin");
          assert(PLRMax > PLRMinUnl, "Parameter PLRMax must be bigger than PLRMinUnl");
        equation
          // Condenser temperatures
          TConEnt = Medium1.temperature(Medium1.setState_phX(port_a1.p,
                                                             inStream(port_a1.h_outflow),
                                                             inStream(port_a1.Xi_outflow)));
          TConLvg = vol1.heatPort.T;
          // Evaporator temperatures
          TEvaEnt = Medium2.temperature(Medium2.setState_phX(port_a2.p, inStream(port_a2.h_outflow)));
          TEvaLvg = vol2.heatPort.T;
          TEvaLvg_degC=Modelica.Units.Conversions.to_degC(TEvaLvg);

          // Enthalpy of temperature setpoint
          hSet =if coo_internal then Medium2.specificEnthalpy_pTX(
            p=port_b2.p,
            T=TSet,
            X=cat(
              1,
              port_b2.Xi_outflow,
              {1 - sum(port_b2.Xi_outflow)})) else Medium1.specificEnthalpy_pTX(
            p=port_b1.p,
            T=TSet,
            X=cat(
              1,
              port_b1.Xi_outflow,
              {1 - sum(port_b1.Xi_outflow)}));

          if on then
            // Available cooling capacity
            QEva_flow_ava = QEva_flow_nominal*capFunT;
            // Cooling capacity required to chill water to setpoint
            QEva_flow_set = Buildings.Utilities.Math.Functions.smoothMin(
              x1=if coo_internal then m2_flow * (hSet - inStream(port_a2.h_outflow))
                 else P * etaMotor - QCon_flow_set,
              x2=Q_flow_small,
              deltaX=-Q_flow_small/100);
            // Heating capacity required to heat up condenser water to setpoint
            QCon_flow_set = if coo_internal then QCon_flow
                            else m1_flow * (hSet - inStream(port_a1.h_outflow));
            // Part load ratio
            PLR1 = Buildings.Utilities.Math.Functions.smoothMin(
              x1 = QEva_flow_set/(QEva_flow_ava+Q_flow_small),
              x2 = PLRMax,
              deltaX=PLRMax/100);
            // PLR2 is the compressor part load ratio. The lower bound PLRMinUnl is
            // since for PLR1<PLRMinUnl, the chiller uses hot gas bypass, under which
            // condition the compressor power is assumed to be the same as if the chiller
            // were to operate at PLRMinUnl
            PLR2 = Buildings.Utilities.Math.Functions.smoothMax(
              x1 = PLRMinUnl,
              x2 = PLR1,
              deltaX = PLRMinUnl/100);

            // Cycling ratio.
            // Due to smoothing, this can be about deltaX/10 above 1.0
            CR = Buildings.Utilities.Math.Functions.smoothMin(
              x1 = PLR1/PLRMin,
              x2 = 1,
              deltaX=0.001);

            // Compressor power.
            P = -QEva_flow_ava/COP_nominal*EIRFunT*EIRFunPLR*CR;
            // Heat flow rates into evaporator and condenser
            // Q_flow_small is a negative number.
            QEva_flow = Buildings.Utilities.Math.Functions.smoothMax(
              x1 = QEva_flow_set,
              x2 = QEva_flow_ava,
              deltaX= -Q_flow_small/10);

          //QEva_flow = max(QEva_flow_set, QEva_flow_ava);
            QCon_flow = -QEva_flow + P*etaMotor;
            // Coefficient of performance
            COP = -QEva_flow/(P-Q_flow_small);
          else
            QEva_flow_ava = 0;
            QEva_flow_set = 0;
            QCon_flow_set = 0;
            PLR1 = 0;
            PLR2 = 0;
            CR   = 0;
            P    = 0;
            QEva_flow = 0;
            QCon_flow = 0;
            COP  = 0;
          end if;
          connect(calCOPHea.y, COP_h);
          connect(QCon_flow_in.y, preHeaFloCon.Q_flow) annotation (Line(
              points={{-59,40},{-39,40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(preHeaFloCon.port, vol1.heatPort) annotation (Line(
              points={{-19,40},{-10,40},{-10,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(QEva_flow_in.y, preHeaFloEva.Q_flow) annotation (Line(
              points={{-59,-40},{-39,-40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(preHeaFloEva.port, vol2.heatPort) annotation (Line(
              points={{-19,-40},{12,-40},{12,-60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(coo, coo_internal)
            annotation (Line(points={{-120,0},{-80,0}}, color={255,0,255}));
          connect(tru.y, coo_internal)
            annotation (Line(points={{-42,0},{-80,0}}, color={255,0,255}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}),
                           graphics={
                Text(extent={{62,96},{112,82}},
                  textString="P",
                  textColor={0,0,127}),
                Text(extent={{-104,-16},{-58,-28}},
                  textString="TSet",
                  textColor={0,0,127}),
                Rectangle(
                  extent={{-99,-54},{102,-66}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-100,-66},{0,-54}},
                  lineColor={0,0,127},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-104,66},{98,54}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-2,54},{98,66}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-44,52},{-40,12}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-56,70},{58,52}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-42,2},{-52,12},{-32,12},{-42,2}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-42,2},{-52,-10},{-32,-10},{-42,2}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-44,-10},{-40,-50}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{38,52},{42,-50}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-56,-50},{58,-68}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{18,24},{62,-18}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{40,24},{22,-8},{58,-8},{40,24}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(extent={{-108,36},{-62,24}},
                  textColor={0,0,127},
                  textString="on"),
                Text(extent={{-102,96},{-56,84}},
                  textColor={0,0,127},
                  visible=have_switchover,
                  textString="coo")}),
        Documentation(info="<html>
<p>
Base class for model of an electric chiller, based on the DOE-2.1 chiller model and the
CoolTools chiller model that are implemented in EnergyPlus as the models
<code>Chiller:Electric:EIR</code> and <code>Chiller:Electric:ReformulatedEIR</code>.
</p>
<p>
The model takes as an input the set point for the leaving chilled water temperature,
which is met if the chiller has sufficient capacity.
Thus, the model has a built-in, ideal temperature control.
The model has three tests on the part load ratio and the cycling ratio:
</p>
<ol>
<li>
The test
<pre>
  PLR1 =min(QEva_flow_set/QEva_flow_ava, PLRMax)
</pre>
ensures that the chiller capacity does not exceed the chiller capacity specified
by the parameter <code>PLRMax</code>.
</li>
<li>
The test <pre>
  CR = min(PLR1/per.PRLMin, 1.0)
</pre>
computes a cycling ratio. This ratio expresses the fraction of time
that a chiller would run if it were to cycle because its load is smaller than
the minimal load at which it can operature. Notice that this model does continuously operature even if
the part load ratio is below the minimum part load ratio. Its leaving evaporator and condenser temperature
can therefore be considered as an
average temperature between the modes where the compressor is off and on.
</li>
<li>
The test <pre>
  PLR2 = max(PLRMinUnl, PLR1)
</pre>
computes the part load ratio of the compressor.
The assumption is that for a part load ratio below <code>PLRMinUnl</code>,
the chiller uses hot gas bypass to reduce the capacity, while the compressor
power draw does not change.
</li>
</ol>
<p>
The electric power only contains the power for the compressor, but not any power for pumps or fans.
</p>
<p>
Optionally, the model can be configured to represent heat recovery chillers with
a switchover option by setting the parameter <code>have_switchover</code> to
<code>true</code>.
In that case an additional Boolean input connector <code>coo</code> is used.
The chiller is tracking a chilled water supply temperature setpoint at the
outlet of the evaporator barrel if <code>coo</code> is <code>true</code>.
Otherwise, if <code>coo</code> is <code>false</code>, the chiller is tracking
a hot water supply temperature setpoint at the outlet of the condenser barrel.
See
<a href=\"modelica://Buildings.Fluid.Chillers.Examples.ElectricEIR_HeatRecovery\">
Buildings.Fluid.Chillers.Examples.ElectricEIR_HeatRecovery</a>
for an example with a chiller operating in heating mode.
</p>
<h4>Implementation</h4>
<p>
This implementation computes the chiller capacity and power consumption
the same way as documented in
<a href=\"https://energyplus.net/assets/nrel_custom/pdfs/pdfs_v22.1.0/EngineeringReference.pdf\">
EnergyPlus v22.1.0 Engineering Reference</a> section 14.3.9.2.
Especially see equations 14.234 and 14.240 in the referenced document.
</p>
<p>
The available chiller capacity <code>QEva_flow_ava</code> is adjusted from
its nominal capacity <code>QEva_flow_nominal</code>
by factor <code>capFunT</code> as
</p>
<pre>  QEva_flow_ava = QEva_flow_nominal*capFunT</pre>
<p>
and the compressor power consumption is computed as
</p>
<pre>  P = -QEva_flow_ava*(1/COP_nominal)*EIRFunT*EIRFunPLR*CR.</pre>
<p>
The models that extend from this base class implement the functions used above
in ways that are shown in the table below.
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<thead>
  <tr>
    <th rowspan=\"2\">Function</th>
    <th rowspan=\"2\">Description</th>
    <th colspan=\"2\">Formulation</th>
  </tr>
  <tr>
    <th><code><a href=\"Modelica://Buildings.Fluid.Chillers.ElectricEIR\">ElectricEIR</a></code></th>
    <th><code><a href=\"Modelica://Buildings.Fluid.Chillers.ElectricReformulatedEIR\">ElectricReformulatedEIR</a></code></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><code>capFunT</code></td>
    <td>Adjusts cooling capacity for current fluid temperatures</td>
    <td>Biquadratic on <code>TConEnt</code> and <code>TEvaLvg</code></td>
    <td>Biquadratic on <code>TConLvg</code> and <code>TEvaLvg</code></td>
  </tr>
  <tr>
    <td><code>EIRFunPLR</code></td>
    <td>Adjusts EIR for the current PLR</td>
    <td>Quadratic on PLR</td>
    <td>Bicubic on <code>TConLvg</code> and PLR</td>
  </tr>
  <tr>
    <td><code>EIRFunT</code></td>
    <td>Adjusts EIR for current fluid temperatures</td>
    <td>Biquadratic on <code>TConEnt</code> and <code>TEvaLvg</code></td>
    <td>Biquadratic on <code>TConLvg</code> and <code>TEvaLvg</code></td>
  </tr>
</tbody>
</table>
<p>
where
<code>TConEnt</code> is the condenser entering temperature,
<code>TEvaLvg</code> is the evaporator leaving temperature,
<code>TConLvg</code> is the condenser leaving temperatore, and
PLR is the part load ratio.
</p>
<h4>References</h4>
<ul>
<li>
<a href=\"https://energyplus.net/assets/nrel_custom/pdfs/pdfs_v22.1.0/EngineeringReference.pdf\">
EnergyPlus v22.1.0 Engineering Reference</a>
</li>
</ul>
</html>",
        revisions="<html>
<ul>
<li>
January 11, 2023, by Antoine Gautier:<br/>
Added optional switchover mode for heat recovery chillers.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3211\">#3211</a>.
</li>
<li>
November 19, 2021, by David Blum:<br/>
Add humidity to entering condenser state calculation.<br/>
This is for issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2770\">2770</a>.
</li>
<li>
June 28, 2019, by Michael Wetter:<br/>
Removed <code>start</code> values and removed
<code>nominal=1</code> for performance curves.<br/>
This is for issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1465\">1465</a>.
</li>
<li>
March 12, 2015, by Michael Wetter:<br/>
Refactored model to make it once continuously differentiable.
This is for issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/373\">373</a>.
</li>
<li>
Jan. 10, 2011, by Michael Wetter:<br/>
Added input signal to switch chiller off, and changed base class to use a dynamic model.
The change of the base class was required to improve the robustness of the model when the control
is switched on again.
</li>
<li>
Sep. 8, 2010, by Michael Wetter:<br/>
Revised model and included it in the Buildings library.
</li>
<li>
October 13, 2008, by Brandon Hencey:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialElectric;

        impure function warnIfPerformanceOutOfBounds
          "Function that checks the performance and writes a warning if it is outside of 0.9 to 1.1"
          input Real x "Argument to be checked";
          input String msg "String to be added to warning message";
          input String curveName "Name of the curve that was tested";
          output Integer retVal
            "0 if x is inside bounds, -1 if it is below bounds, or +1 if it is above bounds";

        algorithm
          if (x > 1.1) then
            retVal :=1;
          elseif ( x < 0.9) then
              retVal :=-1;
          else
            retVal :=0;
          end if;
          if (retVal <> 0) then
            Modelica.Utilities.Streams.print(
        "*** Warning: Chiller performance curves at nominal conditions are outside of bounds.
             "         + msg + " is outside of bounds 0.9 to 1.1.
             The value of the curve fit is "         + String(x) + "
             Check the coefficients of the function "         + curveName + ".");
          end if;

        annotation (
            Documentation(info="<html>
<p>
This function checks if the numeric argument is outside of the
interval <i>0.9</i> to <i>1.1</i>.
If this is the case, the function writes a warning.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 12, 2021, by Michael Wetter:<br/>
Added <code>impure</code> keyword for MSL 4.0.0.
</li>
<li>
September 12, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end warnIfPerformanceOutOfBounds;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Chillers\">Buildings.Fluid.Chillers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for chillers.
</p>
</html>"));
    end Chillers;

    package Delays "Package with delay models"
      extends Modelica.Icons.VariantsPackage;

      model DelayFirstOrder
        "Delay element, approximated by a first order differential equation"
        extends Buildings.Fluid.MixingVolumes.MixingVolume(
          final V=V_nominal,
          final massDynamics=energyDynamics,
          final mSenFac=1);

        parameter Modelica.Units.SI.Time tau=60 "Time constant at nominal flow"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));

    protected
        parameter Modelica.Units.SI.Volume V_nominal=m_flow_nominal*tau/rho_default
          "Volume of delay element";
        annotation (    Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={      Text(
                extent={{-70,-26},{70,-66}},
                textColor={255,255,255},
                textString="tau=%tau")}),
      defaultComponentName="del",
          Documentation(info="<html>
<p>
This model approximates a transport delay using first order differential equations.
</p>
<p>
The model consists of a mixing volume with two ports. The size of the
mixing volume is such that at the nominal mass flow rate
<code>m_flow_nominal</code>,
the time constant of the volume is equal to the parameter <code>tau</code>.
</p>
<p>
The heat flux connector is optional and need not be connnected.
</p>
</html>",
      revisions="<html>
<ul>
<li>
March 7, 2022, by Michael Wetter:<br/>
Set <code>final massDynamics=energyDynamics</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">#1542</a>.
</li>
<li>
September 14, 2013, by Michael Wetter:<br/>
Renamed <code>V0</code> to <code>V_nominal</code> to use consistent notation.
</li>
<li>
September 24, 2008, by Michael Wetter:<br/>
Changed base class from <code>Modelica.Fluid</code> to <code>Buildings</code> library.
This was done to track the auxiliary species flow <code>mC_flow</code>.
</li>
<li>
September 4, 2008, by Michael Wetter:<br/>
Fixed bug in assignment of parameter <code>sta0</code>.
The earlier implementation
required temperature to be a state, which is not always the case.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DelayFirstOrder;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for transport delays in
piping networks.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.Delays.DelayFirstOrder\">
Buildings.Fluid.Delays.DelayFirstOrder</a>
approximates transport delays using a first order differential equation.
</p>
</html>"));
    end Delays;

    package FixedResistances "Package with models for fixed flow resistances"
      extends Modelica.Icons.VariantsPackage;

      model Junction
        "Flow splitter with fixed resistance at each port"
          extends Buildings.Fluid.BaseClasses.PartialThreeWayResistance(
          m_flow_small=mDyn_flow_nominal*1e-4,
          mDyn_flow_nominal = sum(abs(m_flow_nominal[:])/3),
          redeclare Buildings.Fluid.FixedResistances.PressureDrop res1(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[1],
            final dp_nominal=dp_nominal[1],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM),
          redeclare Buildings.Fluid.FixedResistances.PressureDrop res2(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[2],
            final dp_nominal=dp_nominal[2],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM),
          redeclare Buildings.Fluid.FixedResistances.PressureDrop res3(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[3],
            final dp_nominal=dp_nominal[3],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM));

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Modelica.Units.SI.MassFlowRate[3] m_flow_nominal
          "Mass flow rate. Set negative at outflowing ports."
          annotation (Dialog(group="Nominal condition"));

        parameter Modelica.Units.SI.Pressure[3] dp_nominal(each displayUnit="Pa")
          "Pressure drop at nominal mass flow rate, set to zero or negative number at outflowing ports."
          annotation (Dialog(group="Nominal condition"));

        parameter Real deltaM(min=0) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Dialog(group = "Transition to laminar",
                               enable = not linearized));

        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(tab="Advanced"));

      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

        annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Polygon(
                points={{-100,-46},{-32,-40},{-32,-100},{30,-100},{30,-36},{100,-30},
                    {100,38},{-100,52},{-100,-46}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-100,-34},{-18,-28},{-18,-100},{18,-100},{18,-26},{100,-20},
                    {100,22},{-100,38},{-100,-34}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,128,255}),
              Text(
                extent={{-151,142},{149,102}},
                textColor={0,0,255},
                textString="%name"),
              Rectangle(
                extent=DynamicSelect({{-100,10},{-100,10}}, {{-100,10},{-100+100*min(1, max(0, port_1.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3])))),-10}}),
                lineColor={28,108,200},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{-100,10},{-100,10}}, {{0,10},{100*max(-1, min(0, port_1.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3])))),-10}}),
                lineColor={28,108,200},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{0,10}, {0,10}}, {{100,10}, {(1-min(1, max(0, port_2.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3])))))*100,-10}}),
                lineColor={28,108,200},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent=DynamicSelect({{0,10}, {0,10}}, {{0,10}, {-max(-1, min(0, port_2.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3]))))*100,-10}}),
                lineColor={28,108,200},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{-10,0},{-10,0}}, {{-10,-100+100*min(1, max(0, port_3.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3]))))},{10,-100}}),
                lineColor={28,108,200},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{-10,0},{-10,0}}, {{-10, 100*max(-1, min(0, port_3.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3]))))},{10,0}}),
                lineColor={28,108,200},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                visible=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState,
                extent=DynamicSelect({{-35,35},{35,-35}}, {{-0,port_1.m_flow*0},{0,-0}}),
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
      defaultComponentName="jun",
          Documentation(info="<html>
<p>
Model of a flow junction with an optional fixed resistance in each flow leg
and an optional mixing volume at the junction.
</p>
<p>
The pressure drop is implemented using the model
<a href=\"modelica://Buildings.Fluid.FixedResistances.PressureDrop\">
Buildings.Fluid.FixedResistances.PressureDrop</a>.
If its nominal pressure drop is set to zero, then the pressure drop
model will be removed.
For example, the pressure drop declaration
</p>
<pre>
  m_flow_nominal={ 0.1, 0.1,  -0.2},
  dp_nominal =   {500,    0, -6000}
</pre>
<p>
would model a flow mixer that has the nominal flow rates and associated pressure drops
as shown in the figure below. Note that <code>port_3</code> is set to negative values.
The negative values indicate that at the nominal conditions, fluid is leaving the component.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Fluid/FixedResistances/Junction.png\"/>
</p>
<p>
If
<code>energyDynamics &lt;&gt; Modelica.Fluid.Types.Dynamics.SteadyState</code>,
then at the flow junction, a fluid volume is modeled.
The fluid volume is implemented using the model
<a href=\"modelica://Buildings.Fluid.Delays.DelayFirstOrder\">
Buildings.Fluid.Delays.DelayFirstOrder</a>.
The fluid volume has the size
</p>
<pre>
  V = sum(abs(m_flow_nominal[:])/3)*tau/rho_nominal
</pre>
<p>
where <code>tau</code> is a parameter and <code>rho_nominal</code> is the density
of the medium in the volume at nominal condition.
Setting <code>energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial</code>
can help reducing the size of the nonlinear
system of equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
February 26, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
March 26, 2018 by Filip Jorissen:<br/>
Removed <code>final allowFlowReversal=true</code> from all resistances
since this overrides the default simplification when the flow
is not bidirectional.
This change can lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/898\">issue 898</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Renamed model from <code>SplitterFixedResistanceDpM</code> to
<code>FlowJunction</code> and removed the parameters
<code>use_dh</code>, <code>dh</code> and <code>ReC</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/451\">issue 451</a>.
</li>
<li>
October 14, 2016 by Michael Wetter:<br/>
Added to Annex 60 library.<br/>
Updated comment for parameter <code>use_dh</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/451\">issue 451</a>.
</li>
<li>
Removed parameter <code>dynamicBalance</code> that overwrote the setting
of <code>energyDynamics</code> and <code>massDynamics</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/411\">
Annex 60, issue 411</a>.
</li>
<li>
February 1, 2012 by Michael Wetter:<br/>
Expanded documentation.
</li>
<li>
August 4, 2011 by Michael Wetter:<br/>
Added <code>final allowFlowReversal=true</code> to all resistances since it is impractical
to avoid flow reversal in large flow networks where such a setting may be useful.
</li>
<li>
June 11, 2008 by Michael Wetter:<br/>
Based class on
<a href=\"modelica://Buildings.Fluid.BaseClasses.PartialThreeWayFixedResistance\">
Buildings.Fluid.BaseClasses.PartialThreeWayFixedResistance</a>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Junction;

      model LosslessPipe "Pipe with no flow friction and no heat transfer"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface;
        final parameter Boolean from_dp=true "Used to satisfy replaceable models";
      equation
        dp=0;
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,60},{100,-60}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,50},{100,-48}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={217,236,255})}),
      defaultComponentName="pip",
          Documentation(info="<html>
<p>
Model of a pipe with no flow resistance, no heat loss and no transport delay.
This model can be used to replace a <code>replaceable</code> pipe model
in flow legs in which no friction should be modeled.
This is for example done in the outlet port of the
base class for three way valves,
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Implementation is now more efficient for <code>allowFlowReversal=false</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/949\">#949</a>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
June 13, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LosslessPipe;

      model PressureDrop
        "Fixed flow resistance with dp and m_flow as parameter"
        extends Buildings.Fluid.BaseClasses.PartialResistance(
          final m_flow_turbulent = if computeFlowResistance then deltaM * m_flow_nominal_pos else 0);

        parameter Real deltaM(min=1E-6) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Evaluate=true,
                        Dialog(group = "Transition to laminar",
                               enable = not linearized));

        final parameter Real k = if computeFlowResistance then
              m_flow_nominal_pos / sqrt(dp_nominal_pos) else 0
          "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
    protected
        final parameter Boolean computeFlowResistance=(dp_nominal_pos > Modelica.Constants.eps)
          "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
        final parameter Real coeff=
          if linearized and computeFlowResistance
          then if from_dp then k^2/m_flow_nominal_pos else m_flow_nominal_pos/k^2
          else 0
          "Precomputed coefficient to avoid division by parameter";
      initial equation
       if computeFlowResistance then
         assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
       end if;

       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            if from_dp then
              m_flow = dp*coeff;
            else
              dp = m_flow*coeff;
            end if;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(
                  actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                    dp=dp,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(
                  actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                    m_flow=m_flow,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                  dp=dp,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                  m_flow=m_flow,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance

        annotation (defaultComponentName="res",
      Documentation(info="<html>
<p>
Model of a flow resistance with a fixed flow coefficient.
The mass flow rate is
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k
&radic;<span style=\"text-decoration:overline;\">&Delta;p</span>,
</p>
<p>
where
<i>k</i> is a constant and
<i>&Delta;p</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/sqrt(dp_nominal)</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
</p>
<h4>Assumptions</h4>
<p>
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>,
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and
<code>m_flow_nominal</code> are parameters that can be set by the user.
</p>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Fluid/FixedResistances/PressureDrop.png\"/>
</p>
<h4>Important parameters</h4>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction,
models from the package
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the
<code>Buildings</code> library.
</p>
<p>
For a model that uses the hydraulic parameter and flow velocity at nominal conditions
as a parameter, use
<a href=\"modelica://Buildings.Fluid.FixedResistances.HydraulicDiameter\">
Buildings.Fluid.FixedResistances.HydraulicDiameter</a>.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels\">
Buildings.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m&#775; = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 21, 2018, by Michael Wetter:<br/>
Decrease value of <code>deltaM(min=...)</code> attribute.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1026\">#1026</a>.
</li>
<li>
February 3, 2018, by Filip Jorissen:<br/>
Revised implementation of pressure drop equation
such that it depends on <code>from_dp</code>
when <code>linearized=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/884\">#884</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Simplified model by removing the geometry dependent parameters into the new
model
<a href=\"modelica://Buildings.Fluid.FixedResistances.HydraulicDiameter\">
Buildings.Fluid.FixedResistances.HydraulicDiameter</a>.
</li>
<li>
November 23, 2016, by Filip Jorissen:<br/>
Removed <code>dp_nominal</code> and
<code>m_flow_nominal</code> labels from icon.
</li>
<li>
October 14, 2016, by Michael Wetter:<br/>
Updated comment for parameter <code>use_dh</code>.
</li>
<li>
November 26, 2014, by Michael Wetter:<br/>
Added the required <code>annotation(Evaluate=true)</code> so
that the system of nonlinear equations in
<a href=\"modelica://Buildings.Fluid.FixedResistances.Validation.PressureDropsExplicit\">
Buildings.Fluid.FixedResistances.Validation.PressureDropsExplicit</a>
remains the same.
</li>
<li>
November 20, 2014, by Michael Wetter:<br/>
Rewrote the warning message using an <code>assert</code> with
<code>AssertionLevel.warning</code>
as this is the proper way to write warnings in Modelica.
</li>
<li>
August 5, 2014, by Michael Wetter:<br/>
Corrected error in documentation of computation of <code>k</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PressureDrop;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for fixed flow resistances.
By fixed flow resistance, we mean resistances that do not change the
flow coefficient
</p>
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl;
&radic;<span style=\"text-decoration:overline;\">&Delta;p</span>.
</p>
<p>
For models of valves and air dampers, see
<a href=\"modelica://Buildings.Fluid.Actuators\">
Buildings.Fluid.Actuators</a>.
For models of flow resistances as part of the building constructions, see
<a href=\"modelica://Buildings.Airflow.Multizone\">
Buildings.Airflow.Multizone</a>.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.PressureDrop\">
Buildings.Fluid.FixedResistances.PressureDrop</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and a nominal pressure drop. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.HydraulicDiameter\">
Buildings.Fluid.FixedResistances.HydraulicDiameter</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and
a hydraulic diameter. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.LosslessPipe\">
Buildings.Fluid.FixedResistances.LosslessPipe</a>
is an ideal pipe segment with no pressure drop. It is primarily used
in models in which the above pressure drop model need to be replaced by a model with no pressure drop.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.Junction\">
Buildings.Fluid.FixedResistances.Junction</a>
can be used to model flow splitters or flow merges.
</p>
</html>"));
    end FixedResistances;

    package HeatExchangers "Package with heat exchanger models"
      extends Modelica.Icons.VariantsPackage;

      model ConstantEffectiveness "Heat exchanger with constant effectiveness"
        extends Buildings.Fluid.HeatExchangers.BaseClasses.PartialEffectiveness(
          sensibleOnly1 = true,
          sensibleOnly2 = true,
          final prescribedHeatFlowRate1=true,
          final prescribedHeatFlowRate2=true,
          Q1_flow = eps * QMax_flow,
          Q2_flow = -Q1_flow,
          mWat1_flow = 0,
          mWat2_flow = 0);

        parameter Modelica.Units.SI.Efficiency eps(max=1) = 0.8
          "Heat exchanger effectiveness";

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-70,78},{70,-82}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid), Text(
                extent={{-56,-12},{54,-72}},
                textColor={255,255,255},
                textString="eps=%eps")}),
                preferredView="info",
      defaultComponentName="hex",
      Documentation(info="<html>
<p>
Model for a heat exchanger with constant effectiveness.
</p>
<p>
This model transfers heat in the amount of
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q = Q<sub>max</sub> &epsilon;,
</p>
<p>
where <i>&epsilon;</i> is a constant effectiveness and
<i>Q<sub>max</sub></i> is the maximum heat that can be transferred.
</p>
<p>
For a heat and moisture exchanger, use
<a href=\"modelica://Buildings.Fluid.MassExchangers.ConstantEffectiveness\">
Buildings.Fluid.MassExchangers.ConstantEffectiveness</a>
instead of this model.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 13, 2013 by Michael Wetter:<br/>
Corrected error in the documentation.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Updated model to use new variable <code>mWat_flow</code>
in the base class.
</li>
<li>
January 28, 2010, by Michael Wetter:<br/>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br/>
Changed computation of inlet temperatures to use
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ConstantEffectiveness;

      model DryCoilCounterFlow
        "Counterflow coil with discretization along the flow paths and without humidity condensation"
        extends Buildings.Fluid.Interfaces.PartialFourPortInterface(show_T=false);
        extends Buildings.Fluid.Interfaces.FourPortFlowResistanceParameters(
          final computeFlowResistance1=false,
          final computeFlowResistance2=false,
          from_dp1=false,
          from_dp2=false);

        parameter Modelica.Units.SI.ThermalConductance UA_nominal(min=0)
          "Thermal conductance at nominal flow, used to compute heat capacity"
          annotation (Dialog(tab="General", group="Nominal condition"));
        parameter Real r_nominal=2/3
          "Ratio between air-side and water-side convective heat transfer coefficient"
          annotation (Dialog(group="Nominal condition"));
        parameter Integer nEle(min=1) = 4
          "Number of pipe segments used for discretization"
          annotation (Dialog(group="Geometry"));

        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Formulation of energy balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));

        parameter Modelica.Units.SI.Time tau1=10
          "Time constant at nominal flow for medium 1" annotation (Dialog(group=
                "Nominal condition", enable=not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)));
        parameter Modelica.Units.SI.Time tau2=2
          "Time constant at nominal flow for medium 2" annotation (Dialog(group=
                "Nominal condition", enable=not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)));
        parameter Modelica.Units.SI.Time tau_m=5
          "Time constant of metal at nominal UA value"
          annotation (Dialog(group="Nominal condition"));

        parameter Boolean waterSideFlowDependent=true
          "Set to false to make water-side hA independent of mass flow rate"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean airSideFlowDependent=true
          "Set to false to make air-side hA independent of mass flow rate"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean waterSideTemperatureDependent=false
          "Set to false to make water-side hA independent of temperature"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean airSideTemperatureDependent=false
          "Set to false to make air-side hA independent of temperature"
          annotation (Dialog(tab="Heat transfer"));

        parameter Modelica.Units.SI.ThermalConductance GDif=1E-2*UA_nominal/max(1, (nEle - 1))
          "Thermal conductance to approximate diffusion (which improves model at near-zero flow rates)"
          annotation (Dialog(tab="Experimental"));
        Modelica.Units.SI.HeatFlowRate Q1_flow=sum(ele[i].Q1_flow for i in 1:nEle)
          "Heat transferred from solid into medium 1";
        Modelica.Units.SI.HeatFlowRate Q2_flow=sum(ele[i].Q2_flow for i in 1:nEle)
          "Heat transferred from solid into medium 2";

        Modelica.Units.SI.Temperature T1[nEle]=ele[:].vol1.T "Water temperature";
        Modelica.Units.SI.Temperature T2[nEle]=ele[:].vol2.T "Air temperature";
        Modelica.Units.SI.Temperature T_m[nEle]=ele[:].con1.solid.T
          "Metal temperature";

        BaseClasses.HADryCoil hA(
          final UA_nominal=UA_nominal,
          final m_flow_nominal_a=m2_flow_nominal,
          final m_flow_nominal_w=m1_flow_nominal,
          final waterSideTemperatureDependent=waterSideTemperatureDependent,
          final waterSideFlowDependent=waterSideFlowDependent,
          final airSideTemperatureDependent=airSideTemperatureDependent,
          final airSideFlowDependent=airSideFlowDependent,
          r_nominal=r_nominal) "Model for convective heat transfer coefficient"
          annotation (Placement(transformation(extent={{-60,70},{-40,90}})));
    protected
        final parameter Boolean use_temSen_1=
          waterSideTemperatureDependent and allowFlowReversal1 and
          (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
          "Flag, set to true if the temperature sensor 1 is used"
          annotation(Evaluate=true);

        final parameter Boolean use_temSen_2=
          airSideTemperatureDependent and allowFlowReversal2 and
          (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
          "Flag, set to true if the temperature sensor 2 is used"
          annotation(Evaluate=true);

        Buildings.Fluid.Sensors.TemperatureTwoPort temSen_1(
         redeclare package Medium = Medium1,
          allowFlowReversal=allowFlowReversal1,
          m_flow_nominal=m1_flow_nominal,
          tau=if use_temSen_1 then 1 else 0)
          "Temperature sensor, used to obtain temperature for convective heat transfer calculation"
          annotation (Placement(transformation(
                extent={{-58,54},{-46,66}})));
        Buildings.Fluid.Sensors.MassFlowRate masFloSen_1(
          redeclare package Medium = Medium1) "Mass flow rate sensor" annotation (Placement(transformation(
                extent={{-80,54},{-68,66}})));

        Buildings.Fluid.Sensors.TemperatureTwoPort temSen_2(
          redeclare package Medium = Medium2,
          final allowFlowReversal=allowFlowReversal2,
          m_flow_nominal=m2_flow_nominal,
          tau=if use_temSen_2 then 1 else 0)
          "Temperature sensor, used to obtain temperature for convective heat transfer calculation"
          annotation (Placement(transformation(
                extent={{58,-66},{44,-54}})));
        Buildings.Fluid.Sensors.MassFlowRate masFloSen_2(
          redeclare package Medium = Medium2)
          "Mass flow rate sensor" annotation (Placement(transformation(
                extent={{82,-66},{70,-54}})));

        Modelica.Blocks.Math.Gain gai_1(k=1/nEle)
          "Gain medium-side 1 to take discretization into account" annotation (
            Placement(transformation(extent={{-18,84},{-6,96}})));
        Modelica.Blocks.Math.Gain gai_2(k=1/nEle)
          "Gain medium-side 2 to take discretization into account" annotation (
            Placement(transformation(extent={{-18,62},{-6,74}})));

        replaceable model HexElement = BaseClasses.HexElementSensible "Model for a heat exchanger element";

        HexElement ele[nEle](
          redeclare each package Medium1 = Medium1,
          redeclare each package Medium2 = Medium2,
          each allowFlowReversal1=allowFlowReversal1,
          each allowFlowReversal2=allowFlowReversal2,
          each tau1=tau1/nEle,
          each m1_flow_nominal=m1_flow_nominal,
          each tau2=tau2,
          each m2_flow_nominal=m2_flow_nominal,
          each tau_m=tau_m/nEle,
          each UA_nominal=UA_nominal/nEle,
          each energyDynamics=energyDynamics,
          initialize_p1 = {(i == 1 and (not Medium1.singleState)) for i in 1:nEle},
          initialize_p2 = {(i == 1 and (not Medium2.singleState)) for i in 1:nEle},
          each deltaM1=deltaM1,
          each deltaM2=deltaM2,
          each from_dp1=from_dp1,
          each from_dp2=from_dp2,
          dp1_nominal={if i == 1 then dp1_nominal else 0 for i in 1:nEle},
          dp2_nominal={if i == nEle then dp2_nominal else 0 for i in 1:nEle})
          "Heat exchanger element"
          annotation (Placement(transformation(extent={{0,0},{20,20}})));
        Modelica.Blocks.Routing.Replicator rep1(nout=nEle) "Signal replicator"
          annotation (Placement(transformation(extent={{4,82},{18,98}})));
        Modelica.Blocks.Routing.Replicator rep2(nout=nEle) "Signal replicator"
          annotation (Placement(transformation(extent={{4,60},{18,76}})));


        Modelica.Blocks.Sources.RealExpression THA1(
          y=if waterSideTemperatureDependent then
              if allowFlowReversal1 then
                if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
                  temSen_1.T
                else
                  ele[1].vol1.T
              else
                Medium1.temperature(
                  state=Medium1.setState_phX(p=port_a1.p, h=inStream(port_a1.h_outflow), X=inStream(port_a1.Xi_outflow)))
              else
                Medium1.T_default)
          "Temperature used for convective heat transfer calculation for medium 1 (water-side)"
          annotation (Placement(transformation(extent={{-80,78},{-66,88}})));

        Modelica.Blocks.Sources.RealExpression THA2(
          y=if airSideTemperatureDependent then
              if allowFlowReversal1 then
                if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
                  temSen_2.T
                else
                  ele[nEle].vol2.T
              else
                Medium2.temperature(
                  state=Medium2.setState_phX(p=port_a2.p, h=inStream(port_a2.h_outflow), X=inStream(port_a2.Xi_outflow)))
              else
                Medium2.T_default)
          "Temperature used for convective heat transfer calculation for medium 2 (air-side)"
          annotation (Placement(transformation(extent={{-80,72},{-66,82}})));

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor theCon1[nEle-1](each final G=GDif)
          "Thermal connector to approximate diffusion in medium 1"
          annotation (Placement(transformation(extent={{0,34},{20,54}})));

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor theCon2[nEle-1](each final G=GDif)
          "Thermal connector to approximate diffusion in medium 2"
          annotation (Placement(transformation(extent={{20,-40},{0,-20}})));

      initial equation
        assert(UA_nominal > 0,
          "Parameter UA_nominal is negative. Check heat exchanger parameters.");





      equation
        connect(masFloSen_1.m_flow, hA.m1_flow) annotation (Line(points={{-74,66.6},{
                -74,70},{-84,70},{-84,94},{-64,94},{-64,87},{-61,87}},
                                                     color={0,0,127}));
        connect(port_a2, masFloSen_2.port_a)
          annotation (Line(points={{100,-60},{82,-60}}, color={0,127,255}));
        connect(masFloSen_2.port_b, temSen_2.port_a)
          annotation (Line(points={{70,-60},{64,-60},{58,-60}},
                                                       color={0,127,255}));
        connect(masFloSen_2.m_flow, hA.m2_flow) annotation (Line(points={{76,-53.4},{
                76,-44},{-86,-44},{-86,73},{-61,73}}, color={0,0,127}));
        connect(hA.hA_1, gai_1.u) annotation (Line(points={{-39,87},{-28,87},{-28,90},
                {-19.2,90}}, color={0,0,255}));
        connect(hA.hA_2, gai_2.u) annotation (Line(points={{-39,73},{-27.5,73},{-27.5,
                68},{-19.2,68}}, color={0,0,255}));
        connect(port_a1, masFloSen_1.port_a) annotation (Line(
            points={{-100,60},{-80,60}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(masFloSen_1.port_b, temSen_1.port_a) annotation (Line(
            points={{-68,60},{-58,60}},
            color={0,127,255},
            smooth=Smooth.None));

        connect(ele[nEle].port_b1, port_b1) annotation (Line(
            points={{20,16},{40,16},{40,60},{100,60}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(ele[1].port_b2, port_b2) annotation (Line(
            points={{0,4},{-30,4},{-30,-60},{-100,-60}},
            color={0,127,255},
            smooth=Smooth.None));
        for i in 1:nEle - 1 loop
          connect(ele[i].port_b1, ele[i + 1].port_a1) annotation (Line(
              points={{20,16},{30,16},{30,28},{-10,28},{-10,16},{0,16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(ele[i].port_a2, ele[i + 1].port_b2) annotation (Line(
              points={{20,4},{-12,4},{-12,-10},{30,-10},{30,4},{0,4}},
              color={0,127,255},
              smooth=Smooth.None));
        connect(theCon1[i].port_a, ele[i].heaPor1) annotation (Line(points={{0,44},{-10,
                44},{-10,32},{10,32},{10,20}}, color={191,0,0}));
        connect(theCon1[i].port_b, ele[i+1].heaPor1) annotation (Line(points={{20,44},{28,
                44},{28,32},{10,32},{10,20}}, color={191,0,0}));
        connect(theCon2[i].port_a, ele[i].heaPor2) annotation (Line(points={{20,-30},{
                24,-30},{24,-14},{10,-14},{10,0}}, color={191,0,0}));
        connect(theCon2[i].port_b, ele[i+1].heaPor2) annotation (Line(points={{0,-30},{-8,
                -30},{-8,-14},{10,-14},{10,0}}, color={191,0,0}));
        end for;

        connect(gai_1.y, rep1.u) annotation (Line(
            points={{-5.4,90},{2.6,90}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(rep1.y, ele.Gc_1) annotation (Line(
            points={{18.7,90},{44,90},{44,26},{6,26},{6,20}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(gai_2.y, rep2.u) annotation (Line(
            points={{-5.4,68},{2.6,68}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(rep2.y, ele.Gc_2) annotation (Line(
            points={{18.7,68},{48,68},{48,-6},{14,-6},{14,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(THA1.y, hA.T_1) annotation (Line(points={{-65.3,83},{-65.3,83},{-61,
                83}},
              color={0,0,127}));
        connect(THA2.y, hA.T_2) annotation (Line(points={{-65.3,77},{-65.3,77},{-61,
                77}},
              color={0,0,127}));

        connect(temSen_1.port_b, ele[1].port_a1) annotation (Line(
            points={{-46,60},{-30,60},{-30,16},{0,16}},
            color={0,127,255},
            smooth=Smooth.None));

        connect(temSen_2.port_b, ele[nEle].port_a2) annotation (Line(
            points={{44,-60},{30,-60},{30,4},{20,4}},
            color={0,127,255},
            smooth=Smooth.None));
        annotation (
      defaultComponentName="heaCoi",
      Documentation(info="<html>
<p>
Model of a discretized coil without water vapor condensation.
The coil consists of two flow paths which are, at the design flow direction,
in opposite direction to model a counterflow heat exchanger.
The flow paths are discretized into <code>nEle</code> elements.
Each element is modeled by an instance of
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HexElementSensible\">
Buildings.Fluid.HeatExchangers.BaseClasses.HexElementSensible</a>.
Each element has a state variable for the metal.
</p>
<p>
The convective heat transfer coefficients can, for each fluid individually, be
computed as a function of the flow rate and/or the temperature,
or assigned to a constant. This computation is done using an instance of
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil\">
Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil</a>.
</p>
<p>
To model humidity condensation, use the model
<a href=\"modelica://Buildings.Fluid.HeatExchangers.WetCoilCounterFlow\">
Buildings.Fluid.HeatExchangers.WetCoilCounterFlow</a> instead of this model, as
this model computes only sensible heat transfer.
</p>
<h4>Implementation</h4>
<p>
At very small flow rates, which may be caused when the fan is off but there is wind pressure
on the building that entrains outside air through the HVAC system, large temperature differences
could occur if diffusion were neglected.
This model therefore approximates a small diffusion between the elements to have more uniform
medium temperatures if the flow is near zero.
The approximation is done using the heat conductors <code>heaCon1</code> and <code>heaCon2</code>.
As this is a rough approximation, neighboring elements are connected through these heat conduction
elements, ignoring the actual geometrical configuration.
Also, radiation between the coil surfaces on the air side is not modelled explicitly, but
rather may be considered as approximated by these heat conductors.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 19, 2018, by Kino:<br/>
Changed model to use a replaceable model as this allows translation in OpenModelica.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1258\">#1258</a>.
</li>
<li>
November 12, 2017, by Michael wetter:<br/>
Changed time constant to more reasonable values, which also makes
closed loop control tuning easier.
</li>
<li>
November 4, 2017, by Michael wetter:<br/>
Added approximation of diffusion.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1038\">Buildings, #1038</a>.
</li>
<li>
September 8, 2017, by Michael Wetter:<br/>
Changed computation of temperature used for <i>hA</i> calculation
to avoid a state variable with small time constant for some model parameterizations.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/678\">Buildings, #678</a>.
</li>
<li>
September 12, 2014, by Michael Wetter:<br/>
Changed assignment of <code>T_m</code> to avoid using the conditionally
enabled model <code>ele[:].mas.T</code>, which is only
valid in a connect statement.
Moved assignments of
<code>Q1_flow</code>, <code>Q2_flow</code>, <code>T1</code>,
<code>T2</code> and <code>T_m</code> outside of equation section
to avoid mixing graphical and textual modeling within the same model.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameters <code>initialize_p1</code> and <code>initialize_p2</code>.
This is required to enable the coil models to initialize the pressure in the
first volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
June 26, 2014, by Michael Wetter:<br/>
Removed parameters <code>energyDynamics1</code> and <code>energyDynamics2</code>,
and used instead of these two parameters the new parameter <code>energyDynamics</code>.
This was done as this complexity is not required.
</li>
<li>
February 2, 2012, by Michael Wetter:<br/>
Corrected error in assignment of <code>dp2_nominal</code>.
The previous assignment caused a pressure drop in all except one element,
instead of the opposite. This caused too high a flow resistance
of the heat exchanger.
</li>
<li>
October 8, 2011, by Michael Wetter:<br/>
Set <code>show_T=false</code> to avoid state events near zero flow.
</li>
<li>
May 27, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{36,80},{40,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-40,80},{-36,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-2,80},{2,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-98,65},{103,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2},
              initialScale=0.5), graphics={Text(
                extent={{60,72},{84,58}},
                textColor={0,0,255},
                textString="water-side"), Text(
                extent={{50,-32},{90,-38}},
                textColor={0,0,255},
                textString="air-side")}));
      end DryCoilCounterFlow;

      package CoolingTowers "Package with cooling tower models"
        extends Modelica.Icons.VariantsPackage;

        model YorkCalc
          "Cooling tower with variable speed using the York calculation for the approach temperature"
          extends
          Buildings.Fluid.HeatExchangers.CoolingTowers.BaseClasses.CoolingTowerVariableSpeed(
            TWatIn_nominal(fixed=false),
            TWatOut_nominal(fixed=false),
            fanRelPowDer(each fixed=false));

          parameter Modelica.Units.SI.TemperatureDifference TApp_nominal(displayUnit=
                "K") = 3.89 "Design approach temperature"
            annotation (Dialog(group="Nominal condition"));
          parameter Modelica.Units.SI.TemperatureDifference TRan_nominal(displayUnit=
                "K") = 5.56 "Design range temperature (water in - water out)"
            annotation (Dialog(group="Nominal condition"));

          Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations.BoundsYorkCalc bou
            "Bounds for correlation";

          Modelica.Units.SI.TemperatureDifference TRan(displayUnit="K") = T_a - T_b
            "Range temperature";
          Modelica.Units.SI.TemperatureDifference TAppAct(displayUnit="K")=
            Buildings.Utilities.Math.Functions.spliceFunction(
            pos=TAppCor,
            neg=TAppFreCon,
            x=y - yMin + yMin/20,
            deltax=yMin/20) "Approach temperature difference";
          Modelica.Units.SI.MassFraction FRWat=m_flow/mWat_flow_nominal
            "Ratio actual over design water mass flow ratio";
          Modelica.Units.SI.MassFraction FRAir=y
            "Ratio actual over design air mass flow ratio";

      protected
          package Water =  Buildings.Media.Water "Medium package for water";
          parameter Real FRWat0(min=0, start=1, fixed=false)
            "Ratio actual over design water mass flow ratio at nominal condition";
          parameter Modelica.Units.SI.MassFlowRate mWat_flow_nominal(
            min=0,
            start=m_flow_nominal,
            fixed=false) "Nominal water mass flow rate";

          Modelica.Units.SI.TemperatureDifference dTMax(displayUnit="K") = T_a - TAir
            "Maximum possible temperature difference";
          Modelica.Units.SI.TemperatureDifference TAppCor(
            min=0,
            displayUnit="K")=
            Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations.yorkCalc(
            TRan=TRan,
            TWetBul=TAir,
            FRWat=FRWat,
            FRAir=Buildings.Utilities.Math.Functions.smoothMax(
              x1=FRWat/bou.liqGasRat_max,
              x2=FRAir,
              deltaX=0.01)) "Approach temperature for forced convection";
          Modelica.Units.SI.TemperatureDifference TAppFreCon(
            min=0,
            displayUnit="K") = (1 - fraFreCon)*dTMax + fraFreCon*
            Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations.yorkCalc(
            TRan=TRan,
            TWetBul=TAir,
            FRWat=FRWat,
            FRAir=1) "Approach temperature for free convection";

          Modelica.Units.SI.Temperature T_a "Temperature in port_a";
          Modelica.Units.SI.Temperature T_b "Temperature in port_b";

          Modelica.Blocks.Sources.RealExpression QWat_flow(
            y = m_flow*(
              Medium.specificEnthalpy(Medium.setState_pTX(
                p=port_b.p,
                T=TAir + TAppAct,
                X=inStream(port_b.Xi_outflow))) -
              inStream(port_a.h_outflow)))
            "Heat input into water"
            annotation (Placement(transformation(extent={{-80,-70},{-60,-50}})));
        initial equation
          TWatOut_nominal = TAirInWB_nominal + TApp_nominal;
          TRan_nominal = TWatIn_nominal - TWatOut_nominal; // by definition of the range temp.
          TApp_nominal = Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations.yorkCalc(
                           TRan=TRan_nominal, TWetBul=TAirInWB_nominal,
                           FRWat=FRWat0, FRAir=1); // this will be solved for FRWat0
          mWat_flow_nominal = m_flow_nominal/FRWat0;

          // Derivatives for spline that interpolates the fan relative power
          fanRelPowDer = Buildings.Utilities.Math.Functions.splineDerivatives(
                    x=fanRelPow.r_V,
                    y=fanRelPow.r_P,
                    ensureMonotonicity=Buildings.Utilities.Math.Functions.isMonotonic(x=fanRelPow.r_P,
                                                                                      strict=false));

          // Check that a medium is used that has the same definition of enthalpy vs. temperature.
          // This is needed because below, T_a=Water.temperature needed to be hard-coded to use
          // Water.* instead of Medium.* in the function calls due to a bug in OpenModelica.
          assert(abs(Medium.specificEnthalpy_pTX(p=101325, T=273.15, X=Medium.X_default) -
                     Water.specificEnthalpy_pTX(p=101325, T=273.15, X=Medium.X_default)) < 1E-5 and
                 abs(Medium.specificEnthalpy_pTX(p=101325, T=293.15, X=Medium.X_default) -
                     Water.specificEnthalpy_pTX(p=101325, T=293.15, X=Medium.X_default)) < 1E-5,
                 "The selected medium has an enthalpy computation that is not consistent
  with the one in Buildings.Media.Water
  Use a different medium, such as Buildings.Media.Water.");
        equation
          // States at the inlet and outlet

          if allowFlowReversal then
            if homotopyInitialization then
              T_a=Water.temperature(Water.setState_phX(p=port_a.p,
                                         h=homotopy(actual=actualStream(port_a.h_outflow),
                                                    simplified=inStream(port_a.h_outflow)),
                                         X=homotopy(actual=actualStream(port_a.Xi_outflow),
                                                    simplified=inStream(port_a.Xi_outflow))));
              T_b=Water.temperature(Water.setState_phX(p=port_b.p,
                                         h=homotopy(actual=actualStream(port_b.h_outflow),
                                                    simplified=port_b.h_outflow),
                                         X=homotopy(actual=actualStream(port_b.Xi_outflow),
                                                    simplified=port_b.Xi_outflow)));

            else
              T_a=Water.temperature(Water.setState_phX(p=port_a.p,
                                         h=actualStream(port_a.h_outflow),
                                         X=actualStream(port_a.Xi_outflow)));
              T_b=Water.temperature(Water.setState_phX(p=port_b.p,
                                         h=actualStream(port_b.h_outflow),
                                         X=actualStream(port_b.Xi_outflow)));
            end if; // homotopyInitialization

          else // reverse flow not allowed
            T_a=Water.temperature(Water.setState_phX(p=port_a.p,
                                       h=inStream(port_a.h_outflow),
                                       X=inStream(port_a.Xi_outflow)));
            T_b=Water.temperature(Water.setState_phX(p=port_b.p,
                                       h=inStream(port_b.h_outflow),
                                       X=inStream(port_b.Xi_outflow)));
          end if;

          connect(QWat_flow.y, preHea.Q_flow)
            annotation (Line(points={{-59,-60},{-40,-60}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={
                Text(
                  extent={{-104,70},{-70,32}},
                  textColor={0,0,127},
                  textString="TWB"),
                Text(
                  extent={{-50,4},{42,-110}},
                  textColor={255,255,255},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid,
                  textString="York"),
                Rectangle(
                  extent={{-100,81},{-70,78}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{70,56},{82,52}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{78,54},{82,80}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{64,114},{98,76}},
                  textColor={0,0,127},
                  textString="PFan"),
                Ellipse(
                  extent={{0,62},{54,50}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-54,62},{0,50}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{78,82},{100,78}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-98,100},{-86,84}},
                  textColor={0,0,127},
                  textString="y")}),
        Documentation(info="<html>
<p>
Model for a steady-state or dynamic cooling tower with variable speed fan using the York calculation for the
approach temperature at off-design conditions.
</p>
<h4>Thermal performance</h4>
<p>
To compute the thermal performance, this model takes as parameters
the approach temperature, the range temperature and the inlet air wet bulb temperature
at the design condition. Since the design mass flow rate (of the chiller condenser loop)
is also a parameter, these parameters define the rejected heat.
</p>
<p>
For off-design conditions, the model uses the actual range temperature and a polynomial
to compute the approach temperature for free convection and for forced convection, i.e.,
with the fan operating. The polynomial is valid for a York cooling tower.
If the fan input signal <code>y</code> is below the minimum fan revolution <code>yMin</code>,
then the cooling tower operates in free convection mode, otherwise it operates in
the forced convection mode.
For numerical reasons, this transition occurs in the range of <code>y &isin; [0.9*yMin, yMin]</code>.
</p>
<h4>Fan power consumption</h4>
<p>
The fan power consumption at the design condition can be specified as follows:
</p>
<ul>
<li>
The parameter <code>fraPFan_nominal</code> can be used to specify at the
nominal conditions the fan power divided by the water flow rate. The default value is
<i>275</i> Watts for a water flow rate of <i>0.15</i> kg/s.
</li>
<li>
The parameter <code>PFan_nominal</code> can be set to the fan power at nominal conditions.
If a user does not set this parameter, then the fan power will be
<code>PFan_nominal = fraPFan_nominal * m_flow_nominal</code>, where <code>m_flow_nominal</code>
is the nominal water flow rate.
</li>
</ul>
<p>
In the forced convection mode, the actual fan power is
computed as <code>PFan=fanRelPow(y) * PFan_nominal</code>, where
the default value for the fan relative power consumption at part load is
<code>fanRelPow(y)=y<sup>3</sup></code>.
In the free convection mode, the fan power consumption is zero.
For numerical reasons, the transition of fan power from the part load mode
to zero power consumption in the free convection mode occurs in the range
<code>y &isin; [0.9*yMin, yMin]</code>.
<br/>
To change the fan relative power consumption at part load in the forced convection mode,
points of fan controls signal and associated relative power consumption can be specified.
In between these points, the values are interpolated using cubic splines.
</p>
<h4>Comparison the cooling tower model of EnergyPlus</h4>
<p>
This model is similar to the model <code>Cooling Tower:Variable Speed</code> that
is implemented in the EnergyPlus building energy simulation program version 6.0.
The main differences are
</p>
<ol>
<li>
Not implemented are the basin heater power consumption, and
the make-up water usage.
</li>
<li>
The model has no built-in control to switch individual cells of the tower on or off.
To switch cells on or off, use multiple instances of this model, and use your own
control law to compute the input signal <code>y</code>.
</li>
</ol>
<h4>Assumptions and limitations</h4>
<p>
This model requires a medium that has the same computation of the enthalpy as
<a href=\"modelica://Buildings.Media.Water\">
Buildings.Media.Water</a>,
which computes
</p>
<p align=\"center\" style=\"font-style:italic;\">
 h = c<sub>p</sub> (T-T<sub>0</sub>),
</p>
<p>
where
<i>h</i> is the enthalpy,
<i>c<sub>p</sub> = 4184</i> J/(kg K) is the specific heat capacity,
<i>T</i> is the temperature in Kelvin and
<i>T<sub>0</sub> = 273.15</i> Kelvin.
If this is not the case, the simulation will stop with an error message.
The reason for this limitation is that as of January 2015, OpenModelica
failed to translate the model if <code>Medium.temperature()</code> is used
instead of
<code>Water.temperature()</code>.
</p>
<h4>References</h4>
<p>
<a href=\"http://www.energyplus.gov\">EnergyPlus 2.0.0 Engineering Reference</a>, April 9, 2007.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 26, 2021, by Baptiste Ravache:<br/>
Renamed parameter TWatIn0 to TWatIn_nominal.
</li>
<li>
January 16, 2020, by Michael Wetter:<br/>
Refactored model to avoid mixing textual equations and connect statements.
</li>
<li>
December, 22, 2019, by Kathryn Hinkelman:<br/>
Corrected fan power consumption.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1691\">
issue 1691</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Corrected wrong type for <code>FRWat0</code>, as this variable
can take on values that are bigger than <i>1</i>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/567\">issue 567</a>.
</li>
<li>
January 2, 2015, by Michael Wetter:<br/>
Replaced <code>Medium.temperature()</code> with
<code>Water.temperature()</code> in order for the model
to work with OpenModelica.
Added an <code>assert</code> that stops the simulation if
an incompatible medium is used.
</li>
<li>
November 13, 2014, by Michael Wetter:<br/>
Added missing <code>each</code> keyword for <code>fanRelPowDer</code>.
Added regularization in computation of <code>TAppCor</code>.
Removed intermediate states with temperatures.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 9, 2013, by Michael Wetter:<br/>
Simplified the implementation for the situation if
<code>allowReverseFlow=false</code>.
Avoided the use of the conditionally enabled variables <code>sta_a</code> and
<code>sta_b</code> as this was not proper use of the Modelica syntax.
</li>
<li>
September 29, 2011, by Michael Wetter:<br/>
Revised model to use cubic spline interpolation instead of a polynomial.
</li>
<li>
July 12, 2011, by Michael Wetter:<br/>
Introduced common base class for
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc\">Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc</a>
and
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.FixedApproach\">Buildings.Fluid.HeatExchangers.CoolingTowers.FixedApproach</a>
so that they can be used as replaceable models.
</li>
<li>
May 12, 2011, by Michael Wetter:<br/>
Added binding equations for <code>Q_flow</code> and <code>mXi_flow</code>.
</li>
<li>
March 8, 2011, by Michael Wetter:<br/>
Removed base class and unused variables.
</li>
<li>
February 25, 2011, by Michael Wetter:<br/>
Revised implementation to facilitate scaling the model to different nominal sizes.
Removed parameter <code>mWat_flow_nominal</code> since it is equal to <code>m_flow_nominal</code>,
which is the water flow rate from the chiller condenser loop.
</li>
<li>
May 16, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end YorkCalc;

        package Correlations
        "Package with correlations for cooling tower performance"
          extends Modelica.Icons.MaterialProperty;

          function yorkCalc "Cooling tower performance correlation for YorkCalc model"

            input Modelica.Units.SI.TemperatureDifference TRan
              "Range temperature (water in - water out)"
              annotation (Dialog(group="Nominal condition"));
            input Modelica.Units.SI.Temperature TWetBul "Air wet-bulb inlet temperature";
            input Modelica.Units.SI.MassFraction FRWat
              "Ratio actual over design water mass flow ratio";
            input Modelica.Units.SI.MassFraction FRAir
              "Ratio actual over design air mass flow ratio";

            output Modelica.Units.SI.TemperatureDifference TApp "Approach temperature";

        protected
            Modelica.Units.NonSI.Temperature_degC TWetBul_degC
              "Air wet-bulb inlet temperature";
            Modelica.Units.SI.MassFraction liqGasRat "Liquid to gas mass flow ratio";
            constant Real c[:] = {-0.359741205, -0.055053608,  0.0023850432,
                                0.173926877, -0.0248473764,  0.00048430224,
                                -0.005589849456,  0.0005770079712, -0.00001342427256,
                                2.84765801111111, -0.121765149,  0.0014599242,
                                1.680428651, -0.0166920786, -0.0007190532,
                               -0.025485194448,  0.0000487491696,  0.00002719234152,
                               -0.0653766255555556, -0.002278167,  0.0002500254,
                               -0.0910565458,  0.00318176316,  0.000038621772,
                               -0.0034285382352,  0.00000856589904, -0.000001516821552}
              "Polynomial coefficients";

          algorithm
            TWetBul_degC :=Modelica.Units.Conversions.to_degC(TWetBul);
            // smoothMax is added to the numerator and denominator so that
            // liqGasRat -> 1, as both FRWat -> 0 and FRAir -> 0
            liqGasRat := Buildings.Utilities.Math.Functions.smoothMax(x1=1E-4, x2=FRWat, deltaX=1E-5)/
                         Buildings.Utilities.Math.Functions.smoothMax(x1=1E-4, x2=FRAir, deltaX=1E-5);
            TApp := c[1] +
                 c[2] * TWetBul_degC +
                 c[3] * TWetBul_degC * TWetBul_degC +
                 c[4] * TRan +
                 c[5] * TWetBul_degC * TRan +
                 c[6] * TWetBul_degC * TWetBul_degC * TRan +
                 c[7] * TRan * TRan +
                 c[8] * TWetBul_degC * TRan * TRan +
                 c[9] * TWetBul_degC * TWetBul_degC * TRan * TRan +
                 c[10] * liqGasRat +
                 c[11] * TWetBul_degC * liqGasRat +
                 c[12] * TWetBul_degC * TWetBul_degC * liqGasRat +
                 c[13] * TRan * liqGasRat +
                 c[14] * TWetBul_degC * TRan * liqGasRat +
                 c[15] * TWetBul_degC * TWetBul_degC * TRan * liqGasRat +
                 c[16] * TRan * TRan * liqGasRat +
                 c[17] * TWetBul_degC * TRan * TRan * liqGasRat +
                 c[18] * TWetBul_degC * TWetBul_degC * TRan * TRan * liqGasRat +
                 c[19] * liqGasRat * liqGasRat +
                 c[20] * TWetBul_degC * liqGasRat * liqGasRat +
                 c[21] * TWetBul_degC * TWetBul_degC * liqGasRat * liqGasRat +
                 c[22] * TRan * liqGasRat * liqGasRat +
                 c[23] * TWetBul_degC * TRan * liqGasRat * liqGasRat +
                 c[24] * TWetBul_degC * TWetBul_degC * TRan * liqGasRat * liqGasRat +
                 c[25] * TRan * TRan * liqGasRat * liqGasRat +
                 c[26] * TWetBul_degC * TRan * TRan * liqGasRat * liqGasRat +
                 c[27] * TWetBul_degC * TWetBul_degC * TRan * TRan * liqGasRat * liqGasRat;
            annotation (
              Documentation(info="<html>
<p>
Correlation for approach temperature for YorkCalc cooling tower model.
See <a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations.Examples.YorkCalc\">
Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations.Examples.YorkCalc</a> for the graph.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 12, 2011, by Michael Wetter:<br/>
Added <code>smoothMax</code> function to prevent division by zero.
</li>
<li>
May 14, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),smoothOrder=5);
          end yorkCalc;

          record BoundsYorkCalc
            "Coefficient data record for properties of York cooling tower model"
            extends
            Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations.BaseClasses.Bounds(
               TAirInWB_min = 273.15-34.4,
               TAirInWB_max = 273.15+26.7,
               TRan_min =     1.1,
               TRan_max =     22.2,
               TApp_min =     1.1,
               TApp_max =     40,
               FRWat_min =     0.75,
               FRWat_max =    1.25,
               liqGasRat_max = 8);

           annotation (Documentation(info="<html>
<p>
This data record contains the bounds for the YorkCalc cooling tower correlations.
</p>
</html>", revisions="<html>
<ul>
<li>
May 16, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end BoundsYorkCalc;

          package BaseClasses
          "Package with base classes for Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations"
            extends Modelica.Icons.BasesPackage;

            record Bounds "Coefficient data record for properties of cooling tower model"
              extends Modelica.Icons.Record;
              Modelica.Units.SI.Temperature TAirInWB_min
                "Minimum air inlet wet bulb temperature";
              Modelica.Units.SI.Temperature TAirInWB_max
                "Maximum air inlet wet bulb temperature";
              Modelica.Units.SI.Temperature TRan_min "Minimum range temperature";
              Modelica.Units.SI.Temperature TRan_max "Minimum range temperature";
              Modelica.Units.SI.Temperature TApp_min "Minimum approach temperature";
              Modelica.Units.SI.Temperature TApp_max "Minimum approach temperature";
              Real FRWat_min(final min=0, final max=1) "Minimum water flow ratio";
              Real FRWat_max(final min=0) "Maximum water flow ratio";
              Real liqGasRat_max(final min=0) "Maximum liquid to gas ratio";

             annotation (Documentation(info="<html>
<p>
This data record contains the bounds for the cooling tower correlations.
</p>
</html>",   revisions="<html>
<ul>
<li>
June 26, 2013 by Michael Wetter:<br/>
Corrected wrong type for <code>FRWat_min</code>, <code>FRWat_max</code>
and <code>liqGasRat_max</code>.
They were declared as <code>Modelica.Units.SI.MassFraction</code>,
which is incorrect as, for example, <code>FRWat_max</code> can be larger than one.
</li>
<li>
May 16, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Bounds;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations\">Buildings.Fluid.HeatExchangers.CoolingTowers.Correlations</a>.
</p>
</html>"));
          end BaseClasses;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains the performance curve for the
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc\">
Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc</a>
cooling tower model.
</p>
</html>"));
        end Correlations;

        package BaseClasses
        "Package with base classes for Buildings.Fluid.HeatExchangers.CoolingTowers"
          extends Modelica.Icons.BasesPackage;

          partial model CoolingTower "Base class for cooling towers"
            extends Buildings.Fluid.Interfaces.TwoPortHeatMassExchanger(
              redeclare final Buildings.Fluid.MixingVolumes.MixingVolume vol);

            Modelica.Blocks.Interfaces.RealOutput TLvg(
              final unit="K",
              displayUnit="degC") "Leaving water temperature"
              annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
            Modelica.Units.SI.HeatFlowRate Q_flow=preHea.Q_flow
              "Heat input into water circuit";

        protected
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHea
              "Prescribed heat flow"
              annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));
            Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor TVol
              "Water temperature in volume, leaving at port_b"
              annotation (Placement(transformation(extent={{20,-70},{40,-50}})));

          equation
            connect(preHea.port, vol.heatPort) annotation (Line(
                points={{-20,-60},{-16,-60},{-16,-10},{-9,-10}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(TVol.port, vol.heatPort) annotation (Line(
                points={{20,-60},{-16,-60},{-16,-10},{-9,-10}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(TVol.T, TLvg) annotation (Line(
                points={{41,-60},{110,-60}},
                color={0,0,127},
                smooth=Smooth.None));

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                             graphics={
                  Rectangle(
                    extent={{-70,86},{70,-80}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-102,5},{99,-5}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{76,-58},{100,-62}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{76,-60},{80,-4}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Text(
                   extent={{190,-6},{70,-56}},
                    textColor={0,0,0},
                    textString=DynamicSelect("", String(TLvg-273.15, format=".1f"))),
                  Text(
                    extent={{90,-20},{124,-58}},
                    textColor={0,0,127},
                    textString=DynamicSelect("TLvg", ""))}),
          defaultComponentName="cooTow",
              Documentation(info="<html>
<p>
Base class for a steady-state cooling tower.
The variable <code>TAirHT</code> is used to compute the heat transfer with the water side of the cooling tower.
For a dry cooling tower, this is equal to the dry-bulb temperature.
For a wet cooling tower, this is equal to the wet-bulb temperature.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 16, 2020, by Michael Wetter:<br/>
Refactored model to avoid mixing textual equations and connect statements.
</li>
<li>
July 12, 2011, by Michael Wetter:<br/>
Introduced common base class for
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc\">Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc</a>
and
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.FixedApproach\">Buildings.Fluid.HeatExchangers.CoolingTowers.FixedApproach</a>
so that they can be used as replaceable models.
</li>
<li>
May 12, 2011, by Michael Wetter:<br/>
Added binding equations for <code>Q_flow</code> and <code>mXi_flow</code>.
</li>
<li>
March 8, 2011, by Michael Wetter:<br/>
Removed base class and unused variables.
</li>
<li>
April 7, 2009, by Michael Wetter:<br/>
Changed interface to new Modelica.Fluid stream concept.
</li>
<li>
May 14, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end CoolingTower;

          model CoolingTowerVariableSpeed "Base class for cooling towers with variable speed fan"
            extends
            Buildings.Fluid.HeatExchangers.CoolingTowers.BaseClasses.CoolingTower;

            import cha =
              Buildings.Fluid.HeatExchangers.CoolingTowers.BaseClasses.Characteristics;

            parameter Modelica.Units.SI.Temperature TAirInWB_nominal=273.15 + 25.55
              "Nominal outdoor (air inlet) wetbulb temperature"
              annotation (Dialog(group="Heat transfer"));
            parameter Modelica.Units.SI.Temperature TWatIn_nominal
              "Nominal water inlet temperature" annotation (Dialog(group="Heat transfer"));
            parameter Modelica.Units.SI.Temperature TWatOut_nominal
              "Nominal water outlet temperature"
              annotation (Dialog(group="Heat transfer"));

            parameter Real fraFreCon(min=0, max=1, final unit="1") = 0.125
              "Fraction of tower capacity in free convection regime"
              annotation (Dialog(group="Heat transfer"));

            parameter Real fraPFan_nominal(unit="W/(kg/s)") = 275/0.15
              "Fan power divided by water mass flow rate at design condition"
              annotation (Dialog(group="Fan"));
            parameter Modelica.Units.SI.Power PFan_nominal=fraPFan_nominal*m_flow_nominal
              "Fan power" annotation (Dialog(group="Fan"));

            parameter Real yMin(min=0.01, max=1, final unit="1") = 0.3
              "Minimum control signal until fan is switched off (used for smoothing
    between forced and free convection regime)"
              annotation (Dialog(group="Fan"));

            replaceable parameter cha.fan fanRelPow(
                 r_V = {0, 0.1,   0.3,   0.6,   1},
                 r_P = {0, 0.1^3, 0.3^3, 0.6^3, 1})
              constrainedby cha.fan
              "Fan relative power consumption as a function of control signal, fanRelPow=P(y)/P(y=1)"
              annotation (
              choicesAllMatching=true,
              Placement(transformation(extent={{58,70},{78,90}})),
              Dialog(group="Fan"));

            Modelica.Blocks.Interfaces.RealInput TAir(
              final min=0,
              final unit="K",
              displayUnit="degC")
              "Entering air wet bulb temperature"
              annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

            Modelica.Blocks.Interfaces.RealInput y(unit="1") "Fan control signal"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

            Modelica.Blocks.Interfaces.RealOutput PFan(
              final quantity="Power",
              final unit="W")=
              Buildings.Utilities.Math.Functions.spliceFunction(
                  pos=cha.normalizedPower(per=fanRelPow, r_V=y, d=fanRelPowDer) * PFan_nominal,
                  neg=0,
                  x=y-yMin+yMin/20,
                  deltax=yMin/20)
              "Electric power consumed by fan"
              annotation (Placement(transformation(extent={{100,70},{120,90}}),
                  iconTransformation(extent={{100,70},{120,90}})));

        protected
            parameter Real fanRelPowDer[size(fanRelPow.r_V,1)]
              "Coefficients for fan relative power consumption as a function
    of control signal";

          initial equation
            // Check validity of relative fan power consumption at y=yMin and y=1
            assert(cha.normalizedPower(per=fanRelPow, r_V=yMin, d=fanRelPowDer) > -1E-4,
              "The fan relative power consumption must be non-negative for y=0."
            + "\n   Obtained fanRelPow(0) = "
            + String(cha.normalizedPower(per=fanRelPow, r_V=yMin, d=fanRelPowDer))
            + "\n   You need to choose different values for the parameter fanRelPow.");
            assert(abs(1-cha.normalizedPower(per=fanRelPow, r_V=1, d=fanRelPowDer))<1E-4,
            "The fan relative power consumption must be one for y=1."
            + "\n   Obtained fanRelPow(1) = "
            + String(cha.normalizedPower(per=fanRelPow, r_V=1, d=fanRelPowDer))
            + "\n   You need to choose different values for the parameter fanRelPow."
            + "\n   To increase the fan power, change fraPFan_nominal or PFan_nominal.");

            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Text(
                    extent={{-98,100},{-86,84}},
                    textColor={0,0,127},
                    textString="y"),
                  Text(
                    extent={{-104,70},{-70,32}},
                    textColor={0,0,127},
                    textString="TWB"),
                  Rectangle(
                    extent={{-100,81},{-70,78}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-54,62},{0,50}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{0,62},{54,50}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{78,82},{100,78}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{70,56},{82,52}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{78,54},{82,80}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{64,114},{98,76}},
                    textColor={0,0,127},
                    textString="PFan"),
                  Rectangle(
                    extent={{-100,41},{-70,38}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid)}),
              Diagram(coordinateSystem(preserveAspectRatio=false)),
              Documentation(
          info="<html>
<p>
Base model for a steady-state or dynamic cooling tower with a variable speed fan.
This base model is used for both the Merkel and York calculation.
</p>
</html>", revisions="<html>
<ul>
<li>
August 26, 2021, by Baptiste Ravache:<br/>
First implementation.
</li>
</ul>
</html>"));
          end CoolingTowerVariableSpeed;

          package Characteristics "Functions for fan characteristics"

            function normalizedPower "Normalized flow vs. normalized power characteristics for fan"
              extends Modelica.Icons.Function;
              input Characteristics.fan per "Fan relative power consumption";
              input Real r_V(unit="1") "Volumetric flow rate divided by nominal flow rate";
              input Real d[:] "Derivatives at support points for spline interpolation";
              output Modelica.Units.SI.Efficiency r_P(max=1) "Normalized power consumption";
          protected
            Integer n = size(per.r_V, 1) "Number of data points";
            Integer i "Integer to select data interval";

            algorithm
              if n == 1 then
                r_P := per.r_V[1];
              else
                // Compute index for power consumption
                i := 1;
                for j in 1:n-1 loop
                  if r_V > per.r_V[j] then
                    i := j;
                  end if;
                end for;

              // Extrapolate or interpolate the data
              r_P:=Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                x=r_V,
                x1=per.r_V[i],
                x2=per.r_V[i + 1],
                y1=per.r_P[i],
                y2=per.r_P[i + 1],
                y1d=d[i],
                y2d=d[i+1]);
              end if;

            annotation(smoothOrder=1,
            Documentation(info="<html>
<p>
This function computes the fan normalized power consumption
for a given normalized volume flow rate
and performance data. The fan normalized power consumption is
</p>
<p align=\"center\" style=\"font-style:italic;\">
r<sub>P</sub> = s(r<sub>V</sub>, d),
</p>
<p>
where
<i>r<sub>P</sub>;</i> is the normalized fan power consumption,
<i>r<sub>V</sub></i> is the normalized volume flow rate, and
<i>d</i> are performance data for fan or pump efficiency.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>",             revisions="<html>
<ul>
<li>
December, 22, 2019, by Kathryn Hinkelman:<br/>
Corrected cubic hermite spline calculation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1691\">
issue 1691</a>.
</li>
<li>
June 4, 2016, by Michael Wetter:<br/>
Change function from using <code>eta</code> to <code>r_P</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/522\">
issue 522</a>.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),             smoothOrder=1);
            end normalizedPower;

            record fan "Record for fan power consumption"
              extends Modelica.Icons.Record;
              parameter Real r_V[:](each min=0, each unit="1")
                "Volumetric flow rate divided by nominal flow rate at user-selected operating points";
              parameter Real r_P[size(r_V,1)](each max=1)
                "Fan relative power consumption at these flow rates such that r_P = 1 for r_V=1";
              annotation (Documentation(info="<html>
<p>
Data record for performance data that describe normalized volume flow rate versus
normalized fan power consumption.
The normalized volume flow rate <code>r_V</code> must be increasing, i.e.,
<code>r_V[i] &lt; r_V[i+1]</code>.
Both vectors, <code>r_V</code> and <code>r_P</code>
must have the same size.
</p>
</html>",   revisions="<html>
<ul>
<li>
June 4, 2016, by Michael Wetter:<br/>
Changed <code>eta</code> to <code>r_P</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/522\">
issue 522</a>.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end fan;
            annotation (Documentation(info="<html>
<p>
This package implements the performance curve for the fans,
and a record for performance data that can be used with the performance
curve.
</p>
</html>", revisions="<html>
<ul>
<li>
June 4, 2016, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
September 29, 2011, by Michael Wetter:<br/>
New implementation due to changes from polynomial to cubic hermite splines.
</li>
</ul>
</html>"));
          end Characteristics;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers\">Buildings.Fluid.HeatExchangers.CoolingTowers</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains components models for cooling towers.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.FixedApproach\">
Buildings.Fluid.HeatExchangers.CoolingTowers.FixedApproach</a>
computes a fixed approach temperature.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc\">
Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc</a>
computes the cooling tower performance based the York formula.
</p>
</html>"));
      end CoolingTowers;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.HeatExchangers"
        extends Modelica.Icons.BasesPackage;

        model HADryCoil
          "Sensible convective heat transfer model for air to water coil"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.Units.SI.ThermalConductance UA_nominal(min=0)
            "Thermal conductance at nominal flow"
            annotation (Dialog(tab="General", group="Nominal condition"));

          parameter Modelica.Units.SI.MassFlowRate m_flow_nominal_w
            "Water mass flow rate"
            annotation (Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.Units.SI.MassFlowRate m_flow_nominal_a
            "Air mass flow rate"
            annotation (Dialog(tab="General", group="Nominal condition"));

          Modelica.Blocks.Interfaces.RealInput m1_flow(final unit="kg/s") "Mass flow rate medium 1"
            annotation (Placement(transformation(extent={{-120,60},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput m2_flow(final unit="kg/s") "Mass flow rate medium 2"
            annotation (Placement(transformation(extent={{-120,-80},{-100,-60}})));
          Modelica.Blocks.Interfaces.RealInput T_1(final unit="K") "Temperature medium 1"
            annotation (Placement(transformation(extent={{-120,20},{-100,40}})));
          Modelica.Blocks.Interfaces.RealInput T_2(final unit="K") "Temperature medium 2"
            annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));

          Modelica.Blocks.Interfaces.RealOutput hA_1(final unit="W/K")
            "Convective heat transfer medium 1" annotation (Placement(transformation(
                  extent={{100,60},{120,80}})));
          Modelica.Blocks.Interfaces.RealOutput hA_2(final unit="W/K")
            "Convective heat transfer medium 2" annotation (Placement(transformation(
                  extent={{100,-80},{120,-60}})));

          parameter Real r_nominal(min=0)=0.5
            "Ratio between air-side and water-side convective heat transfer coefficient"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.Units.SI.ThermalConductance hA_nominal_w(min=0) =
            UA_nominal*(r_nominal + 1)/r_nominal
            "Water side convective heat transfer coefficient"
            annotation (Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.Units.SI.ThermalConductance hA_nominal_a(min=0) =
            r_nominal*hA_nominal_w
            "Air side convective heat transfer coefficient, including fin resistance"
            annotation (Dialog(tab="General", group="Nominal condition"));
          parameter Real n_w(min=0, max=1)=0.85
            "Water-side exponent for convective heat transfer coefficient, h~m_flow^n";
          parameter Real n_a(min=0, max=1)=0.8
            "Air-side exponent for convective heat transfer coefficient, h~m_flow^n";
          parameter Modelica.Units.SI.Temperature T0_w=
              Modelica.Units.Conversions.from_degC(20) "Water temperature"
            annotation (Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.Units.SI.Temperature T0_a=
              Modelica.Units.Conversions.from_degC(20) "Air temperature"
            annotation (Dialog(tab="General", group="Nominal condition"));
          parameter Boolean waterSideFlowDependent=true
            "Set to false to make water-side hA independent of mass flow rate"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean airSideFlowDependent = true
            "Set to false to make air-side hA independent of mass flow rate"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean waterSideTemperatureDependent = true
            "Set to false to make water-side hA independent of temperature"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean airSideTemperatureDependent = true
            "Set to false to make air-side hA independent of temperature"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
      protected
          Real x_a(min=0)
            "Factor for air side temperature dependent variation of heat transfer coefficient";
          Real x_w(min=0)
            "Factor for water side temperature dependent variation of heat transfer coefficient";
          parameter Real s_w(min=0, fixed=false)
            "Coefficient for temperature dependence of water side heat transfer coefficient";
          Real fm_w "Fraction of actual to nominal mass flow rate";
          Real fm_a "Fraction of actual to nominal mass flow rate";
        initial equation
          s_w =if waterSideTemperatureDependent then 0.014/(1 + 0.014*
            Modelica.Units.Conversions.to_degC(T0_w)) else 1;
        equation
          fm_w = if waterSideFlowDependent then
                      m1_flow / m_flow_nominal_w else 1;
          fm_a = if airSideFlowDependent then
                      m2_flow / m_flow_nominal_a else 1;
          x_w = if waterSideTemperatureDependent then
                 1 + s_w * (T_1-T0_w) else
                      1;
          x_a = if airSideTemperatureDependent then
                 1 + 7.8532E-4 * (T_2-T0_a) else
                      1;
          if waterSideFlowDependent then
            hA_1 = x_w * hA_nominal_w
                       * Buildings.Utilities.Math.Functions.regNonZeroPower(fm_w, n_w, 0.1);
          else
            hA_1 = x_w * hA_nominal_w;
          end if;

          if airSideFlowDependent then
            hA_2 = x_a * hA_nominal_a
                       * Buildings.Utilities.Math.Functions.regNonZeroPower(fm_a, n_a, 0.1);
          else
            hA_2 = x_a * hA_nominal_a;
          end if;
        annotation (Documentation(info="<html>
<p>
Model for sensible convective heat transfer coefficients for an air to water coil.
</p>
<p>
This model computes the convective heat transfer coefficient
for an air to water coil.
The parameters allow a user to enable or disable, individually
for each medium, the mass flow and/or the temperature dependence
of the convective heat transfer coefficients.
For a detailed explanation of the equation, see
the references below.
</p>
<h4>References</h4>
<ul>
<li>
Wetter Michael,
<a href=\"http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=7353\">
Simulation model finned water-air-coil without condensation</a>,
LBNL-42355,
Lawrence Berkeley National Laboratory,
Berkeley, CA, 1999.
</li>
<li>
Wetter Michael,
<a href=\"http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=7352\">
Simulation model air-to-air plate heat exchanger</a>,
LBNL-42354,
Lawrence Berkeley National Laboratory,
Berkeley, CA, 1999.
</li>
</ul>
</html>",
        revisions="<html>
<ul>
<li>
April 9, 2017, by Michael Wetter:<br/>
Corrected coefficient in Taylor expansion of <code>x_a</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/698\">#698</a>.
</li>
<li>
June 8, 2010, by Michael Wetter:<br/>
Fixed bug in computation of <code>s_w</code>.
The old implementation used the current inlet water temperature instead
of the design condition that corresponds to <code>UA_nominal</code>.
</li>
<li>
April 16, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={            Text(
                  extent={{-60,90},{66,0}},
                  textColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="hA"),
                Ellipse(
                  extent={{-32,-10},{-12,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{34,-10},{54,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{0,-10},{20,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-64,-10},{-44,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-48,-40},{-28,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-16,-40},{4,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{16,-40},{36,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{50,-40},{70,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-68,-66},{-48,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-36,-66},{-16,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,-66},{16,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{30,-66},{50,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}));
        end HADryCoil;

        model HexElementSensible
          "Element of a heat exchanger with no humidity condensation"
          extends Buildings.Fluid.HeatExchangers.BaseClasses.PartialHexElement(
           redeclare final Buildings.Fluid.MixingVolumes.BaseClasses.MixingVolumeHeatPort vol1(
             final energyDynamics=energyDynamics,
             final massDynamics=energyDynamics,
             final initialize_p=initialize_p1,
             prescribedHeatFlowRate=false),
           redeclare final Buildings.Fluid.MixingVolumes.BaseClasses.MixingVolumeHeatPort vol2(
             final energyDynamics=energyDynamics,
             final massDynamics=energyDynamics,
             final initialize_p=initialize_p2,
             prescribedHeatFlowRate=false));

          annotation (
            Documentation(info="<html>
<p>
Element of a heat exchanger with humidity condensation and
with dynamics of the fluids and the solid.
</p>
<p>
See
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.PartialHexElement\">
Buildings.Fluid.HeatExchangers.BaseClasses.PartialHexElement</a>
for a description of the physics.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 18, 2014, by Michael Wetter:<br/>
Added initialization for <code>mas</code> to avoid a warning during translation.
</li>
<li>
September 11, 2013, by Michael Wetter:<br/>
Separated old model into one for dry and for wet heat exchangers.
This was done to make the coil compatible with OpenModelica.
</li>
<li>
May 1, 2013, by Michael Wetter:<br/>
Changed the redeclaration of <code>vol2</code> to be replaceable,
as <code>vol2</code> is replaced in some models.
</li>
<li>
April 19, 2013, by Michael Wetter:<br/>
Made instance <code>MassExchange</code> replaceable, rather than
conditionally removing the model, to avoid a warning
during translation because of unused connector variables.
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Removed assignment of medium in <code>vol1</code> and <code>vol2</code>,
since this assignment is already done in the base class using the
<code>final</code> modifier.
</li>
<li>
August 12, 2008, by Michael Wetter:<br/>
Introduced option to compute each medium using a steady state model or
a dynamic model.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end HexElementSensible;

        partial model PartialEffectiveness
          "Partial model to implement heat exchangers based on effectiveness model"
          extends Fluid.Interfaces.StaticFourPortHeatMassExchanger(
            prescribedHeatFlowRate1=true,
            prescribedHeatFlowRate2=true,
            show_T=false);

          Medium1.Temperature T_in1 = if allowFlowReversal1 then
            fra_a1 * Medium1.temperature(state_a1_inflow) + fra_b1 * Medium1.temperature(state_b1_inflow) else
            Medium1.temperature(state_a1_inflow)
            "Inlet temperature medium 1";
          Medium2.Temperature T_in2 = if allowFlowReversal2 then
            fra_a2 * Medium2.temperature(state_a2_inflow) + fra_b2 * Medium2.temperature(state_b2_inflow) else
            Medium2.temperature(state_a2_inflow)
            "Inlet temperature medium 2";
          Modelica.Units.SI.ThermalConductance C1_flow(
            min=0,
            nominal=m1_flow_nominal*cp1_default)=abs(m1_flow)*(if
              allowFlowReversal1 then fra_a1*Medium1.specificHeatCapacityCp(
              state_a1_inflow) + fra_b1*Medium1.specificHeatCapacityCp(state_b1_inflow)
               else Medium1.specificHeatCapacityCp(state_a1_inflow))
            "Heat capacity flow rate medium 1";
          Modelica.Units.SI.ThermalConductance C2_flow(
            min=0,
            nominal=m2_flow_nominal*cp2_default)=abs(m2_flow)*(if
              allowFlowReversal2 then fra_a2*Medium2.specificHeatCapacityCp(
              state_a2_inflow) + fra_b2*Medium2.specificHeatCapacityCp(state_b2_inflow)
               else Medium2.specificHeatCapacityCp(state_a2_inflow))
            "Heat capacity flow rate medium 2";
          Modelica.Units.SI.ThermalConductance CMin_flow(min=0) = min(C1_flow, C2_flow)
            "Minimum heat capacity flow rate";
          Modelica.Units.SI.HeatFlowRate QMax_flow=CMin_flow*(T_in2 - T_in1)
            "Maximum heat flow rate into medium 1";
      protected
          parameter Real delta=1E-3 "Parameter used for smoothing";

          parameter Modelica.Units.SI.SpecificHeatCapacity cp1_default =
            Medium1.specificHeatCapacityCp(Medium1.setState_pTX(
              Medium1.p_default,
              Medium1.T_default,
              Medium1.X_default))
            "Specific heat capacity of medium 1 at default medium state";
          parameter Modelica.Units.SI.SpecificHeatCapacity cp2_default =
            Medium2.specificHeatCapacityCp(Medium2.setState_pTX(
              Medium2.p_default,
              Medium2.T_default,
              Medium2.X_default))
            "Specific heat capacity of medium 2 at default medium state";
          parameter Modelica.Units.SI.ThermalConductance CMin_flow_small =
            min(m1_flow_small*cp1_default, m2_flow_small*cp2_default)
            "Small value for smoothing of minimum heat capacity flow rate";
          Real fra_a1(min=0, max=1) = if allowFlowReversal1
            then Modelica.Fluid.Utilities.regStep(
              m1_flow,
              1,
              0,
              m1_flow_small)
            else 1
            "Fraction of incoming state taken from port a1 (used to avoid excessive calls to regStep)";
          Real fra_b1(min=0, max=1) = if allowFlowReversal1
            then 1-fra_a1
            else 0
            "Fraction of incoming state taken from port b1 (used to avoid excessive calls to regStep)";
          Real fra_a2(min=0, max=1) = if allowFlowReversal2
            then Modelica.Fluid.Utilities.regStep(
              m2_flow,
              1,
              0,
              m2_flow_small)
            else 1
            "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b2(min=0, max=1) = if allowFlowReversal2
            then 1-fra_a2
            else 0
            "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-70,78},{70,-80}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Partial model to implement heat exchanger models.
</p>
<p>
Classes that extend this model need to implement heat and
mass balance equations in a form like
</p>
<pre>
  // transferred heat
  Q1_flow = eps * QMax_flow;
  // no heat loss to ambient
  0 = Q1_flow + Q2_flow;
  // no mass exchange
  mXi1_flow = zeros(Medium1.nXi);
  mXi2_flow = zeros(Medium2.nXi);
</pre>
<p>
Thus, if medium 1 is heated in this device, then <code>Q1_flow &gt; 0</code>
and <code>QMax_flow &gt; 0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2023, by Michael Wetter:<br/>
Set nominal and min attributes for capacity flow rates.<br/>
Moved assignments from <code>initial equation</code> to parameter declaration.
This avoids a warning in Dymola 2023x about non-literal nominal values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3360\">#3360</a>.
</li>
<li>
February 21, 2019, by Filip Jorissen:<br/>
Revised implementation of all equations
such that a binding equation is used.
I.e. we set the variable value at the variable definition
instead of using the equation section.
This allows overwriting the equation
when extending the model.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1102\">#1102</a>.
</li>
<li>
April 30, 2018, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate1=true</code> and
<code>prescribedHeatFlowRate2=true</code>.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/907\">#907</a>.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Changed type of <code>T_in1</code> and <code>T_in2</code>
to <code>Medium1.Temperature</code> and <code>Medium2.Temperature</code>
to avoid an error because of conflicting start values if
<a href=\"modelica://Buildings.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl\">
Buildings.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl</a>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
October 8, 2011, by Michael Wetter:<br/>
Set <code>show_T=false</code> to avoid state events near zero flow.
</li>
<li>
August 31, 2011, by Michael Wetter:<br/>
Removed unused variables <code>gai1</code> and <code>gai2</code>.
</li>
<li>
February 12, 2010, by Michael Wetter:<br/>
Changed model structure to implement effectiveness-NTU model.
</li>
<li>
January 28, 2010, by Michael Wetter:<br/>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br/>
Changed computation of inlet temperatures to use
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialEffectiveness;

        model PartialHexElement "Element of a heat exchanger 2"
          extends Buildings.Fluid.Interfaces.FourPortHeatMassExchanger;

          parameter Boolean initialize_p1 = not Medium1.singleState
            "Set to true to initialize the pressure of volume 1"
            annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean initialize_p2 = not Medium2.singleState
            "Set to true to initialize the pressure of volume 2"
            annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

          parameter Modelica.Units.SI.ThermalConductance UA_nominal
            "Thermal conductance at nominal flow, used to compute time constant"
            annotation (Dialog(group="Nominal condition"));
          parameter Modelica.Units.SI.Time tau_m(min=0) = 60
            "Time constant of metal at nominal UA value" annotation (Dialog(
              tab="General",
              group="Nominal condition",
              enable=not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial)));
          parameter Modelica.Units.SI.HeatCapacity C=2*UA_nominal*tau_m
            "Heat capacity of metal (= cp*m)";

          Modelica.Blocks.Interfaces.RealInput Gc_1
            "Signal representing the convective thermal conductance medium 1 in [W/K]"
            annotation (Placement(transformation(
                origin={-40,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Modelica.Blocks.Interfaces.RealInput Gc_2
            "Signal representing the convective thermal conductance medium 2 in [W/K]"
            annotation (Placement(transformation(
                origin={40,-100},
                extent={{-20,-20},{20,20}},
                rotation=90)));

          Modelica.Thermal.HeatTransfer.Components.HeatCapacitor mas(
            C=C,
            T(stateSelect=StateSelect.always,
              fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)),
            der_T( fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial)))
            if not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
            "Mass of metal"
            annotation (Placement(transformation(
                origin={-82,0},
                extent={{-10,-10},{10,10}},
                rotation=90)));

          Modelica.Thermal.HeatTransfer.Components.Convection con1(dT(min=-200))
            "Convection (and conduction) on fluid side 1"
            annotation (Placement(transformation(extent={{-50,50},{-30,70}})));
          Modelica.Thermal.HeatTransfer.Components.Convection con2(dT(min=-200))
            "Convection (and conduction) on fluid side 2"
            annotation (Placement(transformation(extent={{-50,-30},{-30,-50}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPor1
            "Heat port for heat exchange with the control volume 1"
            annotation (Placement(transformation(extent={{-10,90},{10,110}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPor2
            "Heat port for heat exchange with the control volume 2"
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
        equation
          connect(Gc_1, con1.Gc) annotation (Line(points={{-40,100},{-40,76},{-40,70}},
                            color={0,0,127}));
          connect(Gc_2, con2.Gc) annotation (Line(points={{40,-100},{40,-76},{-40,-76},
                  {-40,-50}},                   color={0,0,127}));
          connect(con1.solid,mas. port) annotation (Line(points={{-50,60},{-66,60},{-66,
                  0},{-70,0},{-72,0},{-72,-6.12323e-16}},
                                   color={191,0,0}));
          connect(con1.fluid, vol1.heatPort) annotation (Line(
              points={{-30,60},{-10,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(con2.fluid, vol2.heatPort) annotation (Line(
              points={{-30,-40},{20,-40},{20,-60},{12,-60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(con2.solid, con1.solid) annotation (Line(
              points={{-50,-40},{-66,-40},{-66,60},{-50,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(vol1.heatPort, heaPor1) annotation (Line(points={{-10,60},{-20,60},{-20,
                  88},{0,88},{0,100}}, color={191,0,0}));
          connect(vol2.heatPort, heaPor2) annotation (Line(points={{12,-60},{18,-60},{20,
                  -60},{20,-90},{0,-90},{0,-100}}, color={191,0,0}));
          annotation (
            Documentation(info="<html>
<p>
Element of a heat exchanger
with dynamics of the fluids and the solid.
The <i>hA</i> value for both fluids is an input.
The driving force for the heat transfer is the temperature difference
between the fluid volumes and the solid.
</p>
<p>
The heat capacity <i>C</i> of the metal is assigned as follows.
Suppose the metal temperature is governed by
</p>
<p align=\"center\" style=\"font-style:italic;\">
  C dT &frasl; dt = (hA)<sub>1</sub> (T<sub>1</sub> - T)
  + (hA)<sub>2</sub> (T<sub>2</sub> - T)
</p>
<p>
where <i>hA</i> are the convective heat transfer coefficients times
heat transfer area that also take
into account heat conduction in the heat exchanger fins and
<i>T<sub>1</sub></i> and <i>T<sub>2</sub></i> are the medium temperatures.
Assuming <i>(hA)<sub>1</sub>=(hA)<sub>2</sub></i>,
this equation can be rewritten as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  C dT &frasl; dt =
  2 (UA)<sub>0</sub> ( (T<sub>1</sub> - T) + (T<sub>2</sub> - T) )

</p>
<p>
where <i>(UA)<sub>0</sub></i> is the <i>UA</i> value at nominal conditions.
Hence we set the heat capacity of the metal
to
</p>
<p align=\"center\" style=\"font-style:italic;\">
C = 2 (UA)<sub>0</sub> &tau;<sub>m</sub>
</p>
<p>
where <i>&tau;<sub>m</sub></i> is the time constant that the metal
of the heat exchanger has if the metal is approximated by a lumped
thermal mass.
</p>
<p>
<b>Note:</b> This model is introduced to allow the instances
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HexElementLatent\">
Buildings.Fluid.HeatExchangers.BaseClasses.HexElementLatent
</a>
and
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HexElementSensible\">
Buildings.Fluid.HeatExchangers.BaseClasses.HexElementSensible
</a>
to redeclare the volume as <code>final</code>, thereby avoiding
that a GUI displays the volume as a replaceable component.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added <code>prescribedHeatFlowRate=false</code> for both volumes.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> of the Annex 60 library.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameters <code>initialize_p1</code> and <code>initialize_p2</code>.
This is required to enable the coil models to initialize the pressure in the
first volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
July 2, 2014, by Michael Wetter:<br/>
Conditionally removed the mass of the metall <code>mas</code>.
</li>
<li>
June 26, 2014, by Michael Wetter:<br/>
Removed parameters <code>energyDynamics1</code> and <code>energyDynamics2</code>,
and used instead of these two parameters <code>energyDynamics</code>.
This was done as this complexity is not required.
</li>
<li>
September 11, 2013, by Michael Wetter:<br/>
Separated old model into one for dry and for wet heat exchangers.
This was done to make the coil compatible with OpenModelica.
</li>
<li>
May 1, 2013, by Michael Wetter:<br/>
Changed the redeclaration of <code>vol2</code> to be replaceable,
as <code>vol2</code> is replaced in some models.
</li>
<li>
April 19, 2013, by Michael Wetter:<br/>
Made instance <code>MassExchange</code> replaceable, rather than
conditionally removing the model, to avoid a warning
during translation because of unused connector variables.
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Removed assignment of medium in <code>vol1</code> and <code>vol2</code>,
since this assignment is already done in the base class using the
<code>final</code> modifier.
</li>
<li>
August 12, 2008, by Michael Wetter:<br/>
Introduced option to compute each medium using a steady state model or
a dynamic model.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-84,114},{-62,86}},
                  textColor={0,0,255},
                  textString="h"), Text(
                  extent={{58,-92},{84,-120}},
                  textColor={0,0,255},
                  textString="h")}));
        end PartialHexElement;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.HeatExchangers\">Buildings.Fluid.HeatExchangers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains models for heat exchangers with and without humidity condensation.
</html>"));
    end HeatExchangers;

    package MixingVolumes "Package with mixing volumes"
      extends Modelica.Icons.VariantsPackage;

      model MixingVolume
        "Mixing volume with inlet and outlet ports (flow reversal is allowed)"
        extends Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          final initialize_p = not Medium.singleState,
          steBal(final use_C_flow = use_C_flow),
          dynBal(final use_C_flow = use_C_flow));

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
          T(start=T_start)) "Heat port for heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

      equation
        connect(heaFloSen.port_a, heatPort)
          annotation (Line(points={{-90,0},{-96,0},{-100,0}}, color={191,0,0}));
        connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},
                {12,-60},{12,6},{18,6}}, color={0,0,127}));
        connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},
                {52,-60},{52,6},{58,6}}, color={0,0,127}));
        annotation (
      defaultComponentName="vol",
      Documentation(info="<html>
<p>
This model represents an instantaneously mixed volume.
Potential and kinetic energy at the port are neglected,
and there is no pressure drop at the ports.
The volume can exchange heat through its <code>heatPort</code>.
</p>
<p>
The volume can be parameterized as a steady-state model or as
dynamic model.</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://Buildings.Fluid.Sensors.Examples.PPM\">Buildings.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
<h4>Implementation</h4>
<p>
If the model is operated in steady-state and has two fluid ports connected,
then the same energy and mass balance implementation is used as in
steady-state component models, i.e., the use of <code>actualStream</code>
is not used for the properties at the port.
</p>
<p>
The implementation of these balance equations is done in the instances
<code>dynBal</code> for the dynamic balance and <code>steBal</code>
for the steady-state balance. Both models use the same input variables:
</p>
<ul>
<li>
The variable <code>Q_flow</code> is used to add sensible <i>and</i> latent heat to the fluid.
For example, <code>Q_flow</code> participates in the steady-state energy balance<pre>
    port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
</pre>
where <code>m_flowInv</code> approximates the expression <code>1/m_flow</code>.
</li>
<li>
The variable <code>mXi_flow</code> is used to add a species mass flow rate to the fluid.
</li>
</ul>
<p>
For the rationale of selecting different energy and mass balances, and for the
use of <code>prescribedHeatFlowRate</code>, see the documentation of
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://Buildings.Fluid.HeatExchangers.HeaterCooler_u\">
Buildings.Fluid.HeatExchangers.HeaterCooler_u</a> and
<a href=\"modelica://Buildings.Fluid.Humidifiers.Humidifier_u\">
Buildings.Fluid.Humidifiers.Humidifier_u</a>.
</p>

</html>",       revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Changed code for handling trace substance insertions using input <code>C_flow</code>.
</li>
<li>
May 1, 2015 by Michael Wetter<br/>
Set <code>final</code> keyword for <code>masExc(final k=0)</code>.
This addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/230\">
issue 230</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"modelica://Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}),
            graphics={
            Text(
                extent={{-152,100},{148,140}},
                textString="%name",
                textColor={0,0,255})}));
      end MixingVolume;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.MixingVolumes"
        extends Modelica.Icons.BasesPackage;

        model MixingVolumeHeatPort
          "Mixing volume with heat port and initialize_p not set to final"
          extends Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume;
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
              T(start=T_start)) "Heat port for heat exchange with the control volume"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        equation
            connect(heaFloSen.port_a, heatPort)
              annotation (Line(points={{-90,0},{-100,0},{-100,0}}, color={191,0,0}));

          annotation (
          defaultComponentName="vol",
          Documentation(info="<html>
<p>
Mixing volume with a heat port.
</p>
<p>
This model is identical to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>,
except that it has a heat port.
</p>
<p>
Note that this model is typically only used to implement new component models that
have staggered volumes.
In contrast to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>, it does
not set <code>initialize_p</code> to <code>final</code> in order
for this model to be usable in staggered volumes which require one
pressure to be set to <code>initialize_p = not Medium.singleState</code>
and all others to <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 9, 2021, by Michael Wetter:<br/>
Corrected annotation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1547\">IBPSA, issue 1547</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
First implementation for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
</ul>
</html>"));
        end MixingVolumeHeatPort;

        model PartialMixingVolume
          "Partial mixing volume with inlet and outlet ports (flow reversal is allowed)"

          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
          parameter Boolean initialize_p = not Medium.singleState
            "= true to set up initial equations for pressure"
            annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

          // We set prescribedHeatFlowRate=false so that the
          // volume works without the user having to set this advanced parameter,
          // but to get high robustness, a user can set it to the appropriate value
          // as described in the info section.
          constant Boolean prescribedHeatFlowRate = false
            "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";

          constant Boolean simplify_mWat_flow = true
            "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

          parameter Modelica.Units.SI.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
          // Port definitions
          parameter Integer nPorts=0 "Number of ports"
            annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
          parameter Modelica.Units.SI.MassFlowRate m_flow_small(min=0) = 1E-4*abs(
            m_flow_nominal) "Small mass flow rate for regularization of zero flow"
            annotation (Dialog(tab="Advanced"));
          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports."
            annotation(Dialog(tab="Assumptions"), Evaluate=true);
          parameter Modelica.Units.SI.Volume V "Volume";
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
              redeclare each package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-40,-10},{40,10}},
              origin={0,-100})));

          Medium.Temperature T = Medium.temperature_phX(
            p=p,
            h=hOut_internal,
            X=if Medium.reducedX then cat(1, Xi, {1-sum(Xi)}) else Xi)
            "Temperature of the fluid";
          Modelica.Blocks.Interfaces.RealOutput U(unit="J")
            "Internal energy of the component";
          Modelica.Units.SI.Pressure p=if nPorts > 0 then ports[1].p else p_start
            "Pressure of the fluid";
          Modelica.Blocks.Interfaces.RealOutput m(unit="kg") "Mass of the component";
          Modelica.Units.SI.MassFraction Xi[Medium.nXi]=XiOut_internal
            "Species concentration of the fluid";
          Modelica.Blocks.Interfaces.RealOutput mXi[Medium.nXi](each unit="kg")
            "Species mass of the component";
          Medium.ExtraProperty C[Medium.nC](nominal=C_nominal) = COut_internal
            "Trace substance mixture content";
          Modelica.Blocks.Interfaces.RealOutput mC[Medium.nC](each unit="kg")
            "Trace substance mass of the component";

      protected
          Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation steBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium=Medium,
            final m_flow_nominal = m_flow_nominal,
            final allowFlowReversal = allowFlowReversal,
            final m_flow_small = m_flow_small,
            final prescribedHeatFlowRate=prescribedHeatFlowRate,
            hOut(start=Medium.specificEnthalpy_pTX(
                         p=p_start,
                         T=T_start,
                         X=X_start)))
              if useSteadyStateTwoPort "Model for steady-state balance if nPorts=2"
                annotation (Placement(transformation(extent={{20,0},{40,20}})));
          Buildings.Fluid.Interfaces.ConservationEquation dynBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium = Medium,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final p_start=p_start,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final C_nominal=C_nominal,
            final fluidVolume = V,
            final initialize_p = initialize_p,
            m(start=V*rho_start),
            nPorts=nPorts,
            final mSenFac=mSenFac)
              if not useSteadyStateTwoPort "Model for dynamic energy balance"
            annotation (Placement(transformation(extent={{60,0},{80,20}})));

          // Density at start values, used to compute initial values and start guesses
          parameter Modelica.Units.SI.Density rho_start=Medium.density(
            state=state_start) "Density, used to compute start and guess values";
          final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
          // Density at medium default values, used to compute the size of control volumes
          final parameter Modelica.Units.SI.Density rho_default=Medium.density(
            state=state_default) "Density, used to compute fluid mass";
          final parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
              T=T_start,
              p=p_start,
              X=X_start[1:Medium.nXi]) "Medium state at start values";
          // See info section for why prescribedHeatFlowRate is used here.
          // The condition below may only be changed if StaticTwoPortConservationEquation
          // contains a correct solution for all foreseeable parameters/inputs.
          // See Buildings, issue 282 for a discussion.
          final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
              (prescribedHeatFlowRate or (not allowFlowReversal)) and (
              energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
            "Flag, true if the model has two ports only and uses a steady state balance"
            annotation (Evaluate=true);
          // Outputs that are needed to assign the medium properties
          Modelica.Blocks.Interfaces.RealOutput hOut_internal(unit="J/kg")
            "Internal connector for leaving temperature of the component";
          Modelica.Blocks.Interfaces.RealOutput XiOut_internal[Medium.nXi](each unit="1")
            "Internal connector for leaving species concentration of the component";
          Modelica.Blocks.Interfaces.RealOutput COut_internal[Medium.nC](each unit="1")
            "Internal connector for leaving trace substances of the component";

          Buildings.HeatTransfer.Sources.PrescribedTemperature preTem
            "Port temperature"
            annotation (Placement(transformation(extent={{-40,-10},{-60,10}})));
          Modelica.Blocks.Sources.RealExpression portT(y=T) "Port temperature"
            annotation (Placement(transformation(extent={{-10,-10},{-30,10}})));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen
            "Heat flow sensor"
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
        equation
          ///////////////////////////////////////////////////////////////////////////
          // asserts
          if not allowFlowReversal then
            assert(ports[1].m_flow > -m_flow_small,
          "In " + getInstanceName() + ": Model has flow reversal,
  but the parameter allowFlowReversal is set to false.
  m_flow_small    = "         + String(m_flow_small) + "
  ports[1].m_flow = "         + String(ports[1].m_flow) + "
");       end if;
          // Actual definition of port variables.
          //
          // If the model computes the energy and mass balances as steady-state,
          // and if it has only two ports,
          // then we use the same base class as for all other steady state models.
          if useSteadyStateTwoPort then
          connect(steBal.port_a, ports[1]) annotation (Line(
              points={{20,10},{10,10},{10,-20},{0,-20},{0,-20},{0,-100}},
              color={0,127,255}));

          connect(steBal.port_b, ports[2]) annotation (Line(
              points={{40,10},{46,10},{46,-20},{0,-20},{0,-100}},
              color={0,127,255}));
            U=0;
            mXi=zeros(Medium.nXi);
            m=0;
            mC=zeros(Medium.nC);
            connect(hOut_internal,  steBal.hOut);
            connect(XiOut_internal, steBal.XiOut);
            connect(COut_internal,  steBal.COut);
          else
              connect(dynBal.ports, ports) annotation (Line(
              points={{70,0},{70,-80},{62,-80},{2.22045e-15,-80},{2.22045e-15,-90},{2.22045e-15,
                    -100}},
              color={0,127,255}));
            connect(U,dynBal.UOut);
            connect(mXi,dynBal.mXiOut);
            connect(m,dynBal.mOut);
            connect(mC,dynBal.mCOut);
            connect(hOut_internal,  dynBal.hOut);
            connect(XiOut_internal, dynBal.XiOut);
            connect(COut_internal,  dynBal.COut);
          end if;

          connect(portT.y, preTem.T)
            annotation (Line(points={{-31,0},{-38,0}},   color={0,0,127}));
          connect(heaFloSen.port_b, preTem.port)
            annotation (Line(points={{-70,0},{-65,0},{-60,0}},    color={191,0,0}));
          connect(heaFloSen.Q_flow, steBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-16},{6,-16},{6,18},{18,18}},
                                             color={0,0,127}));
          connect(heaFloSen.Q_flow, dynBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-10},{-80,-16},{6,-16},{6,24},{50,24},{50,16},{58,16}},
                                                                       color={0,0,127}));
          annotation (
        defaultComponentName="vol",
        Documentation(info="<html>
<p>
This is a partial model of an instantaneously mixed volume.
It is used as the base class for all fluid volumes of the package
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">
Buildings.Fluid.MixingVolumes</a>.
</p>


<h4>Typical use and important parameters</h4>
<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
Set the constant <code>simplify_mWat_flow = true</code> to simplify the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
to
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector
for the trace substance flow rate.
</p>
<h4>Implementation</h4>
<p>
If the model is (i) operated in steady-state,
(ii) has two fluid ports connected, and
(iii) <code>prescribedHeatFlowRate=true</code> or <code>allowFlowReversal=false</code>,
then the model uses
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
in order to use
the same energy and mass balance implementation as is used as in
steady-state component models.
In this situation, the functions <code>inStream</code> are used for the two
flow directions rather than the function
<code>actualStream</code>, which is less efficient.
However, the use of <code>inStream</code> has the disadvantage
that <code>hOut</code> has to be computed, in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>,
using
</p>
<pre>
if allowFlowReversal then
  hOut = Buildings.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                    y2=port_a.h_outflow,
                                                    x=port_a.m_flow,
                                                    x_small=m_flow_small/1E3);
else
  hOut = port_b.h_outflow;
end if;
</pre>
<p>
Hence, for <code>allowFlowReversal=true</code>, if <code>hOut</code>
were to be used to compute the temperature that
drives heat transfer such as by conduction,
then the heat transfer would depend on upstream and the <i>downstream</i>
temperatures for small mass flow rates.
This can give wrong results. Consider for example a mass flow rate that is positive
but very close to zero. Suppose the upstream temperature is <i>20</i>&deg;C,
the downstream temperature is <i>10</i>&deg;C, and the heat port is
connected through a heat conductor to a boundary condition of <i>20</i>&deg;C.
Then, <code>hOut = (port_b.h_outflow + port_a.h_outflow)/2</code> and hence
the temperature <code>heatPort.T</code>
is <i>15</i>&deg;C. Therefore, heat is added to the component.
As the mass flow rate is by assumption very small, the fluid that leaves the component
will have a very high temperature, violating the 2nd law.
To avoid this situation, if
<code>prescribedHeatFlowRate=false</code>, then the model
<a href=\"modelica://Buildings.Fluid.Interfaces.ConservationEquation\">
Buildings.Fluid.Interfaces.ConservationEquation</a>
is used instead of
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">
Buildings.Fluid.MixingVolumes</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 24, 2022, by Michael Wetter:<br/>
Improved conversion from <code>Xi</code> to <code>X</code> so that it also works
with media that have <code>reducedX=true</code>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1650\">#1650</a>.
</li>
<li>
September 18, 2020, by Michael Wetter:<br/>
Set start value for <code>steBal.hOut</code> so that <code>T_start</code>
can be used which is not known in that instance.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1397\">#1397</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
October 30, 2019 by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> to flow
reversal check.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1228\">
issue 1228</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
Removed <code>partial</code> keyword as this model is not partial.<br/>
Moved <code>C_flow</code> and <code>use_C_flow</code> to child classes.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Moved heat port to the extending classes to provide better comment.
Otherwise, the mixing volume without water input would have a comment
that says latent heat can be added at this port.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs U, m, mXi, mC for being able to
check conservation of quantities.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Updated model to use the new parameter <code>use_mWat_flow</code>
rather than <code>sensibleOnly</code>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added conditional input <code>C_flow</code> for
handling trace substance insertions.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate=prescribedHeatflowRate</code> for
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
This results in equations that are solved more easily.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Set start value for <code>heatPort.T</code> and changed
type of <code>T</code> to <code>Medium.Temperature</code> rather than
<code>Modelica.Units.SI.Temperature</code>
to avoid an
error because of conflicting start values if
<code>Buildings.Fluid.Chillers.Carnot_y</code>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> to the actual model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Improved documentation and changed the test
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 prescribedHeatFlowRate and ...
</pre>
to
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 (prescribedHeatFlowRate or (not allowFlowReversal)) and ...
</pre>
The reason is that if there is no flow reversal, then
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
computes <code>hOut =  port_b.h_outflow;</code>, and hence
it is correct to use <code>hOut</code> to compute
temperature-driven heat flow, such as by conduction or convection.
See also the model documentation.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">
#412</a>.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
October 29, 2014, by Michael Wetter:<br/>
Made assignment of <code>mFactor</code> final, and changed computation of
density to use default medium states as are also used to compute the
specific heat capacity.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Removed <code>Q_flow</code> and added <code>QSen_flow</code>.
This was done to clarify what is sensible and total heat flow rate
as part of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to instance <code>steBal</code> as it has no longer this parameter.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Renamed <code>rho_nominal</code> to <code>rho_start</code>
because this quantity is computed using start values and not
nominal values.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the check of multiple connections to the same element
of a fluid port, as this check required the use of the deprecated
<code>cardinality</code> function.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"modelica://Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
This implementation also simplifies the implementation of
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</a>,
which now uses the same equations as this model.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={
               Text(
                  extent={{-60,-26},{56,-58}},
                  textColor={255,255,255},
                  textString="V=%V"),
                Text(
                  extent={{-152,100},{148,140}},
                  textString="%name",
                  textColor={0,0,255}),
               Ellipse(
                  extent={{-100,98},{100,-102}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor=DynamicSelect({170,213,255}, min(1, max(0, (1-(T-273.15)/50)))*{28,108,200}+min(1, max(0, (T-273.15)/50))*{255,0,0})),
                Text(
                  extent={{62,28},{-58,-22}},
                  textColor={255,255,255},
                  textString=DynamicSelect("", String(T-273.15, format=".1f")))}));
        end PartialMixingVolume;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">Buildings.Fluid.MixingVolumes</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package contains models for completely mixed volumes.
</p>
<p>
For most situations, the model
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a> should be used.
The other models are only of interest if water should be added to
or subtracted from the fluid volume, such as in a
coil with water vapor condensation.
</p>
</html>"));
    end MixingVolumes;

    package Movers "Package with fan and pump models"
      extends Modelica.Icons.Package;

      model FlowControlled_dp
        "Fan or pump with ideally controlled head dp as input signal"
        extends Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine(
          final preVar=Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.PressureDifference,
          final computePowerUsingSimilarityLaws=per.havePressureCurve,
          preSou(dp_start=dp_start, control_dp= not prescribeSystemPressure),
          final stageInputs(each final unit="Pa") = heads,
          final constInput(final unit="Pa") = constantHead,
          final _m_flow_nominal = m_flow_nominal,
          filter(
            final y_start=dp_start,
            u(final unit="Pa"),
            y(final unit="Pa"),
            x(each nominal=dp_nominal),
            u_nominal=dp_nominal),
          eff(
            per(
              final pressure=
                if per.havePressureCurve then
                  per.pressure
                else
                  Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters(
                    V_flow = {i/(nOri-1)*2.0*m_flow_nominal/rho_default for i in 0:(nOri-1)},
                    dp =     {i/(nOri-1)*2.0*dp_nominal for i in (nOri-1):-1:0}),
              final etaHydMet=
                if (per.etaHydMet ==
                     Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Power_VolumeFlowRate
                  or per.etaHydMet ==
                     Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.EulerNumber)
                  and not per.havePressureCurve then
                    Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.NotProvided
                else per.etaHydMet,
              final etaMotMet=
                if (per.etaMotMet ==
                     Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio
                  or per.etaMotMet ==
                     Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve)
                  and (not per.haveWMot_nominal and not per.havePressureCurve) then
                     Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.NotProvided
                else per.etaMotMet),
            r_N(start=if abs(dp_nominal) > 1E-8 then dp_start/dp_nominal else 0)));

        parameter Modelica.Units.SI.PressureDifference dp_start(
          min=0,
          displayUnit="Pa") = 0 "Initial value of pressure raise"
          annotation (Dialog(tab="Dynamics", group="Filtered speed"));

        parameter Modelica.Units.SI.MassFlowRate m_flow_nominal(
          final min=Modelica.Constants.small)
          "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));

        // For air, we set dp_nominal = 600 as default, for water we set 10000
        parameter Modelica.Units.SI.PressureDifference dp_nominal(
          final min=Modelica.Constants.small,
          displayUnit="Pa") = if rho_default < 500 then 500 else 10000 "Nominal pressure raise, used to normalized the filter if use_inputFilter=true,
        to set default values of constantHead and heads, and
        and for default pressure curve if not specified in record per"
          annotation (Dialog(group="Nominal condition"));

        parameter Modelica.Units.SI.PressureDifference constantHead(
          min=0,
          displayUnit="Pa") = dp_nominal
          "Constant pump head, used when inputType=Constant" annotation (Dialog(
              enable=inputType == Buildings.Fluid.Types.InputType.Constant));

        // By default, set heads proportional to sqrt(speed/speed_nominal)
        parameter Modelica.Units.SI.PressureDifference[:] heads(
          each min=0,
          each displayUnit="Pa") = dp_nominal*{(per.speeds[i]/per.speeds[end])^2 for
          i in 1:size(per.speeds, 1)}
          "Vector of head set points, used when inputType=Stages"
          annotation (Dialog(enable=inputType == Buildings.Fluid.Types.InputType.Stages));
        parameter Boolean prescribeSystemPressure = false
          "=true, to control mover such that pressure difference is obtained across two remote points in system"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput dpMea(
          final quantity="PressureDifference",
          displayUnit="Pa",
          final unit="Pa")=gain.u if prescribeSystemPressure
          "Measurement of pressure difference between two points where the set point should be obtained"
          annotation (Placement(transformation(
              extent={{20,-20},{-20,20}},
              rotation=90,
              origin={-80,120})));

        Modelica.Blocks.Interfaces.RealInput dp_in(final unit="Pa")
          if inputType == Buildings.Fluid.Types.InputType.Continuous
          "Prescribed pressure rise"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));

        Modelica.Blocks.Interfaces.RealOutput dp_actual(final unit="Pa")
          "Pressure difference between the mover inlet and outlet"
          annotation (Placement(transformation(extent={{100,40},{120,60}}),
              iconTransformation(extent={{100,40},{120,60}})));

    protected
        Modelica.Blocks.Math.Gain gain(final k=-1)
          annotation (Placement(transformation(extent={{10,-10},{-10,10}},
              rotation=90,
              origin={44,30})));
      equation
        assert(inputSwitch.u >= -1E-3,
          "Pressure set point for mover cannot be negative. Obtained dp = " + String(inputSwitch.u));

        if use_inputFilter then
          connect(filter.y, gain.u) annotation (Line(
            points={{41,70.5},{44,70.5},{44,42}},
            color={0,0,127},
            smooth=Smooth.None));
        else
          connect(inputSwitch.y, gain.u) annotation (Line(
            points={{1,50},{44,50},{44,42}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;

        connect(inputSwitch.u, dp_in) annotation (Line(
            points={{-22,50},{-26,50},{-26,80},{0,80},{0,120}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(preSou.dp_in, gain.y) annotation (Line(
            points={{56,8},{56,14},{44,14},{44,19}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(senRelPre.p_rel, dp_actual) annotation (Line(points={{50.5,-26.35},{
                50.5,-38},{74,-38},{74,50},{110,50}},
                                                 color={0,0,127}));
        annotation (
          Icon(graphics={
              Text(
                extent={{-40,126},{-160,76}},
                textColor={0,0,127},
                visible=inputType == Buildings.Fluid.Types.InputType.Continuous or inputType == Buildings.Fluid.Types.InputType.Stages,
                textString=DynamicSelect("dp", if inputType == Buildings.Fluid.Types.InputType.Continuous then String(dp_in, format=".0f") else String(stage)))}),
        defaultComponentName="mov",
        Documentation(info="<html>
<p>
This model describes a fan or pump with prescribed head.
The input connector provides the pressure rise from the inlet to the outlet.
</p>
<h4>Main equations</h4>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a>.
</p>
<h4>Typical use and important parameters</h4>
<p>
If <code>use_inputFilter=true</code>, then the parameter <code>dp_nominal</code> is
used to normalize the filter. This is used to improve the numerics of the transient response.
The actual pressure raise of the mover at steady-state is independent
of the value of <code>dp_nominal</code>. It is recommended to set
<code>dp_nominal</code> to approximately the pressure raise that the mover has during
full speed.
</p>
<h4>Options</h4>
<p>
Parameter <code>prescribeSystemPressure</code>
can be used to control the mover such that the pressure
difference set point is obtained across two points
in the system, instead of across the fan.
This allows an efficient implementation of
static pressure reset controllers.
A measurement of the pressure difference between the
two points in system then needs to be connected
to <code>RealInput dpMea</code>.
This functionality is demonstrated in
<a href=\"modelica://Buildings.Fluid.Movers.Validation.FlowControlled_dpSystem\">
Buildings.Fluid.Movers.Validation.FlowControlled_dpSystem</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
March 1, 2023, by Hongxiang Fu:<br/>
Refactored the model with a new declaration for
<code>m_flow_nominal</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1705\">#1705</a>.
</li>
<li>
April 27, 2022, by Hongxiang Fu:<br/>
Replaced <code>not use_powerCharacteristic</code> with the enumerations
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod\">
Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod</a>
and
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod\">
Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod</a>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
<li>
March 7, 2022, by Michael Wetter:<br/>
Set <code>final massDynamics=energyDynamics</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">#1542</a>.
</li>
<li>
June 17, 2021, by Michael Wetter:<br/>
Changed implementation of the filter.<br/>
Removed parameter <code>y_start</code> which is not used because <code>dp_start</code> is used.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating stage.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
May 5, 2017, by Filip Jorissen:<br/>
Added parameters, documentation and functionality for
<code>prescribeSystemPressure</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/770\">#770</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 14, 2016, by Michael Wetter:<br/>
Changed default values for <code>heads</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/583\">#583</a>.
</li>
<li>
March 2, 2016, by Filip Jorissen:<br/>
Refactored model such that it directly extends <code>PartialFlowMachine</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 5, 2015, by Michael Wetter:<br/>
Removed the parameters <code>use_powerCharacteristics</code> and <code>power</code>
from the performance data record <code>per</code>
because
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_dp\">
Buildings.Fluid.Movers.FlowControlled_dp</a>
and
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_m_flow\">
Buildings.Fluid.Movers.FlowControlled_m_flow</a>
fix the flow rate or head, which can give a flow work that is higher
than the power consumption specified in this record.
Hence, users should use the efficiency data for this model.
The record has been moved to
<a href=\"modelica://Buildings.Fluid.Movers.Data.SpeedControlled_y\">
Buildings.Fluid.Movers.Data.SpeedControlled_y</a>
as it makes sense to use it for the movers
<a href=\"modelica://Buildings.Obsolete.Fluid.Movers.FlowControlled_Nrpm\">
Buildings.Obsolete.Fluid.Movers.FlowControlled_Nrpm</a>
and
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_y\">
Buildings.Fluid.Movers.FlowControlled_y</a>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/457\">
issue 457</a>.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>July 5, 2010, by Michael Wetter:<br/>
Changed <code>assert(dp_in >= 0, ...)</code> to <code>assert(dp_in >= -0.1, ...)</code>.
The former implementation triggered the assert if <code>dp_in</code> was solved for
in a nonlinear equation since the solution can be slightly negative while still being
within the solver tolerance.
</li>
<li>March 24, 2010, by Michael Wetter:<br/>
Revised implementation to allow zero flow rate.
</li>
<li>October 1, 2009,
    by Michael Wetter:<br/>
       Added model to the Buildings library.
</ul>
</html>"));
      end FlowControlled_dp;

      model FlowControlled_m_flow
        "Fan or pump with ideally controlled mass flow rate as input signal"
        extends Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine(
          final preVar=Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate,
          final computePowerUsingSimilarityLaws=per.havePressureCurve,
          final stageInputs(each final unit="kg/s")=massFlowRates,
          final constInput(final unit="kg/s")=constantMassFlowRate,
          final _m_flow_nominal = m_flow_nominal,
          filter(
            final y_start=m_flow_start,
            u(final unit="kg/s"),
            y(final unit="kg/s"),
            x(each nominal=m_flow_nominal),
            u_nominal=m_flow_nominal),
          eff(
            per(
              final pressure = if per.havePressureCurve then
                per.pressure
              else
                Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters(
                  V_flow = {i/(nOri-1)*2.0*m_flow_nominal/rho_default for i in 0:(nOri-1)},
                  dp =     {i/(nOri-1)*2.0*dp_nominal for i in (nOri-1):-1:0}),
              final etaHydMet=
                if (per.etaHydMet ==
                     Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Power_VolumeFlowRate
                  or per.etaHydMet ==
                     Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.EulerNumber)
                  and not per.havePressureCurve then
                    Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.NotProvided
                else per.etaHydMet,
              final etaMotMet=
                if (per.etaMotMet ==
                     Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio
                  or per.etaMotMet ==
                     Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve)
                  and (not per.haveWMot_nominal and not per.havePressureCurve) then
                     Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.NotProvided
                else per.etaMotMet),
            r_N(start=if abs(m_flow_nominal) > 1E-8 then m_flow_start/m_flow_nominal else 0)),
          preSou(m_flow_start=m_flow_start));

        parameter Modelica.Units.SI.MassFlowRate m_flow_nominal(
          final min=Modelica.Constants.small)
          "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));

        // For air, we set dp_nominal = 600 as default, for water we set 10000
        parameter Modelica.Units.SI.PressureDifference dp_nominal(
          final min=Modelica.Constants.small,
          displayUnit="Pa") = if rho_default < 500 then 500 else 10000
          "Nominal pressure raise, used for default pressure curve if not specified in record per"
          annotation (Dialog(group="Nominal condition"));

        parameter Modelica.Units.SI.MassFlowRate m_flow_start(min=0) = 0
          "Initial value of mass flow rate"
          annotation (Dialog(tab="Dynamics", group="Filtered speed"));

        parameter Modelica.Units.SI.MassFlowRate constantMassFlowRate=m_flow_nominal
          "Constant pump mass flow rate, used when inputType=Constant" annotation (
            Dialog(enable=inputType == Buildings.Fluid.Types.InputType.Constant));

        // By default, set massFlowRates proportional to (speed/speed_nominal)
        parameter Modelica.Units.SI.MassFlowRate[:] massFlowRates=m_flow_nominal*{per.speeds[
            i]/per.speeds[end] for i in 1:size(per.speeds, 1)}
          "Vector of mass flow rate set points, used when inputType=Stage"
          annotation (Dialog(enable=inputType == Buildings.Fluid.Types.InputType.Stages));

        parameter Modelica.Units.SI.Pressure dpMax(
          min=0,
          displayUnit="Pa") = 2*max(eff.per.pressure.dp)
         "Maximum pressure allowed to operate the model, if exceeded, the simulation stops with an error"
         annotation(Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput m_flow_in(
          final unit="kg/s",
          nominal=m_flow_nominal)
          if inputType == Buildings.Fluid.Types.InputType.Continuous
          "Prescribed mass flow rate"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));
        Modelica.Blocks.Interfaces.RealOutput m_flow_actual(
          final unit="kg/s",
          nominal=m_flow_nominal) "Actual mass flow rate"
          annotation (Placement(transformation(extent={{100,40},{120,60}}),
              iconTransformation(extent={{100,40},{120,60}})));

      equation
        assert(-dp <= dpMax,
          "In " + getInstanceName() + ": Model operates with head -dp = " + String(-dp) + " Pa,
    exceeding the pressure allowed by the parameter "       + getInstanceName() + ".dpMax.
    This can happen if the model forces a high mass flow rate through a closed actuator,
    or if the performance record is unreasonable. Please verify your model, and
    consider using one of the other pump or fan models.");

        if use_inputFilter then
          connect(filter.y, m_flow_actual) annotation (Line(
            points={{41,70.5},{44,70.5},{44,50},{110,50}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(filter.y, preSou.m_flow_in)
            annotation (Line(points={{41,70.5},{44,70.5},{44,8}}, color={0,0,127}));
        else
        connect(inputSwitch.y, m_flow_actual) annotation (Line(points={{1,50},{110,50}},
                                                   color={0,0,127}));
        connect(inputSwitch.y, preSou.m_flow_in) annotation (Line(
            points={{1,50},{44,50},{44,8}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;

        connect(inputSwitch.u, m_flow_in) annotation (Line(
            points={{-22,50},{-26,50},{-26,80},{0,80},{0,120}},
            color={0,0,127},
            smooth=Smooth.None));

        annotation (
            Icon(graphics={
              Text(
                extent={{-40,126},{-160,76}},
                textColor={0,0,127},
                visible=inputType == Buildings.Fluid.Types.InputType.Continuous or inputType == Buildings.Fluid.Types.InputType.Stages,
                textString=DynamicSelect("m_flow", if inputType == Buildings.Fluid.Types.InputType.Continuous then String(m_flow_in, leftJustified=false, significantDigits=3) else String(stage)))}),
        defaultComponentName="mov",
        Documentation(
         info="<html>
<p>
This model describes a fan or pump with prescribed mass flow rate.
</p>
<p>
Note that if the model operates with a head that is larger than <code>dpMax</code>, which by default is
two times larger than the largest head declared in <code>eff.per.pressure.dp</code>,
the simulation will stop with an error message.
This guards against unreasonably high pressure drops and electrical power use,
which can happen if the model is forcing mass flow rate through a closed actuator.
</p>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>",   revisions="<html>
<ul>
<li>
March 1, 2023, by Hongxiang Fu:<br/>
Refactored the model with a new declaration for
<code>m_flow_nominal</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1705\">#1705</a>.
</li>
<li>
April 27, 2022, by Hongxiang Fu:<br/>
Replaced <code>not use_powerCharacteristic</code> with the enumerations
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod\">
Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod</a>
and
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod\">
Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod</a>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
<li>
November 15, 2022, by Michael Wetter:<br/>
Added assertion if model operates with a pressure higher than <code>dpMax</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1659\">#1659</a>.
</li>
<li>
March 7, 2022, by Michael Wetter:<br/>
Set <code>final massDynamics=energyDynamics</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">#1542</a>.
</li>
<li>
June 17, 2021, by Michael Wetter:<br/>
Changed implementation of the filter.<br/>
Removed parameter <code>y_start</code> which is not used because <code>m_flow_start</code> is used.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating stage.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
November 10, 2016, by Michael Wetter:<br/>
Changed default values for <code>massFlowRates</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/583\">#583</a>.
</li>
<li>
March 2, 2016, by Filip Jorissen:<br/>
Refactored model such that it directly extends <code>PartialFlowMachine</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24, 2010, by Michael Wetter:<br/>
Revised implementation to allow zero flow rate.
</li>
<li>October 1, 2009
    by Michael Wetter:<br/>
       Model added to the Buildings library.
</ul>
</html>"));
      end FlowControlled_m_flow;

      package Data "Package containing data for real pumps/fans"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Generic data record for movers"
          extends Modelica.Icons.Record;

          // Pressure requires default values to avoid in Dymola the message
          // Failed to expand the variable pressure.V_flow.
          parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure(
            V_flow = {0, 0},
            dp =     {0, 0}) "Volume flow rate vs. total pressure rise"
            annotation(Evaluate=true,
                       Dialog(group="Pressure curve"));
          final parameter Modelica.Units.SI.VolumeFlowRate V_flow_max=
            if havePressureCurve
              then (pressure.V_flow[end]
                        -(pressure.V_flow[end] - pressure.V_flow[end - 1])
                        /(pressure.dp[end] - pressure.dp[end - 1])
                        * pressure.dp[end])
            else 0
              "Volume flow rate on the curve when pressure rise is zero";
          final parameter Modelica.Units.SI.PressureDifference dpMax(
            displayUnit="Pa")=
            if havePressureCurve
              then (pressure.dp[1]
                        -(pressure.dp[1] - pressure.dp[2])
                        /(pressure.V_flow[1] - pressure.V_flow[2])
                        * pressure.V_flow[1])
            else 0
              "Pressure rise on the curve when flow rate is zero";

          // Efficiency computation choices
          parameter Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod etaHydMet=
            Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.EulerNumber
            "Efficiency computation method for the hydraulic efficiency etaHyd"
            annotation (Dialog(group="Power computation"));
          parameter Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod etaMotMet=
            if powerOrEfficiencyIsHydraulic
              then Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve
            else Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.NotProvided
            "Efficiency computation method for the motor efficiency etaMot"
            annotation (Dialog(group="Power computation"));

          parameter Boolean powerOrEfficiencyIsHydraulic=true
            "=true if hydraulic power or efficiency is provided, instead of total"
            annotation (Dialog(group="Power computation",
            enable=max(power.P)>Modelica.Constants.eps
            or max(efficiency.eta)>Modelica.Constants.eps));

          // Arrays for efficiency values
          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
            efficiency(
              V_flow={0},
              eta={0.7}) "Total or hydraulic efficiency vs. volumetric flow rate"
            annotation (Dialog(group="Power computation",
                               enable=etaHydMet == Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Efficiency_VolumeFlowRate));
          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
            motorEfficiency(
              V_flow={0},
              eta={0.7})
            "Motor efficiency vs. volumetric flow rate"
            annotation (Dialog(group="Power computation",
                               enable=etaMotMet == Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_VolumeFlowRate));
          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters_yMot
            motorEfficiency_yMot(y={0}, eta={0.7})
            "Motor efficiency vs. part load ratio yMot, where yMot = WHyd/WMot_nominal"
            annotation (Dialog(group="Power computation", enable=etaMotMet ==
              Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio));

          // Power curve
          //   It requires default values to suppress Dymola message
          //   "Failed to expand the variable Power.V_flow"
          parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters power(
            V_flow={0},
            P={0})
            "Power (either consumed or hydraulic) vs. volumetric flow rate"
           annotation (Dialog(group="Power computation",
                              enable =   etaHydMet==
              Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Power_VolumeFlowRate));

          // Peak condition
          parameter Buildings.Fluid.Movers.BaseClasses.Euler.peak peak(
            V_flow=peak_internal.V_flow,
            dp=peak_internal.dp,
            eta=peak_internal.eta)
            "Volume flow rate, pressure rise, and efficiency (either total or hydraulic) at peak condition"
            annotation (Dialog(group="Power computation",
                               enable =  etaHydMet==
              Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.EulerNumber));
          final parameter Buildings.Fluid.Movers.BaseClasses.Euler.peak peak_internal=
            Buildings.Fluid.Movers.BaseClasses.Euler.getPeak(pressure=pressure,power=power)
            "Internal peak variable";
          // The getPeak() function automatically handles the estimation of peak point
          //   when insufficient information is provided from the pressure curve.

          // Motor
          parameter Boolean motorCooledByFluid=true
            "If true, then motor heat is added to fluid stream"
            annotation(Dialog(group="Motor heat rejection"));
          parameter Modelica.Units.SI.Power WMot_nominal=
            if max(power.P)>Modelica.Constants.eps
            then
              if powerOrEfficiencyIsHydraulic
                then max(power.P)*1.2
              else max(power.P)
            else
              if havePressureCurve
                then V_flow_max/2 * dpMax/2 /0.7*1.2
              else 0
            "Rated motor power"
              annotation(Dialog(group="Power computation",
                                enable= etaMotMet==
                Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio
                                or      etaMotMet==
                Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve));
          parameter Modelica.Units.SI.Efficiency etaMot_max(max=1)= 0.7
            "Maximum motor efficiency"
            annotation (Dialog(group="Power computation", enable=etaMotMet ==
              Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve));
          final parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters_yMot
              motorEfficiency_yMot_generic=
                Buildings.Fluid.Movers.BaseClasses.Characteristics.motorEfficiencyCurve(
                  P_nominal=WMot_nominal,
                  eta_max=etaMot_max)
            "Motor efficiency  vs. part load ratio"
            annotation (Dialog(enable=false));
          final parameter Boolean haveWMot_nominal=WMot_nominal > Modelica.Constants.eps
            "= true, if the rated motor power is provided";

          // Speed
          parameter Real speed_nominal(
            final min=0,
            final unit="1") = 1 "Nominal rotational speed for flow characteristic"
            annotation (Dialog(group="Normalized speeds"));

          parameter Real constantSpeed(final min=0, final unit="1") = 1
            "Normalized speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant"
            annotation (Dialog(group="Normalized speeds"));

          parameter Real[:] speeds(each final min = 0, each final unit="1") = {1}
            "Vector of normalized speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages"
            annotation (Dialog(group="Normalized speeds"));

          // Set a parameter in order for
          // (a) FlowControlled_m_flow and FlowControlled_dp to be able to set a reasonable
          //     default pressure curve if it is not specified here, and
          // (b) SpeedControlled_y to be able to issue an assert
          //     if no pressure curve is specified.
          final parameter Boolean havePressureCurve=
            sum(pressure.V_flow) > Modelica.Constants.eps and
            sum(pressure.dp) > Modelica.Constants.eps
            "= true, if default record values are being used";

          annotation (
          defaultComponentPrefixes = "parameter",
          defaultComponentName = "per",
          Documentation(revisions="<html>
<ul>
<li>
March 29, 2023, by Hongxiang Fu:<br/>
Deleted angular speed parameters with the unit rpm.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1704\">IBPSA, #1704</a>.
</li>
<li>
March 1, 2022, by Hongxiang Fu:<br/>
<ul>
<li>
Modified the record to allow separate specifications of different
efficiency variables.
</li>
<li>
Added parameters for computation using Euler number.
</li>
<li>
Added parameters for providing the motor efficiency as an array
vs. motor part load ratio.
</li>
<li>
Moved the computation of <code>V_flow_max</code> here from
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine\">
Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine</a>
and <code>dpMax</code> here from
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>
</li>
</ul>
These are for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
<li>
February 19, 2016, by Filip Jorissen:<br/>
Refactored model such that <code>SpeedControlled_Nrpm</code>,
<code>SpeedControlled_y</code> and <code>FlowControlled</code>
are integrated into one record.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
February 17, 2016, by Michael Wetter:<br/>
Changed parameter <code>N_nominal</code> to
<code>speed_rpm_nominal</code> as it is the same quantity as <code>speeds_rmp</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
January 19, 2016, by Filip Jorissen:<br/>
Added parameter <code>speeds_rpm</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
February 13, 2015, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised record for OpenModelica.
</li>
<li>
November 22, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Record containing parameters for pumps or fans.
</p>
<h4>Typical use</h4>
<p>
This record may be used to assign for example fan performance data using
declaration such as
</p>
<pre>
  Buildings.Fluid.Movers.SpeedControlled_y fan(
    redeclare package Medium = Medium,
      per(pressure(V_flow={0,m_flow_nominal,2*m_flow_nominal}/1.2,
                   dp={2*dp_nominal,dp_nominal,0}))) \"Fan\";
</pre>
<p>
This data record can be used with
<a href=\"modelica://Buildings.Fluid.Movers.SpeedControlled_y\">
Buildings.Fluid.Movers.SpeedControlled_y</a>,
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_dp\">
Buildings.Fluid.Movers.FlowControlled_dp</a>,
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_m_flow\">
Buildings.Fluid.Movers.FlowControlled_m_flow</a>.
</p>
<p>
An example that uses manufacturer data can be found in
<a href=\"modelica://Buildings.Fluid.Movers.Validation.Pump_y_stratos\">
Buildings.Fluid.Movers.Validation.Pump_y_stratos</a>.
</p>
<h4>Declaration of the peak condition</h4>
<p>
The variable <code>peak</code> is intentionally declared in a way that each of its
element is declared individually. If it was delcared the same way as does
<code>peak_internal</code>, Modelica would prevent the modification of its
specific elements with the following error message:<br/>
<code>
Record has a value, and attempt to modify specific elements.<br/>
The element modification of e.g. V_flow will be ignored.<br/>
</code>
The other variable <code>peak_internal</code> uses a function call to compute its
default values. By passing them to <code>peak</code> one by one, the model can
both have default values and also allow the user to override them easily.
See <a href=\"https://github.com/modelica/ModelicaSpecification/issues/791\">
Modelica Specification issue #791</a>.
</p>
</html>"));
        end Generic;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains data for fans and pumps.
</p>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>"));
      end Data;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Movers"
        extends Modelica.Icons.BasesPackage;

        model FlowMachineInterface
          "Partial model with performance curves for fans or pumps"
          extends Modelica.Blocks.Icons.Block;

          import cha = Buildings.Fluid.Movers.BaseClasses.Characteristics;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Buildings.Fluid.Movers.Data.Generic per
            "Record with performance data"
            annotation (choicesAllMatching=true,
              Placement(transformation(extent={{60,-80},{80,-60}})));

          parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable preVar=
            Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed "Type of prescribed variable";
          parameter Boolean computePowerUsingSimilarityLaws
            "= true, compute power exactly, using similarity laws. Otherwise approximate.";

          final parameter Modelica.Units.SI.VolumeFlowRate V_flow_nominal=per.pressure.V_flow[
              nOri] "Nominal volume flow rate, used for homotopy";

          parameter Modelica.Units.SI.Density rho_default
            "Fluid density at medium default state";

          final parameter Boolean haveVMax = (abs(per.pressure.dp[nOri]) < Modelica.Constants.eps)
            "Flag, true if user specified data that contain V_flow_max";

          final parameter Modelica.Units.SI.VolumeFlowRate V_flow_max=
            if per.V_flow_max>Modelica.Constants.eps
              then per.V_flow_max
            else
              V_flow_nominal
            "Maximum volume flow rate, used for smoothing";

          parameter Integer nOri(min=1) "Number of data points for pressure curve"
            annotation(Evaluate=true);

         // Normalized speed
          Modelica.Blocks.Interfaces.RealInput y_in(final unit="1") if preSpe
            "Prescribed mover speed"
            annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,120})));

          Modelica.Blocks.Interfaces.RealOutput y_out(
            final unit="1") "Mover speed (prescribed or computed)"
            annotation (Placement(transformation(extent={{100,90},{120,110}})));

          Modelica.Blocks.Interfaces.RealInput m_flow(
            final quantity="MassFlowRate",
            final unit="kg/s") "Mass flow rate"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

          Modelica.Blocks.Interfaces.RealInput rho(
            final quantity="Density",
            final unit="kg/m3",
            min=0.0) "Medium density"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Modelica.Blocks.Interfaces.RealOutput V_flow(
            quantity="VolumeFlowRate",
            final unit="m3/s") "Volume flow rate"
            annotation (Placement(transformation(extent={{100,50},{120,70}}),
                iconTransformation(extent={{100,50},{120,70}})));

          Modelica.Blocks.Interfaces.RealInput dp_in(
            quantity="PressureDifference",
            final unit="Pa") if prePre "Prescribed pressure increase"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=270,
                origin={40,120})));

          Modelica.Blocks.Interfaces.RealOutput dp(
            quantity="Pressure",
            final unit="Pa") if not prePre "Pressure increase (computed or prescribed)"
            annotation (Placement(transformation(extent={{100,70},{120,90}})));

          Modelica.Blocks.Interfaces.RealOutput WFlo(
            quantity="Power",
            final unit="W") "Flow work"
            annotation (Placement(transformation(extent={{100,10},{120,30}})));

          Modelica.Blocks.Interfaces.RealOutput WHyd(
            quantity="Power",
            final unit="W") "Hydraulic work (shaft work, brake horsepower)"
            annotation (Placement(
                transformation(extent={{100,-10},{120,10}}), iconTransformation(extent={
                    {100,-10},{120,10}})));

          Modelica.Blocks.Interfaces.RealOutput PEle(
            quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{100,-30},{120,-10}}),
                iconTransformation(extent={{100,-30},{120,-10}})));

          Modelica.Blocks.Interfaces.RealOutput eta(
            final quantity="Efficiency",
            final unit="1",
            start = 0.49) "Overall efficiency"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}}),
                iconTransformation(extent={{100,-70},{120,-50}})));
          // A start value is given to suppress the following translation warning:
          //   "Some variables are iteration variables of the initialization problem:
          //   but they are not given any explicit start values. Zero will be used."

          Modelica.Blocks.Interfaces.RealOutput etaHyd(
            final quantity="Efficiency",
            final unit="1") "Hydraulic efficiency"
            annotation (Placement(transformation(extent={{100,-90},{120,-70}}),
                iconTransformation(extent={{100,-90},{120,-70}})));

          Modelica.Blocks.Interfaces.RealOutput etaMot(
            final quantity="Efficiency",
            final unit="1") "Motor efficiency"
            annotation (Placement(transformation(extent={{100,-110},{120,-90}}),
                iconTransformation(extent={{100,-110},{120,-90}})));

          // "Shaft rotational speed";
          Modelica.Blocks.Interfaces.RealOutput r_N(unit="1")
            "Ratio N_actual/N_nominal";
          Real r_V(start=1, unit="1") "Ratio V_flow/V_flow_max";

      protected
          final parameter Boolean preSpe=
            preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed
            "True if speed is a prescribed variable of this block";
          final parameter Boolean prePre=
            preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.PressureDifference or
            preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate
            "True if pressure head is a prescribed variable of this block";

          // Derivatives for cubic spline
          final parameter Real etaDer[size(per.efficiency.V_flow,1)]=
            if not per.etaHydMet==Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Efficiency_VolumeFlowRate
              then zeros(size(per.efficiency.V_flow,1))
            elseif (size(per.efficiency.V_flow, 1) == 1)
              then {0}
            else
              Buildings.Utilities.Math.Functions.splineDerivatives(
                x=per.efficiency.V_flow,
                y=per.efficiency.eta,
                ensureMonotonicity=Buildings.Utilities.Math.Functions.isMonotonic(
                  x=per.efficiency.eta,
                  strict=false))
            "Coefficients for cubic spline of total or hydraulic efficiency vs. volume flow rate";
          final parameter Real motDer[size(per.motorEfficiency.V_flow, 1)]=
            if not per.etaMotMet==Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_VolumeFlowRate
              then zeros(size(per.motorEfficiency.V_flow,1))
            elseif (size(per.motorEfficiency.V_flow, 1) == 1)
              then {0}
            else
              Buildings.Utilities.Math.Functions.splineDerivatives(
                x=per.motorEfficiency.V_flow,
                y=per.motorEfficiency.eta,
                ensureMonotonicity=Buildings.Utilities.Math.Functions.isMonotonic(
                  x=per.motorEfficiency.eta,
                  strict=false))
            "Coefficients for cubic spline of motor efficiency vs. volume flow rate";
          final parameter Real motDer_yMot[size(per.motorEfficiency_yMot.y,1)]=
            if not per.etaMotMet==
              Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio
              then zeros(size(per.motorEfficiency_yMot.y,1))
            elseif (size(per.motorEfficiency_yMot.y,1) == 1)
              then {0}
            else
              Buildings.Utilities.Math.Functions.splineDerivatives(
                x=per.motorEfficiency_yMot.y,
                y=per.motorEfficiency_yMot.eta,
                ensureMonotonicity=Buildings.Utilities.Math.Functions.isMonotonic(
                  x=per.motorEfficiency_yMot.eta,
                  strict=false))
            "Coefficients for cubic spline of motor efficiency vs. motor PLR";
          final parameter Real motDer_yMot_generic[9]=
            if per.etaMotMet==
              Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve
              or  (per.etaMotMet==
              Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.NotProvided
                   and per.haveWMot_nominal)
              then Buildings.Utilities.Math.Functions.splineDerivatives(
                     x=per.motorEfficiency_yMot_generic.y,
                     y=per.motorEfficiency_yMot_generic.eta,
                     ensureMonotonicity=true)
            else zeros(9)
            "Coefficients for cubic spline of motor efficiency vs. motor PLR with generic curves";

          final parameter Modelica.Units.SI.PressureDifference dpMax(
            displayUnit="Pa")=
            per.dpMax "Maximum head";

          parameter Real delta = 0.05
            "Small value used to for regularization and to approximate an internal flow resistance of the fan";

          parameter Real kRes(min=0, unit="kg/(s.m4)") =  dpMax/V_flow_max*delta^2/10
            "Coefficient for internal pressure drop of the fan or pump";

          parameter Integer curve=
             if (haveVMax and haveDPMax) or (nOri == 2) then 1
             elseif haveVMax or haveDPMax then 2
             else 3
            "Flag, used to pick the right representation of the fan or pump's pressure curve";

          final parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur1(
            final n = nOri,
            final V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                     {per.pressure.V_flow[i] for i in 1:nOri}
                     else
                     zeros(nOri),
            final dp = if (haveVMax and haveDPMax) or (nOri == 2) then
                     {(per.pressure.dp[i] + per.pressure.V_flow[i] * kRes) for i in 1:nOri}
                     else
                     zeros(nOri))
            "Volume flow rate vs. total pressure rise with correction for fan or pump's resistance added";

          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur2(
            final n = nOri + 1,
            V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                        zeros(nOri + 1)
                     elseif haveVMax then
                      cat(1, {0}, {per.pressure.V_flow[i] for i in 1:nOri})
                     elseif haveDPMax then
                      cat(1, { per.pressure.V_flow[i] for i in 1:nOri}, {V_flow_max})
                     else
                      zeros(nOri + 1),
            dp = if (haveVMax and haveDPMax) or (nOri == 2) then
                        zeros(nOri + 1)
                     elseif haveVMax then
                      cat(1, {dpMax}, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri})
                     elseif haveDPMax then
                      cat(1, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri}, {0})
                     else
                       zeros(nOri+1))
            "Volume flow rate vs. total pressure rise with correction for fan or pump's resistance added";
          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur3(
            final n = nOri + 2,
            V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                       zeros(nOri + 2)
                     elseif haveVMax or haveDPMax then
                       zeros(nOri + 2)
                     else
                       cat(1, {0}, {per.pressure.V_flow[i] for i in 1:nOri}, {V_flow_max}),
            dp =     if (haveVMax and haveDPMax) or (nOri == 2) then
                       zeros(nOri + 2)
                     elseif haveVMax or haveDPMax then
                       zeros(nOri + 2)
                     else
                       cat(1, {dpMax}, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri}, {0}))
            "Volume flow rate vs. total pressure rise with correction for fan or pump's resistance added";

          parameter Real preDer1[nOri](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer2[nOri+1](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer3[nOri+2](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real powDer[size(per.power.V_flow,1)]=
           if per.etaHydMet==
              Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Power_VolumeFlowRate then
             Buildings.Utilities.Math.Functions.splineDerivatives(
                           x=per.power.V_flow,
                           y=per.power.P,
                           ensureMonotonicity=Buildings.Utilities.Math.Functions.isMonotonic(x=per.power.P,
                                                                                             strict=false))
           else
             zeros(size(per.power.V_flow,1))
            "Coefficients for polynomial of power vs. flow rate";

          final parameter Buildings.Fluid.Movers.BaseClasses.Euler.powerWithDerivative powEu_internal=
            if (curve == 1) then
              Buildings.Fluid.Movers.BaseClasses.Euler.power(peak=per.peak,pressure=pCur1)
            elseif (curve == 2) then
              Buildings.Fluid.Movers.BaseClasses.Euler.power(peak=per.peak,pressure=pCur2)
            else
              Buildings.Fluid.Movers.BaseClasses.Euler.power(peak=per.peak,pressure=pCur3)
            "Intermediate parameter";
          final parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters powEu(
            V_flow = powEu_internal.V_flow,
            P = powEu_internal.P)
            "Power vs. volumetric flow rate computed from Euler number";
          final parameter Real powEuDer[:] = powEu_internal.d
            "Power derivative with respect to volumetric flow rate computed from Euler number";

          parameter Boolean haveMinimumDecrease=
            if nOri<2 then false
            else
              Modelica.Math.BooleanVectors.allTrue({(per.pressure.dp[i + 1] -
              per.pressure.dp[i])/(per.pressure.V_flow[i + 1] - per.pressure.V_flow[
              i]) < -kRes for i in 1:nOri - 1}) "Flag used for reporting";

          parameter Boolean haveDPMax = (abs(per.pressure.V_flow[1])  < Modelica.Constants.eps)
            "Flag, true if user specified data that contain dpMax";

          Modelica.Blocks.Interfaces.RealOutput dp_internal
            "If dp is prescribed, use dp_in and solve for r_N, otherwise compute dp using r_N";

          Modelica.Units.SI.Efficiency eta_internal
            "Either eta or etaHyd";

          Modelica.Units.SI.Power P_internal
            "Either PEle or WHyd";

          parameter Real deltaP = 1E-4 * V_flow_max * dpMax
            "Small value for regularisation of power";

          Real yMot(final min=0, final start=0.833)=
            if per.haveWMot_nominal
              then WHyd/per.WMot_nominal
            else 1
            "Motor part load ratio";

        function getPerformanceDataAsString
          input Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure
              "Performance data";
          input Real derivative[:](unit="kg/(s.m4)") "Derivative";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(derivative, 1) loop
            str :=str + "  V_flow[" + String(i) + "]=" + String(
                pressure.V_flow[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\t" + "dp[" + String(i) + "]=" +
                String(
                pressure.dp[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\tResulting derivative dp/dV_flow = "
                 + String(
                derivative[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getPerformanceDataAsString;

        function getArrayAsString
          input Real array[:] "Array to be printed";
          input String varName "Variable name";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(array, 1) loop
            str :=str + "  " + varName + "[" + String(i) + "]=" + String(
                array[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getArrayAsString;

        initial equation
          // Check validity of data
          assert(nOri > 1, "Must have at least two data points for pressure.V_flow.");
          assert(Buildings.Utilities.Math.Functions.isMonotonic(x=per.pressure.V_flow, strict=true) and
          per.pressure.V_flow[1] > -Modelica.Constants.eps,
          "The fan pressure rise must be a strictly decreasing sequence with respect to the volume flow rate,
  with the first element for the fan pressure raise being non-zero.
The following performance data have been entered:
"         + getArrayAsString(per.pressure.V_flow, "pressure.V_flow"));

          if not haveVMax then
            assert(nOri>=2,
              "When the maximum flow is not specified,
      at least two points are needed for the power curve.");
            if nOri>=2 then
              assert((per.pressure.V_flow[nOri]-per.pressure.V_flow[nOri-1])
                   /((per.pressure.dp[nOri]-per.pressure.dp[nOri-1]))<0,
            "The last two pressure points for the fan or pump's performance curve must be decreasing.
Received
"         + getArrayAsString(per.pressure.dp, "dp"));
            end if;
          end if;

          // Write warning if the volumetric flow rate versus pressure curve does not satisfy
          // the minimum decrease condition
          if (not haveMinimumDecrease) then
            Modelica.Utilities.Streams.print("
Warning:
========
It is recommended that the volume flow rate versus pressure relation
of the fan or pump satisfy the minimum decrease condition

        (per.pressure.dp[i+1]-per.pressure.dp[i])
d[i] = ------------------------------------------------- < "         + String(-kRes) + "
       (per.pressure.V_flow[i+1]-per.pressure.V_flow[i])

 is
"         + getArrayAsString({(per.pressure.dp[i+1]-per.pressure.dp[i])
                /(per.pressure.V_flow[i+1]-per.pressure.V_flow[i]) for i in 1:nOri-1}, "d") + "
Otherwise, a solution to the equations may not exist if the fan or pump's speed is reduced.
In this situation, the solver will fail due to non-convergence and
the simulation stops.");
          end if;

          // Correction for flow resistance of the fan or pump
          if curve == 1 then  // ----- Curve 1
            // V_flow_max and dpMax are provided by the user, or we only have two data points
            preDer1= Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur1.V_flow,
              y=pCur1.dp);
            preDer2= zeros(nOri + 1);
            preDer3= zeros(nOri + 2);
          elseif curve == 2 then  // ----- Curve 2
            // V_flow_max or dpMax is provided by the user, but not both
            preDer1= zeros(nOri);
            preDer2= Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur2.V_flow,
              y=pCur2.dp);
            preDer3= zeros(nOri + 2);
          else  // ----- Curve 3
            // Neither V_flow_max nor dpMax are provided by the user
            preDer1= zeros(nOri);
            preDer2= zeros(nOri + 1);
            preDer3= Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur3.V_flow,
              y=pCur3.dp);
          end if;

          assert(not ((per.etaMotMet==
                   Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio
                   or  per.etaMotMet==
                   Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve)
                 and not per.haveWMot_nominal),
                 "In " + getInstanceName() + ": etaMotMet is set to
         .Efficiency_MotorPartLoadRatio or .GenericCurve which requires
         the motor's rated power, but per.WMot_nominal is not assigned or
         cannot be estimated because no power curve is provided.");

          assert(max(per.power.P)<1E-6 or per.WMot_nominal>max(per.power.P)*0.99,
                 "In " + getInstanceName() + ": The rated motor power provided in
         per.WMot_nominal is smaller than the maximum power provided in per.power.
         Use a larger value for per.WMot_nominal or leave it blank to allow the
         model to assume a default value.");

          assert(homotopyInitialization, "In " + getInstanceName() +
                 ": The constant homotopyInitialization has been modified from its default
         value. This constant will be removed in future releases.",
                 level = AssertionLevel.warning);

        equation
          // Assign values of dp and r_N, depending on which variable exists and is prescribed
          connect(dp_internal,dp);
          connect(dp_internal,dp_in);
          connect(r_N, y_in);
          y_out=r_N;

          // Flow rate conversion
          V_flow = m_flow / rho;

          // Hydraulic equations
          r_V = V_flow/V_flow_max;

          // If the speed is not prescribed and we do not require exact power computations, we set r_N = 1.
          // Similarity laws are then not used, meaning the power computation is less accurate.
          // This however has the advantage that no non-linear algebraic loop is formed and
          // it allows an implementation when the pressure curve is unknown.
          if (computePowerUsingSimilarityLaws == false) and preVar <> Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed then
            r_N=1;
          else
          // For the homotopy method, we approximate dp by an equation
          // that is linear in V_flow, and that goes linearly to 0 as r_N goes to 0.
          // The three branches below are identical, except that we pass either
          // pCur1, pCur2 or pCur3, and preDer1, preDer2 or preDer3
          if (curve == 1) then
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1),
                                                   simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1)
                                       +(V_flow-V_flow_nominal) * (cha.pressure(
                                                             V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1))
                                                            /(2*delta*V_flow_nominal)));

            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                       r_N=r_N,
                                                       dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                       d=preDer1,
                                                       per=pCur1);
            end if;     // end of computation for this branch
           elseif (curve == 2) then
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2),
                                                    simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2)
                                       +(V_flow-V_flow_nominal) * (cha.pressure(
                                                             V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2))
                                                            /(2*delta*V_flow_nominal)));

            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                              r_N=r_N,
                                                              dpMax=dpMax,
                                                              V_flow_max=V_flow_max,
                                                              d=preDer2,
                                                              per=pCur2);
            end if;     // end of computation for this branch
          else
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3),
                                  simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3)
                                       +(V_flow-V_flow_nominal)*
                                               (cha.pressure(V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3))
                                                            /(2*delta*V_flow_nominal)));

            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                              r_N=r_N,
                                                              dpMax=dpMax,
                                                              V_flow_max=V_flow_max,
                                                              d=preDer3,
                                                              per=pCur3);
            end if;
            // end of computation for this branch
          end if;
            // end of if/else choosing between exact/simplified power computation
          end if;

          // Power and efficiency
          WFlo = Buildings.Utilities.Math.Functions.smoothMax(
                   x1=dp_internal*V_flow,
                   x2=0,
                   deltaX=deltaP/2);
          if per.powerOrEfficiencyIsHydraulic then
            eta = etaHyd * etaMot;
          else
            etaHyd = Buildings.Utilities.Math.Functions.smoothMin(
                       x1=eta/etaMot, x2=1, deltaX=1E-3);
          end if;

          // Hydraulic efficiency etaHyd and hydraulic work WHyd
          //   or total efficiency eta and total electric power PEle
          //   depending on the information provided
          if per.powerOrEfficiencyIsHydraulic then
            P_internal=WHyd;
            eta_internal=etaHyd;
            PEle = WFlo / Buildings.Utilities.Math.Functions.smoothMax(
                            x1=eta, x2=1E-2, deltaX=1E-3);
          else
            P_internal=PEle;
            eta_internal=eta;
            WHyd = WFlo / Buildings.Utilities.Math.Functions.smoothMax(
                            x1=etaMot, x2=1E-2, deltaX=1E-3);
          end if;
          if per.etaHydMet==
               Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Power_VolumeFlowRate then
            if homotopyInitialization then
              P_internal = homotopy(actual=cha.power(per=per.power, V_flow=V_flow, r_N=r_N, d=powDer, delta=delta),
                              simplified=V_flow/V_flow_nominal*
                                    cha.power(per=per.power, V_flow=V_flow_nominal, r_N=1, d=powDer, delta=delta));
            else
              P_internal = (rho/rho_default)*cha.power(per=per.power, V_flow=V_flow, r_N=r_N, d=powDer, delta=delta);
            end if;
            eta_internal = WFlo/Buildings.Utilities.Math.Functions.smoothMax(
                             x1=P_internal, x2=deltaP, deltaX=deltaP/2);
          elseif per.etaHydMet==
               Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.EulerNumber then
            if homotopyInitialization then
              P_internal = homotopy(actual=cha.power(per=powEu, V_flow=V_flow, r_N=r_N, d=powEuDer, delta=delta),
                              simplified=V_flow/V_flow_nominal*
                                    cha.power(per=powEu, V_flow=V_flow_nominal, r_N=1, d=powEuDer, delta=delta));
            else
              P_internal = (rho/rho_default)*cha.power(per=powEu, V_flow=V_flow, r_N=r_N, d=powEuDer, delta=delta);
            end if;
            eta_internal = WFlo / Buildings.Utilities.Math.Functions.smoothMax(
                                    x1=P_internal, x2=deltaP, deltaX=deltaP/2);
          elseif per.etaHydMet == Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Efficiency_VolumeFlowRate then
            if homotopyInitialization then
              eta_internal = homotopy(actual=cha.efficiency(per=per.efficiency,     V_flow=V_flow, d=etaDer, r_N=r_N, delta=delta),
                                simplified=cha.efficiency(per=per.efficiency, V_flow=V_flow_max,   d=etaDer, r_N=r_N, delta=delta));
            else
              eta_internal = cha.efficiency(per=per.efficiency, V_flow=V_flow, d=etaDer, r_N=r_N, delta=delta);
            end if;
            if per.powerOrEfficiencyIsHydraulic then
              P_internal=WFlo/Buildings.Utilities.Math.Functions.smoothMax(
                                x1=eta_internal, x2=1E-2, deltaX=1E-3);
            else
              P_internal=WHyd/Buildings.Utilities.Math.Functions.smoothMax(
                                x1=eta_internal, x2=1E-2, deltaX=1E-3);
            end if;
          else // Not provided
            if per.powerOrEfficiencyIsHydraulic then
              eta_internal=0.7;
              P_internal=WFlo/eta_internal;
            else
              eta_internal=0.49;
              P_internal=WHyd/eta_internal;
            end if;
          end if;

          // Motor efficiency etaMot
          if per.etaMotMet == Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_VolumeFlowRate then
            if homotopyInitialization then
              etaMot = homotopy(actual=cha.efficiency(per=per.motorEfficiency,     V_flow=V_flow, d=motDer, r_N=r_N, delta=delta),
                                simplified=cha.efficiency(per=per.motorEfficiency, V_flow=V_flow_max,   d=motDer, r_N=r_N, delta=delta));
            else
              etaMot = cha.efficiency(per=per.motorEfficiency,     V_flow=V_flow, d=motDer, r_N=r_N, delta=delta);
            end if;
          elseif per.etaMotMet==
               Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio then
            if homotopyInitialization then
              etaMot =homotopy(actual=cha.efficiency_yMot(
                per=per.motorEfficiency_yMot,
                y=yMot,
                d=motDer_yMot), simplified=cha.efficiency_yMot(
                per=per.motorEfficiency_yMot,
                y=1,
                d=motDer_yMot));
            else
              etaMot =cha.efficiency_yMot(
                per=per.motorEfficiency_yMot,
                y=yMot,
                d=motDer_yMot);
            end if;
          elseif per.etaMotMet==
               Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve then
              if homotopyInitialization then
                etaMot =homotopy(actual=cha.efficiency_yMot(
                  per=per.motorEfficiency_yMot_generic,
                  y=yMot,
                  d=motDer_yMot_generic), simplified=cha.efficiency_yMot(
                  per=per.motorEfficiency_yMot_generic,
                  y=1,
                  d=motDer_yMot_generic));
              else
                etaMot =cha.efficiency_yMot(
                  per=per.motorEfficiency_yMot_generic,
                  y=yMot,
                  d=motDer_yMot_generic);
              end if;
          else // Not provided
            etaMot = 0.7;
          end if;

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                            graphics={
                Text(extent={{56,84},{106,70}},
                  textColor={0,0,127},
                  textString="dp"),
                Text(extent={{56,-10},{106,-24}},
                  textColor={0,0,127},
                  textString="PEle"),
                Text(extent={{48,-48},{98,-62}},
                  textColor={0,0,127},
                  textString="eta"),
                Text(extent={{50,-68},{100,-82}},
                  textColor={0,0,127},
                  textString="etaHyd"),
                Text(extent={{50,-86},{100,-100}},
                  textColor={0,0,127},
                  textString="etaMot"),
                Ellipse(
                  extent={{-78,34},{44,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-62,18},{28,-72}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-26,-18},{-8,-36}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-26,-22},{-32,-8},{-30,10},{-8,20},{-6,14},{-24,6},{-24,-8},{
                      -18,-20},{-26,-22}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{-8,-32},{-2,-46},{-4,-64},{-26,-74},{-28,-68},{-10,-60},{-10,
                      -46},{-16,-34},{-8,-32}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{7,21},{13,7},{11,-11},{-11,-21},{-13,-15},{5,-7},{5,7},{-1,19},
                      {7,21}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier,
                  origin={9,-23},
                  rotation=90),
                Polygon(
                  points={{-7,-21},{-13,-7},{-11,11},{11,21},{13,15},{-5,7},{-5,-7},{1,-19},
                      {-7,-21}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier,
                  origin={-43,-31},
                  rotation=90),
                Text(extent={{56,28},{106,14}},
                  textColor={0,0,127},
                  textString="WFlo"),
                Text(extent={{56,66},{106,52}},
                  textColor={0,0,127},
                  textString="V_flow"),
                Line(
                  points={{-74,92},{-74,40}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-74,40},{46,40}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-70,86},{-40,84},{8,68},{36,42}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Text(extent={{56,102},{106,88}},
                  textColor={0,0,127},
                  textString="y_out"),
                Text(extent={{56,8},{106,-6}},
                  textColor={0,0,127},
                  textString="WHyd")}),
            Documentation(info="<html>
<p>
This is an interface that implements the functions to compute the head, power draw
and efficiency of fans and pumps.
</p>
<p>
The nominal hydraulic characteristic (total pressure rise versus volume flow rate)
is given by a set of data points
using the data record <code>per</code>, which is an instance of
<a href=\"modelica://Buildings.Fluid.Movers.Data.Generic\">
Buildings.Fluid.Movers.Data.Generic</a>.
A cubic hermite spline with linear extrapolation is used to compute
the performance at other operating points.
</p>
<p>
The model computes the power and efficiency items in the list below.
</p>
<ul>
<li>
Flow work:<br/>
<i>W&#775;<sub>flo</sub> = V&#775; &sdot; &Delta;p</i>
</li>
<li>
Total efficiency and consumed electric power:<br/>
<i>&eta; = W&#775;<sub>flo</sub> &frasl; P<sub>ele</sub></i>
</li>
<li>
Hydraulic effiency and hydraulic work (shaft work, brake horsepower):<br/>
<i>&eta;<sub>hyd</sub> = W&#775;<sub>flo</sub> &frasl; W&#775;<sub>hyd</sub></i>
</li>
<li>
Motor efficiency:<br/>
<i>&eta;<sub>mot</sub> = W&#775;<sub>hyd</sub> &frasl; P<sub>ele</sub></i>
</li>
</ul>
<p>
See
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
Buildings.Fluid.Movers.UsersGuide</a>
for how the user can provide power and efficiency information to the model.
</p>
<h4>Implementation</h4>
<p>
For numerical reasons, the user-provided data points for volume flow rate
versus pressure rise are modified to add a fan internal flow resistance.
Because this flow resistance is subtracted during the simulation when
computing the fan pressure rise, the model reproduces the exact points
that were provided by the user.
</p>
<p>
Also for numerical reasons, the pressure rise at zero flow rate and
the flow rate at zero pressure rise is added to the user-provided data,
unless the user already provides these data points.
Since Modelica 3.2 does not allow dynamic memory allocation, this
implementation required the use of three different arrays for the
situation where no additional point is added, where one additional
point is added and where two additional points are added.
The parameter <code>curve</code> causes the correct data record
to be used during the simulation.
</p>
<p>
In order to prevent the model from producing negative mover power
when either the flow rate or pressure rise is forced to be negative,
the flow work <i>W&#775;<sub>flo</sub></i> is constrained to be non-negative.
The regularisation starts around 0.01% of the characteristic maximum power
<i>W&#775;<sub>max</sub> = V&#775;<sub>max</sub> &Delta;p<sub>max</sub></i>.
See discussions and an example of this situation in
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1621\">IBPSA, #1621</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 8, 2022, by Hongxiang Fu:<br/>
<ul>
<li>
Modified the power and efficiency computation to allow computing
the hydraulic efficiency <code>etaHyd</code> and
the motor efficiency <code>etaMot</code> separately;
</li>
<li>
Implemented the option to compute the total efficiency <code>eta</code>
or the hydraulic efficiency <code>etaHyd</code> using the Euler number.
</li>
<li>
Implemented the option for the user to provide the motor efficiency
<code>etaMot</code> as a function of part load ratio <i>y</i>. Also allowed generic
curves to be used.
</li>
<li>
Moved <code>haveVMax</code> here from
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine\">
Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine</a>.
</li>
<li>
Now it passes <code>WHyd</code> instead of <code>etaHyd</code> to
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.PowerInterface\">
Buildings.Fluid.Movers.BaseClasses.PowerInterface</a>.
</li>
<li>
Now the flow work <code>WFlo</code> is bounded to be non-negative.
</li>
</ul>
These are for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
June 6, 2022, by Hongxiang Fu:<br/>
Added a constraint that <i>W<sub>flo</sub> = V&#775; &Delta;p &ge; 0</i>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1621\">IBPSA, #1621</a>.
</li>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
February 19, 2016, by Michael Wetter and Filip Jorissen:<br/>
Refactored model to make implementation clearer.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference and reformatted code.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 2, 2015, by Michael Wetter:<br/>
Corrected computation of
<code>etaMot = cha.efficiency(per=per.motorEfficiency, V_flow=V_flow, d=motDer, r_N=r_N, delta=1E-4)</code>
which previously used <code>V_flow_max</code> instead of <code>V_flow</code>.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Removed in <code>N_actual</code> and <code>N_filtered</code>
the <code>max</code> attribute to
avoid a translation warning.
</li>
<li>
April 21, 2014, by Filip Jorissen and Michael Wetter:<br/>
Changed model to use
<a href=\"modelica://Buildings.Fluid.Movers.Data.Generic\">
Buildings.Fluid.Movers.Data.Generic</a>.
April 19, 2014, by Filip Jorissen:<br/>
Passed extra parameters to power() and efficiency()
to be able to properly evaluate the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 27, 2013, by Michael Wetter:<br/>
Reformulated <code>per=if (curve == 1) then pCur1 elseif (curve == 2) then pCur2 else pCur3</code>
by moving the computation into the idividual logical branches because OpenModelica generates an
error when assign the statement to <code>data</code>
as <code>pCur1</code>, <code>pCur2</code> and <code>pCur3</code> have different dimensions.
</li>
<li>
September 17, 2013, by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of parameters
that are an array.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Removed assignment in declaration of <code>pCur?.V_flow</code> as
these parameters have the attribute <code>fixed=false</code> set.
</li>
<li>
October 11, 2012, by Michael Wetter:<br/>
Added implementation of <code>WFlo = eta * P</code> with
guard against division by zero.
Changed implementation of <code>etaMot=sqrt(eta)</code> to
<code>etaHyd = 1</code> to avoid infinite derivative as <code>eta</code>
converges to zero.
</li>
<li>
February 20, 2012, by Michael Wetter:<br/>
Assigned value to nominal attribute of <code>V_flow</code>.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
October 4 2011, by Michael Wetter:<br/>
Revised the implementation of the pressure drop computation as a function
of speed and volume flow rate.
The new implementation avoids a singularity near zero volume flow rate and zero speed.
</li>
<li>
March 28 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end FlowMachineInterface;

        model IdealSource
          "Base class for pressure and mass flow source with optional power input"
          extends Buildings.Fluid.Interfaces.PartialTwoPortTransport(show_T=false);

          // Quantity to control
          parameter Boolean control_m_flow
            "if true, then the mass flow rate is equal to the value of m_flow_in"
            annotation(Evaluate = true);
          parameter Boolean control_dp = not control_m_flow
            "if true, then the head is equal to the value of dp_in"
            annotation(Evaluate = true);

          Modelica.Blocks.Interfaces.RealInput m_flow_in(unit="kg/s") if control_m_flow
            "Prescribed mass flow rate"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-60,80})));
          Modelica.Blocks.Interfaces.RealInput dp_in(unit="Pa") if control_dp
            "Prescribed pressure difference port_a.p-port_b.p"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={60,80})));

      protected
          Modelica.Blocks.Interfaces.RealInput m_flow_internal(unit="kg/s")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput dp_internal(unit="Pa")
            "Needed to connect to conditional connector";

        equation
          // Ideal control
          if control_m_flow then
            m_flow = m_flow_internal;
          else
            m_flow_internal = 0;
          end if;
          if control_dp then
            dp = dp_internal;
          else
            dp_internal = 0;
          end if;

          connect(dp_internal, dp_in);
          connect(m_flow_internal, m_flow_in);

          // Energy balance (no storage)
          port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
          port_b.h_outflow = inStream(port_a.h_outflow);

          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,50},{100,-48}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  visible=not control_m_flow,
                  extent={{24,44},{80,24}},
                  textColor={255,255,255},
                  textString="dp"),
                Text(
                  visible=control_m_flow,
                  extent={{-80,44},{-24,24}},
                  textColor={255,255,255},
                  textString="m")}),
            Documentation(info="<html>
<p>
Model of a fictitious pipe that is used as a base class
for a pressure source or to prescribe a mass flow rate.
</p>
<p>
Note that for fans and pumps with dynamic balance,
both the heat and the flow work are added to the volume of
air or water. This simplifies the equations compared to
adding heat to the volume, and flow work to this model.
</p>
<p>
Typically either <code>control_m_flow</code> or
<code>control_dp</code> should be <code>true</code> to avoid a
singular system.
If <code>control_m_flow = true</code>, then the mass flow rate
is set to the value of the input connector <code>m_flow_in</code>.
Otherwise, this model does not specify the mass flow rate.
Similarly, if <code>control_dp = true</code>, the head is equal to the
value of the input connector <code>dp_in</code>.
Otherwise, this model does not specify the head.
</p>
</html>",
        revisions="<html>
<ul>
<li>
May 4, 2017, by Filip Jorissen:<br/>
Implemented option to set <code>control_dp</code>
independently from <code>control_m_flow</code>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/770\">#770</a>.
</li>
<li>
March 2, 2017, by Filip Jorissen:<br/>
Implemented simplification when <code>allowFlowReversal=false</code>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/673\">#673</a>.
</li>
<li>
March 20, 2016, by Michael Wetter:<br/>
Corrected documentation for <code>dp_in</code>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Added units to the signal connectors.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
Removed the option to add power to the medium, as this is dealt with in the volume
that is used in the mover model.
</li>
<li>
July 27, 2010 by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>
April 13, 2010 by Michael Wetter:<br/>
Made heat connector optional.
</li>
<li>
March 23, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end IdealSource;

        partial model PartialFlowMachine
          "Partial model to interface fan or pump models with the medium"
          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations(
            final massDynamics=energyDynamics,
            final mSenFac=1);
          extends Buildings.Fluid.Interfaces.PartialTwoPort(
            port_a(
              p(start=Medium.p_default),
              h_outflow(start=h_outflow_start)),
            port_b(
              p(start=p_start),
              h_outflow(start=h_outflow_start)));

          replaceable parameter Buildings.Fluid.Movers.Data.Generic per
            constrainedby Buildings.Fluid.Movers.Data.Generic
            "Record with performance data"
            annotation (choicesAllMatching=true,
              Placement(transformation(extent={{52,60},{72,80}})));

          parameter Buildings.Fluid.Types.InputType inputType = Buildings.Fluid.Types.InputType.Continuous
            "Control input type"
            annotation(Dialog(
              group="Control"));
          parameter Real constInput = 0 "Constant input set point"
            annotation(Dialog(
              group="Control",
              enable=inputType == Buildings.Fluid.Types.InputType.Constant));
          parameter Real stageInputs[:]
            "Vector of input set points corresponding to stages"
            annotation(Dialog(
              group="Control",
              enable=inputType == Buildings.Fluid.Types.InputType.Stages));

          parameter Boolean computePowerUsingSimilarityLaws
            "= true, compute power exactly, using similarity laws. Otherwise approximate.";

          parameter Boolean addPowerToMedium=true
            "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)";

          parameter Boolean nominalValuesDefineDefaultPressureCurve = false
            "Set to true to avoid warning if m_flow_nominal and dp_nominal are used to construct the default pressure curve";

          parameter Modelica.Units.SI.Time tau=1
            "Time constant of fluid volume for nominal flow, used if energy or mass balance is dynamic"
            annotation (Dialog(
              tab="Dynamics",
              group="Nominal condition",
              enable=energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState));

          // Classes used to implement the filtered speed
          parameter Boolean use_inputFilter=true
            "= true, if speed is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered speed"));
          parameter Modelica.Units.SI.Time riseTime=30
            "Rise time of the filter (time to reach 99.6 % of the speed)" annotation (
              Dialog(
              tab="Dynamics",
              group="Filtered speed",
              enable=use_inputFilter));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));

          // Connectors and ports
          Modelica.Blocks.Interfaces.IntegerInput stage
            if inputType == Buildings.Fluid.Types.InputType.Stages
            "Stage input signal for the pressure head"
            annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));

          Modelica.Blocks.Interfaces.RealOutput y_actual(
            final unit="1")
            "Actual normalised fan or pump speed that is used for computations"
            annotation (Placement(transformation(extent={{100,60},{120,80}}),
                iconTransformation(extent={{100,60},{120,80}})));

          Modelica.Blocks.Interfaces.RealOutput P(
            quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
            "Heat dissipation to environment"
            annotation (Placement(transformation(extent={{-70,-110},{-50,-90}}),
                iconTransformation(extent={{-10,-78},{10,-58}})));

          // Variables
          Modelica.Units.SI.VolumeFlowRate VMachine_flow(start=_VMachine_flow) = eff.V_flow
            "Volume flow rate";
          Modelica.Units.SI.PressureDifference dpMachine(displayUnit="Pa") = -preSou.dp
            "Pressure difference";

          Real eta(unit="1", final quantity="Efficiency") =    eff.eta "Global efficiency";
          Real etaHyd(unit="1", final quantity="Efficiency") = eff.etaHyd "Hydraulic efficiency";
          Real etaMot(unit="1", final quantity="Efficiency") = eff.etaMot "Motor efficiency";

          // Quantity to control

          // Copied from Fluid.Interfaces.PartialTwoPortInterface
          parameter Modelica.Units.SI.MassFlowRate m_flow_small(min=0) = 1E-4*abs(
            _m_flow_nominal) "Small mass flow rate for regularization of zero flow"
            annotation (Dialog(tab="Advanced"));
          // Diagnostics
           parameter Boolean show_T = false
            "= true, if actual temperature at port is computed"
            annotation (
              Dialog(tab="Advanced", group="Diagnostics"),
              HideResult=true);

          Modelica.Units.SI.MassFlowRate m_flow(start=_m_flow_start) = port_a.m_flow
            "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";

          Modelica.Units.SI.PressureDifference dp(
            start=_dp_start,
            displayUnit="Pa") = port_a.p - port_b.p
            "Pressure difference between port_a and port_b";

          Medium.ThermodynamicState sta_a=
            if allowFlowReversal then
              Medium.setState_phX(port_a.p,
                                  noEvent(actualStream(port_a.h_outflow)),
                                  noEvent(actualStream(port_a.Xi_outflow)))
            else
              Medium.setState_phX(port_a.p,
                                  noEvent(inStream(port_a.h_outflow)),
                                  noEvent(inStream(port_a.Xi_outflow)))
              if show_T "Medium properties in port_a";

          Medium.ThermodynamicState sta_b=
            if allowFlowReversal then
              Medium.setState_phX(port_b.p,
                                  noEvent(actualStream(port_b.h_outflow)),
                                  noEvent(actualStream(port_b.Xi_outflow)))
            else
              Medium.setState_phX(port_b.p,
                                  noEvent(port_b.h_outflow),
                                  noEvent(port_b.Xi_outflow))
               if show_T "Medium properties in port_b";
          // - Copy continues in protected section

      protected
          parameter Modelica.Units.SI.MassFlowRate _m_flow_nominal=
            max(eff.per.pressure.V_flow)*rho_default
            "Nominal mass flow rate";

          // Copied from Fluid.Interfaces.PartialTwoPortInterface
          final parameter Modelica.Units.SI.MassFlowRate _m_flow_start=0
            "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window";
          final parameter Modelica.Units.SI.PressureDifference _dp_start(displayUnit=
                "Pa") = 0
            "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window";
          // - End of copy

          final parameter Modelica.Units.SI.VolumeFlowRate _VMachine_flow=0
            "Start value for VMachine_flow, used to avoid a warning if not specified";

          parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable preVar "Type of prescribed variable";

          // The parameter speedIsInput is required to conditionally remove the instance gain.
          // If the conditional removal of this instance where to use the test
          // preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed,
          // then OpenModelica fails to translate the model with the message
          // .../PartialFlowMachine.mo:185:3-189:70:writable]
          // Error: Variable Types.PrescribedVariable.Speed not found in scope
          // Buildings.Fluid.Movers.SpeedControlled_y$floMac1.
          final parameter Boolean speedIsInput=
            (preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed)
            "Parameter that is true if speed is the controlled variables";

          final parameter Integer nOri = size(per.pressure.V_flow, 1)
            "Number of data points for pressure curve"
            annotation(Evaluate=true);

          final parameter Boolean haveVMax = eff.haveVMax
            "Flag, true if user specified data that contain V_flow_max";

          final parameter Modelica.Units.SI.VolumeFlowRate V_flow_max=eff.V_flow_max;
          final parameter Modelica.Units.SI.Density rho_default=
            Medium.density_pTX(
              p=Medium.p_default,
              T=Medium.T_default,
              X=Medium.X_default) "Default medium density";

          final parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start,
            p=p_start,
            X=X_start) "Medium state at start values";

          final parameter Modelica.Units.SI.SpecificEnthalpy h_outflow_start=
              Medium.specificEnthalpy(sta_start) "Start value for outflowing enthalpy";

          final parameter Modelica.Units.SI.Frequency fCut=5/(2*Modelica.Constants.pi*
              riseTime) "Cut-off frequency of filter";

          Modelica.Blocks.Sources.Constant[size(stageInputs, 1)] stageValues(
            final k=stageInputs)
           if inputType == Buildings.Fluid.Types.InputType.Stages "Stage input values"
            annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
          Modelica.Blocks.Sources.Constant setConst(
            final k=constInput)
           if inputType == Buildings.Fluid.Types.InputType.Constant
            "Constant input set point"
            annotation (Placement(transformation(extent={{-80,70},{-60,90}})));

          Extractor extractor(final nin=size(stageInputs,1))
           if inputType == Buildings.Fluid.Types.InputType.Stages "Stage input extractor"
            annotation (Placement(transformation(extent={{-50,60},{-30,40}})));

          Modelica.Blocks.Routing.RealPassThrough inputSwitch
            "Dummy connection for easy connection of input options"
            annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                origin={-10,50})));

          Buildings.Fluid.Delays.DelayFirstOrder vol(
            redeclare final package Medium = Medium,
            final tau=tau,
            final energyDynamics=energyDynamics,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final m_flow_nominal=_m_flow_nominal,
            final m_flow_small=m_flow_small,
            final p_start=p_start,
            final prescribedHeatFlowRate=true,
            final allowFlowReversal=allowFlowReversal,
            nPorts=2) "Fluid volume for dynamic model"
            annotation (Placement(transformation(extent={{-70,0},{-90,20}})));

          Buildings.Fluid.BaseClasses.ActuatorFilter filter(
            final n=2,
            final f=fCut,
            final normalized=true,
            final initType=init) if use_inputFilter
            "Second order filter to approximate dynamics of the fan or pump's speed, and to improve numerics"
            annotation (Placement(transformation(extent={{20,61},{40,80}})));

          Buildings.Fluid.Movers.BaseClasses.IdealSource preSou(
            redeclare final package Medium = Medium,
            final m_flow_small=m_flow_small,
            final allowFlowReversal=allowFlowReversal,
            final control_m_flow= (preVar ==  Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate))
            "Pressure source"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));

          Buildings.Fluid.Movers.BaseClasses.PowerInterface heaDis(
            final motorCooledByFluid=per.motorCooledByFluid,
            final delta_V_flow=1E-3*V_flow_max)
           if addPowerToMedium "Heat dissipation into medium"
            annotation (Placement(transformation(extent={{20,-80},{40,-60}})));

          Modelica.Blocks.Math.Add PToMed(final k1=1, final k2=1)
         if addPowerToMedium "Heat and work input into medium"
            annotation (Placement(transformation(extent={{50,-90},{70,-70}})));

          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prePow(
            final alpha=0)
         if addPowerToMedium
            "Prescribed power (=heat and flow work) flow for dynamic model"
            annotation (Placement(transformation(extent={{-14,-104},{-34,-84}})));

          Modelica.Blocks.Sources.RealExpression rho_inlet(y=
            Medium.density(
              Medium.setState_phX(port_a.p,
                                  inStream(port_a.h_outflow),
                                  inStream(port_a.Xi_outflow))))
            "Density of the inflowing fluid"
            annotation (Placement(transformation(extent={{-90,-74},{-70,-54}})));

          Buildings.Fluid.Sensors.MassFlowRate senMasFlo(
            redeclare final package Medium = Medium) "Mass flow rate sensor"
            annotation (Placement(transformation(extent={{-50,10},{-30,-10}})));

          Buildings.Fluid.Sensors.RelativePressure senRelPre(
            redeclare final package Medium = Medium) "Head of mover"
            annotation (Placement(transformation(extent={{58,-27},{43,-14}})));

          // Because the speed data are not used by FlowMachineInterface, we set them
          // to zero.
          Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface eff(
            per(
              final powerOrEfficiencyIsHydraulic = per.powerOrEfficiencyIsHydraulic,
              final efficiency =           per.efficiency,
              final motorEfficiency =      per.motorEfficiency,
              final motorEfficiency_yMot = per.motorEfficiency_yMot,
              final motorCooledByFluid =   per.motorCooledByFluid,
              final speed_nominal =        0,
              final constantSpeed =        0,
              final speeds =               {0},
              final power =                per.power,
              final peak =                 per.peak),
            final nOri = nOri,
            final rho_default=rho_default,
            final computePowerUsingSimilarityLaws=computePowerUsingSimilarityLaws,
            r_V(start=_m_flow_nominal/rho_default),
            final preVar=preVar) "Flow machine"
            annotation (Placement(transformation(extent={{-32,-68},{-12,-48}})));

      protected
          block Extractor
            "Extract scalar signal out of signal vector dependent on IntegerRealInput index"
            extends Modelica.Blocks.Interfaces.MISO;

            Modelica.Blocks.Interfaces.IntegerInput index "Integer input for control input"
            annotation (Placement(
                  transformation(
                  origin={0,-120},
                  extent={{-20,-20},{20,20}},
                  rotation=90)));
          equation
          y = sum({if index == i then u[i] else 0 for i in 1:nin});

          annotation (Icon(graphics={
                  Rectangle(
                    extent={{-80,50},{-40,-50}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-84.4104,1.9079},{-84.4104,-2.09208},{-80.4104,-0.09208},{
                        -84.4104,1.9079}},
                    lineColor={0,0,127},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-62,2},{-50.1395,12.907},{-39.1395,12.907}}, color={0,0,
                        127}),
                  Line(points={{-63,4},{-49,40},{-39,40}}, color={0,0,127}),
                  Line(points={{-102,0},{-65.0373,-0.01802}}, color={0,0,127}),
                  Ellipse(
                    extent={{-70.0437,4.5925},{-60.0437,-4.90745}},
                    lineColor={0,0,127},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-63,-5},{-50,-40},{-39,-40}}, color={0,0,127}),
                  Line(points={{-62,-2},{-50.0698,-12.907},{-39.0698,-12.907}}, color={
                        0,0,127}),
                  Polygon(
                    points={{-38.8808,-11},{-38.8808,-15},{-34.8808,-13},{-38.8808,-11}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-39,42},{-39,38},{-35,40},{-39,42}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-38.8728,-38.0295},{-38.8728,-42.0295},{-34.8728,-40.0295},
                        {-38.8728,-38.0295}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-38.9983,14.8801},{-38.9983,10.8801},{-34.9983,12.8801},{-38.9983,
                        14.8801}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-30,50},{30,-50}},
                    fillColor={235,235,235},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{100,0},{0,0}}, color={0,0,127}),
                  Line(points={{0,2},{0,-104}}, color={255,128,0}),
                  Line(points={{-35,40},{-20,40}}, color={0,0,127}),
                  Line(points={{-35,13},{-20,13}}, color={0,0,127}),
                  Line(points={{-35,-13},{-20,-13}}, color={0,0,127}),
                  Line(points={{-35,-40},{-20,-40}}, color={0,0,127}),
                  Polygon(points={{0,0},{-20,13},{-20,13},{0,0},{0,0}}, lineColor={0,0,
                        127}),
                  Ellipse(
                    extent={{-6,6},{6,-6}},
                    lineColor={255,128,0},
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid)}));
          end Extractor;

        initial algorithm
          // The control signal is dp or m_flow but the user did not provide a fan or pump curve.
          // Hence, the speed is computed using default values, which likely are wrong.
          // Therefore, scaling the power using the speed is inaccurate.
          assert(nominalValuesDefineDefaultPressureCurve or
                 per.havePressureCurve or
                 (preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed),
        "*** Warning in " + getInstanceName() +
        ": Mover is flow or pressure controlled and uses default pressure curve.
This leads to an approximate power consumption.
Set nominalValuesDefineDefaultPressureCurve=true to suppress this warning.",
                 level=AssertionLevel.warning);

          // The control signal is dp or m_flow but the user did not provide a fan or pump curve.
          // Hence, the speed is computed using default values, which likely are wrong.
          // In addition, the user wants to use (V_flow, P) to compute the power.
          // This can lead to using a power that is less than the flow work. We avoid
          // this by ignoring the setting of per.etaHydMet.
          // The comment is split into two parts since otherwise the JModelica C-compiler
          // throws warnings.
          assert(nominalValuesDefineDefaultPressureCurve or
                 (per.havePressureCurve or
                   (preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed)) or
                 per.etaHydMet<>
              Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Power_VolumeFlowRate,
        "*** Warning in " + getInstanceName() +
        ": Mover is flow or pressure controlled, uses default pressure curve and
has per.etaHydMet=.Power_VolumeFlowRate.
As this can cause wrong power consumption, the model overrides this setting by using per.etaHydMet=.NotProvided.
Set nominalValuesDefineDefaultPressureCurve=true to suppress this warning.",
                 level=AssertionLevel.warning);

          assert(per.havePressureCurve or
                  not (per.etaHydMet ==
                       Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.Power_VolumeFlowRate
                    or per.etaHydMet ==
                       Buildings.Fluid.Movers.BaseClasses.Types.HydraulicEfficiencyMethod.EulerNumber),
        "*** Warning in " + getInstanceName() +
        ": Mover has per.etaHydMet=.Power_VolumeFlowRate or per.etaHydMet=.EulerNumber.
This requires per.pressure to be provided.
Because it is not, the model overrides this setting by using per.etaHydMet=.NotProvided.
Also consider using models under Movers.Preconfigured which autopopulate a pressure curve.",
                 level=AssertionLevel.warning);

          assert(per.havePressureCurve or per.haveWMot_nominal or
                  not (per.etaMotMet ==
                       Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio
                    or per.etaMotMet ==
                       Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve),
        "*** Warning in " + getInstanceName() +
        ": Mover has per.etaMotMet=.Efficiency_MotorPartLoadRatio or per.etaMotMet=.GenericCurve.
This requires per.WMot_nominal or per.pressure to be provided. Because neither is provided,
the model overrides this setting and by using per.etaMotMet=.NotProvided.
Also consider using models under Movers.Preconfigured which autopopulate a pressure curve.",
                 level=AssertionLevel.warning);

          assert(per.powerOrEfficiencyIsHydraulic or
                  not (per.etaMotMet ==
                       Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.Efficiency_MotorPartLoadRatio
                    or per.etaMotMet ==
                       Buildings.Fluid.Movers.BaseClasses.Types.MotorEfficiencyMethod.GenericCurve),
        "*** Warning in " + getInstanceName() +
        ": Mover has per.etaMotMet=.Efficiency_MotorPartLoadRatio or per.etaMotMet=.GenericCurve
and provides information for total electric power instead of hydraulic power.
This forms an algebraic loop. If simulation fails to converge,
see the \"Motor efficiency\" section in the users guide for how to correct it.",
                 level=AssertionLevel.warning);

        equation
          connect(prePow.port, vol.heatPort) annotation (Line(
              points={{-34,-94},{-60,-94},{-60,10},{-70,10}},
              color={191,0,0}));

          connect(vol.heatPort, heatPort) annotation (Line(
              points={{-70,10},{-70,10},{-60,10},{-60,-100}},
              color={191,0,0}));
          connect(preSou.port_b, port_b) annotation (Line(
              points={{60,0},{100,0}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(stageValues.y, extractor.u) annotation (Line(
              points={{-59,50},{-52,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(extractor.y, inputSwitch.u) annotation (Line(
              points={{-29,50},{-22,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(setConst.y, inputSwitch.u) annotation (Line(
              points={{-59,80},{-26,80},{-26,50},{-22,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(extractor.index, stage) annotation (Line(
              points={{-40,62},{-40,90},{0,90},{0,120}},
              color={255,127,0},
              smooth=Smooth.None));

          connect(PToMed.y, prePow.Q_flow) annotation (Line(points={{71,-80},{80,-80},{80,
                  -94},{-14,-94}},                 color={0,0,127}));
          connect(PToMed.u1, heaDis.Q_flow) annotation (Line(points={{48,-74},{44,-74},{
                  44,-72},{44,-70},{41,-70}},
                                     color={0,0,127}));

          connect(senRelPre.port_b, preSou.port_a) annotation (Line(points={{43,-20.5},{
                  20,-20.5},{20,0},{40,0}},
                                       color={0,127,255}));
          connect(senRelPre.port_a, preSou.port_b) annotation (Line(points={{58,-20.5},{
                  80,-20.5},{80,0},{60,0}},
                                       color={0,127,255}));
          connect(heaDis.V_flow,eff. V_flow) annotation (Line(points={{18,-60},{14,-60},
                  {14,-52},{-11,-52}},       color={0,0,127}));
          connect(eff.PEle, heaDis.PEle) annotation (Line(points={{-11,-60},{0,-60},{0,
                  -80},{18,-80}}, color={0,0,127}));
          connect(eff.WFlo, heaDis.WFlo) annotation (Line(points={{-11,-56},{4,-56},{4,
                  -66},{18,-66}}, color={0,0,127}));
          connect(rho_inlet.y,eff. rho) annotation (Line(points={{-69,-64},{-69,-64},{-34,
                  -64}},                          color={0,0,127}));
          connect(eff.m_flow, senMasFlo.m_flow) annotation (Line(points={{-34,-54},{-34,
                  -54},{-40,-54},{-40,-11}},               color={0,0,127}));
          connect(eff.WFlo, PToMed.u2) annotation (Line(points={{-11,-56},{4,-56},{4,
                  -86},{48,-86}}, color={0,0,127}));
          connect(inputSwitch.y, filter.u) annotation (Line(points={{1,50},{12,50},{12,70.5},
                  {18,70.5}},     color={0,0,127}));

          connect(senRelPre.p_rel, eff.dp_in) annotation (Line(points={{50.5,-26.35},{50.5,
                  -38},{-18,-38},{-18,-46}},               color={0,0,127}));
          connect(eff.y_out, y_actual) annotation (Line(points={{-11,-48},{92,-48},{92,
                  70},{110,70}},
                             color={0,0,127}));
          connect(port_a, vol.ports[1])
            annotation (Line(points={{-100,0},{-79,0},{-79,0}}, color={0,127,255}));
          connect(vol.ports[2], senMasFlo.port_a)
            annotation (Line(points={{-81,0},{-81,0},{-50,0}}, color={0,127,255}));
          connect(senMasFlo.port_b, preSou.port_a)
            annotation (Line(points={{-30,0},{40,0},{40,0}}, color={0,127,255}));
          connect(eff.WHyd, heaDis.WHyd) annotation (Line(points={{-11,-58},{2,-58},{2,
                  -74},{18,-74}}, color={0,0,127}));
          connect(eff.PEle, P) annotation (Line(points={{-11,-60},{0,-60},{0,-50},{90,
                  -50},{90,90},{110,90}},
                                     color={0,0,127}));
           annotation(Icon(coordinateSystem(preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}),
            graphics={
                Line(
                  points={{0,70},{100,70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,90},{100,90}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}}),
                Rectangle(
                  extent={{-100,16},{100,-16}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Ellipse(
                  extent={{-58,58},{58,-58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,100,199}),
                Polygon(
                  points={{0,50},{0,-50},{54,0},{0,50}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{4,16},{36,-16}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  visible=energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState,
                  fillColor={0,100,199}),
                Text(extent={{64,106},{114,92}},
                  textColor={0,0,127},
                  textString="P"),
                Text(extent={{42,86},{92,72}},
                  textColor={0,0,127},
                  textString="y_actual"),
                Line(
                  points={{0,100},{0,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  visible=use_inputFilter,
                  extent={{-32,40},{34,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=use_inputFilter,
                  extent={{-32,100},{34,40}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=use_inputFilter,
                  extent={{-20,92},{22,46}},
                  textColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold})}),
            Documentation(info="<html>
<p>
This is the base model for fans and pumps.
It provides an interface
between the equations that compute head and power consumption,
and the implementation of the energy and pressure balance
of the fluid.
</p>
<p>
Optionally, the fluid volume
is computed using a dynamic balance or a steady-state balance.
</p>
<p>
The parameter <code>addPowerToMedium</code> determines whether
any power is added to the fluid. The default is <code>addPowerToMedium=true</code>,
and hence the outlet enthalpy is higher than the inlet enthalpy if the
flow device is operating.
The setting <code>addPowerToMedium=false</code> is physically incorrect
(since the flow work, the flow friction and the fan heat do not increase
the enthalpy of the medium), but this setting does in some cases lead to simpler equations
and more robust simulation, in particular if the mass flow is equal to zero.
</p>
<p>
In the previous implementation, this model extends from
<a href=\"Modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>.
Now it copies much of the code instead.
This is to resolve a potential circular parameter binding that occurs when
<a href=\"Modelica://Buildings.Fluid.Movers.Preconfigured.SpeedControlled_y\">
Buildings.Fluid.Movers.Preconfigured.SpeedControlled_y</a>
extends from
<a href=\"Modelica://Buildings.Fluid.Movers.SpeedControlled_y\">
Buildings.Fluid.Movers.SpeedControlled_y</a>.
The former uses the nominal flow rate provided by user to construct
the pressure curve, whilst the latter uses the user-provided pressure curve
to determine the nominal flow rate. The new implementation removes the
original declaration of nominal flow rate from
<a href=\"Modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>
and hides it (<code>protected _m_flow_nominal</code>) from the user.
This way, A higher-level model (e.g.
<a href=\"Modelica://Buildings.Fluid.Movers.FlowControlled_dp\">
Buildings.Fluid.Movers.FlowControlled_dp</a>),
can still provide a default but not the other way around.
See discussions in
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1705\">#1705</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 29, 2023, by Hongxiang Fu:<br/>
Removed the gain block that normalised the speed input
because it is no longer needed. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1704\">IBPSA, #1704</a>.
</li>
<li>
March 1, 2023, by Hongxiang Fu:<br/>
Instead of extending
<a href=\"Modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>,
this model now has its code copied, then rewrote <code>m_flow_nominal</code>
as <code>protected _m_flow_nominal</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1705\">#1705</a>.
</li>
<li>
May 6, 2022, by Hongxiang Fu:<br/>
<ul>
<li>
Moved <code>haveVMax</code> from here to
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>
and <code>V_flow_max</code> from here to
<a href=\"modelica://Buildings.Fluid.Movers.Data.Generic\">
Buildings.Fluid.Movers.Data.Generic</a>.
</li>
<li>
Added <code>per.peak</code>, <code>per.totalEfficiency,</code>,
<code>per.motorEfficiency_yMot</code>to be also passed down to <code>eff.per</code>
at instantiation.
</li>
<li>
Added an <code>assert()</code> warning when the model has to make an unreliable
guess for efficiency computation using <code>.EulerNumber</code>.
</li>
<li>
Added an <code>assert()</code> warning when the model has to override
<code>per.etaMotMet</code>.
</li>
</ul>
These are for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
<li>
June 17, 2021, by Michael Wetter:<br/>
Changed implementation of the filter.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
January 22, 2019, by Filip Jorissen:<br/>
Split long assert output string into two strings to avoid compiler warnings
in JModelica.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1081\">#1081</a>.
</li>
<li>
January 8, 2019, by Filip Jorissen:<br/>
Added assert for value of <code>m_flow_nominal</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/908\">#908</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Set start value for <code>VMachine_flow</code> to avoid a warning in
<a href=\"modelica://Buildings.Fluid.Movers.Examples.MoverContinuous\">
Buildings.Fluid.Movers.Examples.MoverContinuous</a>.
</li>
<li>
July 29, 2016, by Michael Wetter:<br/>
Made <code>Extractor</code> protected so that it can be removed later
with a backwards compatible change.
</li>
<li>
July 19, 2016, by Filip Jorissen:<br/>
Created custom implementation for extractor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/498\">#498</a>.
</li>
<li>
June 16, 2016, by Filip Jorissen:<br/>
Switched position of mixing volume and mass flow rate sensor.
This is to have a consistent operating point tuple
of <code>dp</code> and <code>m_flow</code> when having
compressible flow.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
February 19, 2016, by Michael Wetter and Filip Jorissen:<br/>
Refactored model to make implementation clearer.
This model now includes code for both speed and flow prescribed models,
eliminating the need for an additional level of partial models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
Removed the parameter <code>dynamicBalance</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/411\">#411</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
Removed assignment of <code>min</code> and <code>max</code> attributes
of the port mass flow rate as this is already done in the base class.
Removed <code>import</code> statement.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
Added code for displaying constant set point in symbol.
</li>
<li>
January 24, 2015, by Michael Wetter:<br/>
Propagated <code>m_flow_small</code> of instance <code>vol</code> and made
all its parameters final.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 29, 2010, by Michael Wetter:<br/>
Reduced fan time constant from 10 to 1 second.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialFlowMachine;

        model PowerInterface
          "Partial model to compute power draw and heat dissipation of fans and pumps"
          extends Modelica.Blocks.Icons.Block;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Boolean motorCooledByFluid
            "Flag, true if the motor is cooled by the fluid stream";

          parameter Modelica.Units.SI.VolumeFlowRate delta_V_flow
            "Factor used for setting heat input into medium to zero at very small flows";

          Modelica.Blocks.Interfaces.RealInput V_flow(
            final quantity="VolumeFlowRate",
            final unit="m3/s") "Volume flow rate"
            annotation (Placement(transformation(extent={{-140,80},{-100,120}}),
                iconTransformation(extent={{-140,80},{-100,120}})));

          Modelica.Blocks.Interfaces.RealInput WFlo(
            final quantity="Power",
            final unit="W") "Flow work"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
                iconTransformation(extent={{-140,20},{-100,60}})));

          Modelica.Blocks.Interfaces.RealInput WHyd(final quantity="Power", final unit="W")
            "Hydraulic work (converted to flow work and heat)" annotation (Placement(
                transformation(extent={{-140,-60},{-100,-20}}), iconTransformation(
                  extent={{-140,-60},{-100,-20}})));

          Modelica.Blocks.Interfaces.RealInput PEle(
            final quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{-140,-120},{-100,-80}})));

          Modelica.Blocks.Interfaces.RealOutput Q_flow(
            quantity="Power",
            final unit="W") "Heat input from fan or pump to medium"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      protected
          Modelica.Units.SI.HeatFlowRate QThe_flow
            "Heat input from fan or pump to medium";

          Modelica.Units.SI.Efficiency etaHyd
            "Hydraulic efficiency";

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          // Hydraulic power (transmitted by shaft), etaHyd = WFlo/WHyd
          etaHyd = WFlo / Buildings.Utilities.Math.Functions.smoothMax(
                             x1=WHyd, x2=1E-5, deltaX=1E-6);
          // Heat input into medium
          QThe_flow +  WFlo = if motorCooledByFluid then PEle else WHyd;
          // At m_flow = 0, the solver may still obtain positive values for QThe_flow.
          // The next statement sets the heat input into the medium to zero for very small flow rates.
          Q_flow = if homotopyInitialization then
            homotopy(actual=Buildings.Utilities.Math.Functions.regStep(
                              y1=QThe_flow,
                              y2=0,
                              x=noEvent(abs(V_flow))-2*delta_V_flow,
                              x_small=delta_V_flow),
                    simplified=0)
            else
              Buildings.Utilities.Math.Functions.regStep(
                              y1=QThe_flow,
                              y2=0,
                              x=noEvent(abs(V_flow))-2*delta_V_flow,
                              x_small=delta_V_flow);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
            Line( origin={-49.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Line( origin={0.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Line( origin={50.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Polygon(
            origin={48,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0}),
            Polygon(
            origin={-2,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0}),
            Polygon(
            origin={-52,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0})}),
            Documentation(info="<html>
<p>Block that implements the functions to compute the
heat dissipation of fans and pumps. It is used by the model
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine\">
Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
March 8, 2022, by Hongxiang Fu:<br/>
This model no longer computes <code>WHyd</code>.
It now takes <code>WHyd</code> instead of <code>etaHyd</code> as an input from
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
February 19, 2016, by Michael Wetter:<br/>
First implementation during refactoring of mover models to make implementation clearer.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
</ul>
</html>"));
        end PowerInterface;

        package Characteristics "Functions for fan or pump characteristics"

          function efficiency "Flow vs. efficiency characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per
              "Efficiency performance data";
            input Modelica.Units.SI.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real d[:] "Derivatives at support points for spline interpolation";
            input Real r_N(unit="1") "Relative speed";
            input Real delta "Small value for switching implementation around zero speed";
            output Real eta(unit="1", final quantity="Efficiency") "Efficiency";

        protected
            Integer n = size(per.V_flow, 1) "Number of data points";
            Real rat "Ratio of V_flow/r_N";
            Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              eta := per.eta[1];
            else
              // The use of the max function avoids problems with low speeds
              // and turned-off pumps
              rat:=V_flow/
                      Buildings.Utilities.Math.Functions.smoothMax(
                        x1=r_N,
                        x2=0.1,
                        deltaX=delta);
              i :=1;
              for j in 1:n-1 loop
                 if rat > per.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              eta:=Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=per.V_flow[i],
                          x2=per.V_flow[i + 1],
                          y1=per.eta[i],
                          y2=per.eta[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;

            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan or pump efficiency for given normalized volume flow rate
and performance data. The efficiency is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &eta; = s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>&eta;</i> is the efficiency,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate, and
<i>d</i> are performance data for fan or pump efficiency.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>", revisions="<html>
<ul>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Corrected documentation as curve uses <i>V&#775;</i>
as an independent variable.
</li>
<li>
September 30, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>V_flow</code>
instead of <code>r_V</code>.
</li>
<li>
April 19, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>r_V/r_N</code>
instead of <code>r_V</code> to properly account for the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiency;

          function efficiency_yMot
            "Efficiency vs. motor PLR characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input
              Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters_yMot
              per "Efficiency performance data";
            input Real y "Motor part load ratio, y = PEle/PEle_nominal";
            input Real d[:] "Derivatives at support points for spline interpolation";
            output Real eta(unit="1", final quantity="Efficiency") "Efficiency";

        protected
            Integer n = size(per.y, 1) "Number of data points";
            Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              eta := per.eta[1];
            else
              i :=1;
              for j in 1:n-1 loop
                 if y > per.y[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              eta:=Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=y,
                          x1=per.y[i],
                          x2=per.y[i + 1],
                          y1=per.eta[i],
                          y2=per.eta[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;

            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function is similar to
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency\">
Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency</a>,
but takes the motor part load ratio
<i>y=P<sub>ele</sub> &frasl; P<sub>ele,nominal</sub></i>
instead of volumetric flow rate <i>V&#775;</i> as input
and does not consider the speed of the mover.
</p>
</html>", revisions="<html>
<ul>
<li>
March 2, 2022, by Hongxiang Fu:<br/>
First implementation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));
          end efficiency_yMot;

          function motorEfficiencyCurve
            "This function generates the generic curve for motor efficiency based on rated motor power"
            extends Modelica.Icons.Function;
            input Modelica.Units.SI.Power P_nominal "Rated input power of the motor";
            input Modelica.Units.SI.Efficiency eta_max "Maximum motor efficiency";
            // Below, default values are assigned so that that dimensions are known.
            output Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters_yMot
              motorEfficiency_yMot(
                  y={0, 0.1, 0.2, 0.3, 0.4, 0.6, 0.8, 1, 1.2},
                  eta=zeros(nPoi)) "Motor efficiency vs. motor part load ratio";

        protected
            constant Modelica.Units.SI.Power u2[nSiz]={700, 2500, 7500, 15000, 35000, 70000, 80000, 90000}
              "Rated motor input power";
            constant Integer nSiz=8 "Number of motor sizes";
            constant Integer nPoi=9 "Size";
            // Two rows and two columns of 1 are added to the ends of the table in order to
            //   prevent the lookup table from producing values larger than 1.
            constant Real[nPoi, nSiz] tab=
              [             1E-6,              1E-6,              1E-6,              1E-6,              1E-6,              1E-6, 1E-6, 1E-6;
               0.319836509737628, 0.329886760993909, 0.458027464511497, 0.576112127457564, 0.643957112752703, 0.724359122802955,    1,    1;
               0.551721742352314, 0.613279531297038, 0.752726767477942, 0.843179028784475, 0.903480536322164, 0.962525762452817,    1,    1;
               0.716480140443274, 0.804199438688888, 0.886622050343885, 0.936873306625292, 0.956973809137855, 0.987124562906699,    1,    1;
               0.816999745270129, 0.922527383461084, 0.950165574415858, 0.980316328184702,                 1,                 1,    1,    1;
               0.906409929833499,                 1,                 1,                 1,                 1,                 1,    1,    1;
               0.956863812148299,                 1,                 1,                 1,                 1,                 1,    1,    1;
                               1,                 1,                 1,                 1,                 1,                 1,    1,    1;
                               1,                 1,                 1,                 1,                 1,                 1,    1,    1]
              "Generic motor efficiency table (eta / eta_max)";
          algorithm
            if P_nominal>1E-6 then
              for j in 1:nPoi loop
                motorEfficiency_yMot.eta[j]:=eta_max * Buildings.Utilities.Math.Functions.smoothInterpolation(
                  x=P_nominal,
                  xSup=u2,
                  ySup=tab[j, :],
                  ensureMonotonicity=true);
              end for;
            else
              motorEfficiency_yMot.eta := 0.7*ones(nPoi);
            end if;

          annotation (Documentation(info="<html>
<p>
This function generates a generic motor efficiency curve based on the
rated motor power input and maximum motor efficiency according to U.S. DOE (2014)
(shown below). It returns a constant array if the rated power is unavailable.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Fluid/Movers/BaseClasses/Characteristics/MotorEfficiencyCurves.png\"
width=\"500\"/>
</p>
<h4>References</h4>
<p>
U.S. DOE (2014).
<i>Determining Electric Motor Load and Efficiency.</i>
URL:
<a href=\"https://www.energy.gov/sites/prod/files/2014/04/f15/10097517.pdf\">
https://www.energy.gov/sites/prod/files/2014/04/f15/10097517.pdf</a>
</p>
</html>",           revisions="<html>
<ul>
<li>April 5, by Hongxiang Fu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));
          end motorEfficiencyCurve;

          function power "Flow vs. electrical power characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters per
              "Pressure performance data";
            input Modelica.Units.SI.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative speed";
            input Real d[:] "Derivatives at support points for spline interpolation";
            input Real delta "Small value for switching implementation around zero speed";
            output Modelica.Units.SI.Power P "Power consumption";

        protected
             Integer n=size(per.V_flow, 1) "Dimension of data vector";

            Modelica.Units.SI.VolumeFlowRate rat "Ratio of V_flow/r_N";
             Integer i "Integer to select data interval";

          algorithm
            if n == 1 then
              P := r_N^3*per.P[1];
            else
              i :=1;
              // The use of the max function to avoids problems for low speeds
              // and turned off pumps
              rat:=V_flow/
                      Buildings.Utilities.Math.Functions.smoothMax(
                        x1=r_N,
                        x2=0.1,
                        deltaX=delta);
              for j in 1:n-1 loop
                 if rat > per.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              P:=r_N^3*Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=per.V_flow[i],
                          x2=per.V_flow[i + 1],
                          y1=per.P[i],
                          y2=per.P[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;
            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan power consumption for given volume flow rate,
speed and performance data. The power consumption is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  P = r<sub>N</sub><sup>3</sup> &nbsp; s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>P</i> is the power consumption,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>V_flow/r_N</code>
instead of <code>V_flow</code> to properly account for the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end power;

          function pressure
            "Pump or fan head away from the origin without correction for mover flow resistance"
            extends Modelica.Icons.Function;

            input Modelica.Units.SI.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real d[:] "Derivatives of flow rate vs. pressure at the support points";
            input Modelica.Units.SI.PressureDifference dpMax(displayUnit="Pa")
              "Maximum pressure drop at nominal speed, for regularisation";
            input Modelica.Units.SI.VolumeFlowRate V_flow_max
              "Maximum flow rate at nominal speed, for regularisation";
            input Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal per
              "Pressure performance data";

            output Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
              "Pressure raise";

        protected
            constant Real delta = 0.05
              "Small number for r_N below which we don't care about the affinity laws";
            constant Real delta2 = delta/2 "= delta/2";
            Real r_R(unit="1") "Relative revolution, bounded below by delta";
            Integer i "Integer to select data interval";
            Modelica.Units.SI.VolumeFlowRate rat "Ratio of V_flow/r_R";

          algorithm
            // For r_N < delta, we restrict r_N in the term V_flow/r_N.
            // This is done using a cubic spline in a region 0.75*delta < r_N < 1.25*r_N
            // We call this restricted value r_R
            if r_N > delta then
              r_R :=r_N;
            elseif r_N < 0 then
              r_R := delta2;
            else
              // Restrict r_N using a spline
              r_R :=Modelica.Fluid.Utilities.cubicHermite(
                x=r_N,
                x1=0,
                x2=delta,
                y1=delta2,
                y2=delta,
                y1d=0,
                y2d=1);
            end if;

            i :=1;

            rat := V_flow/r_R;
            for j in 1:size(d, 1)-1 loop
              if rat > per.V_flow[j] then
                i := j;
              end if;
            end for;
            // In the assignment below,
            // dp -> 0 as r_N -> 0 quadratically, because rat is bounded
            // by the above regularization
            if r_N>=0 then
              dp:=r_N^2*Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                        x=rat,
                        x1=per.V_flow[i],
                        x2=per.V_flow[i + 1],
                        y1=per.dp[i],
                        y2=per.dp[i + 1],
                        y1d=d[i],
                        y2d=d[i+1]);
            else
              dp:=-r_N^2*(dpMax-dpMax/V_flow_max*V_flow);
            end if;
          annotation(smoothOrder=1,
          Documentation(info="<html>
<p>
This function computes the fan static
pressure raise as a function of volume flow rate and revolution in the form
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = r<sub>N</sub><sup>2</sup> &nbsp; s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>&Delta;p</i> is the pressure rise,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
<p>
The function allows <i>r<sub>N</sub></i> to be zero.
</p>
</html>",   revisions="<html>
<ul>
<li>
September 8, 2016, by Michael Wetter and Filip Jorissen:<br/>
Changed implementation to allow <code>r_N = 0</code>.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
September 7, 2016, by Michael Wetter:<br/>
Moved function which was a protected function to make it public, as it
is now called by
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>.
</li>
</ul>
</html>"));
          end pressure;

          record efficiencyParameters
            "Record for efficiency parameters vs. volumetric flow rate"
            extends Modelica.Icons.Record;
            parameter Modelica.Units.SI.VolumeFlowRate V_flow[:](each min=0)
              "Volumetric flow rate at user-selected operating points";
            parameter Modelica.Units.SI.Efficiency eta[size(V_flow, 1)](each max=1)
              "Fan or pump efficiency at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe efficiency
versus volumetric flow rate.
The volume flow rate <code>r_V</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>eta</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiencyParameters;

          record efficiencyParameters_yMot
            "Record for efficiency parameters vs. motor part load ratio"
            extends Modelica.Icons.Record;
            parameter Real y[:](each min=0)
              "Part load ratio, y = PEle/PEle_nominal";
            parameter Modelica.Units.SI.Efficiency eta[size(y, 1)](each max=1)
              "Fan or pump efficiency at these part load ratios";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe efficiency versus part load ratio.
This is used a method to describe the motor efficiency <code>etaMot</code>.
The PLR <code>y</code> must be increasing, i.e.,
<code>y[i] &lt; y[i+1]</code>.
Both vectors, <code>y</code> and <code>eta</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
March 2, 2022, by Hongxiang Fu:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiencyParameters_yMot;

          record flowParameters "Record for flow parameters"
            extends Modelica.Icons.Record;

            parameter Modelica.Units.SI.VolumeFlowRate V_flow[:](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.Units.SI.PressureDifference dp[size(V_flow, 1)](each min=0,
                each displayUnit="Pa") "Fan or pump total pressure at these flow rates";

            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end flowParameters;

          record flowParametersInternal "Record for flow parameters with prescribed size"
            extends Modelica.Icons.Record;
            parameter Integer n "Number of elements in each array"
             annotation(Evaluate=true);
            parameter Modelica.Units.SI.VolumeFlowRate V_flow[n](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.Units.SI.PressureDifference dp[n](each min=0, each
                displayUnit="Pa") "Fan or pump total pressure at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
<p>
This record is identical to
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters\">
Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters</a>,
except that it takes the size of the array as a parameter. This is required
in Dymola 2014. Otherwise, the array size would need to be computed in
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>
in the <code>initial algorithm</code> section, which is not supported.
</p>
</html>", revisions="<html>
<ul>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
March 22, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end flowParametersInternal;

          record powerParameters "Record for electrical power parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.Units.SI.VolumeFlowRate V_flow[:](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.Units.SI.Power P[size(V_flow, 1)](each min=0)
              "Fan or pump electrical power at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
electrical power.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>P</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
October 10, 2012, by Michael Wetter:<br/>
Fixed wrong <code>displayUnit</code> and
<code>max</code> attribute for power.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end powerParameters;
          annotation (Documentation(info="<html>
<p>
This package implements performance curves for fans and pumps,
and records for parameter that can be used with these performance
curves.
</p>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for information about these performance curves.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 8, 2016, by Michael Wetter:<br/>
Deleted function <code>performanceCurve</code> as it is no longer needed. Instead, the function
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure\">
Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure</a>
is used for all speeds.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
September 29, 2011, by Michael Wetter:<br/>
New implementation due to changes from polynomial to cubic hermite splines.
</li>
</ul>
</html>"));
        end Characteristics;

        package Euler "Functions and data record templates for Euler number"

          function correlation
            "Correlation of static efficiency ratio vs log of Euler number ratio"
            extends Modelica.Icons.Function;
            input Real x "log10(Eu/Eu_peak)";
            output Real y "eta/eta_peak";

        protected
            Real a "Polynomial coefficient";
            Real b "Polynomial coefficient";
            Real c "Polynomial coefficient";
            Real d "Polynomial coefficient";
            Real y1 "eta/eta_peak";
          algorithm
            if x < -0.5 then
              a := 0.05687322707407;
              b := 0.493231336746;
              c := 1.433531254001;
              d := 1.407887300933;
            elseif x > 0.5 then
              a := -8.5494313567465000E-3;
              b := 1.2957001502368300E-1;
              c := -6.5997315029278200E-1;
              d := 1.13993003013131;
            else
              a := 0.37824577860088;
              b := -0.75988502317361;
              c := -0.060614519563716;
              d := 1.01426507307139;
            end if;
            y1 := (a*x^3 + b*x^2 + c*x + d) / 1.01545;
            // y1 is almost always bounded away from zero,
            // hence we make a test to see whether we indeed
            // need to call smoothMax or can avoid its overhead
            y := if y1 > 0.002 then y1 else
              Buildings.Utilities.Math.Functions.smoothMax(
                x1=y1,
                x2=0.001,
                deltaX=0.0005);

            annotation(smoothOrder = 1,
            Documentation(info="<html>
<p>
This function approximates the following correlation:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Fluid/Movers/BaseClasses/Euler/eulerCorrelation.svg\"/>
</p>
<p>
where <i>y=&eta; &frasl; &eta;<sub>p</sub></i> (note that <i>&eta;</i>
refers to the hydraulic efficiency instead of total efficiency),
<i>x=log<sub>10</sub>(Eu &frasl; Eu<sub>p</sub>)</i>,
with the subscript <i>p</i> denoting the condition where
the mover is operating at peak efficiency, and
</p>
<p align=\"center\">
<i>Z<sub>1</sub>=(x-a) &frasl; b</i>
</p>
<p align=\"center\">
<i>Z<sub>2</sub>=(e<sup>c&sdot;x</sup>&sdot;d&sdot;x-a) &frasl; b</i>
</p>
<p align=\"center\">
<i>Z<sub>3</sub>=-a &frasl; b</i>
</p>
<p align=\"center\">
<i>a=-2.732094</i>
</p>
<p align=\"center\">
<i>b=2.273014</i>
</p>
<p align=\"center\">
<i>c=0.196344</i>
</p>
<p align=\"center\">
<i>d=5.267518</i>
</p>
<p>
The approximation uses two simple polynomials stitched together by
a third one of the same order.
Care has been taken to ensure that, on the curve constructed by
<code>if</code> statements, the differences of <i>dy &frasl; dx</i>
evaluated by different groups of coefficients at the connecting points
(i.e. at <i>x = - 0.5</i> and <i>x = + 0.5</i>) are less than <i>1E-14</i>.
This way, the derivative is still continuous to the solver even if
the solver requires a precision of <i>1E-10</i> when there are nested loops.
</p>
<p>
The correlation and the approximation have the shape as shown below
(plotted by 
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Validation.EulerCurve\">
Buildings.Fluid.Movers.BaseClasses.Validation.EulerCurve</a>).
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Fluid/Movers/BaseClasses/Euler/EulerCurve.png\"/>
</p>
<p>
The modified dimensionless Euler number is defined as
</p>
<p align=\"center\">
<i>Eu=(&Delta;p&sdot;D<sup>4</sup>) &frasl; (&rho;&sdot;V&#775;<sup>2</sup>)</i>
</p>
<p>
where <i>&Delta;p</i> is the fan pressure rise in Pa,
<i>D</i> is the fan wheel outer diameter in m,
<i>&rho;</i> is the inlet air density in kg/m<sup>3</sup>,
and <i>V&#775;</i> is the volumetric flow rate in m<sup>3</sup>/s.
Note that the units in the definition do not matter to this correlation
because it is the ratio of the Euler numbers that is used.
Since <i>D</i> is constant for the same mover
and <i>&rho;</i> is approximately constant for common HVAC applications,
the Euler number ratio can be simplified to
</p>
<p align=\"center\">
<i>Eu &frasl; Eu<sub>p</sub>=(&Delta;p&sdot;V&#775;<sub>p</sub><sup>2</sup>)
&frasl; (&Delta;p<sub>p</sub>&sdot;V&#775;<sup>2</sup>)</i>
</p>
<h4>References</h4>
<p>
For more information regarding the correlation curve refer to
<a href=\"https://energyplus.net/assets/nrel_custom/pdfs/pdfs_v9.6.0/EngineeringReference.pdf\">
EnergyPlus 9.6.0 Engineering Reference</a>
chapter 16.4 equations 16.209 through 16.218.
Note that the formula is simplified here from the source document.
</p>
<h4>Resources</h4>
<p>
The svg file for the correlation equation was generated on
<a href=\"https://viereck.ch/latex-to-svg/\">
https://viereck.ch/latex-to-svg</a>
using
<a href=\"modelica://Buildings/Resources/Images/Fluid/Movers/BaseClasses/Euler/eulerCorrelation.txt\">
this script</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
February 2, 2023, by Michael Wetter:<br/>
Rewrote to reduce number of <code>if-then</code> statements and to use
<code>smoothMax</code> rather than <code>max</code>.
</li>
<li>
December 12, 2022, by Hongxiang Fu and Filip Jorissen:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a> and
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1645\">#1645</a>.
</li>
</ul>
</html>"));
          end correlation;

          function efficiency
            "Computes efficiency with the Euler number correlation"
            extends Modelica.Icons.Function;
            input Buildings.Fluid.Movers.BaseClasses.Euler.peak peak
              "Operation point with maximum efficiency";
            input Modelica.Units.SI.PressureDifference dp
              "Pressure rise";
            input Modelica.Units.SI.VolumeFlowRate V_flow
              "Volumetric flow rate";
            input Real V_flow_dp_small(
              final unit="m3.Pa/s",
              min = Modelica.Constants.eps)
              "Small number for regularisation";
            output Modelica.Units.SI.Efficiency eta
              "Efficiency";

        protected
            Real log_r_Eu "Log10 of Eu/Eu_peak";

          algorithm
            log_r_Eu:= log10(
                         Buildings.Utilities.Math.Functions.smoothMax(
                           x1=dp * peak.V_flow^2,
                           x2=V_flow_dp_small,
                           deltaX=V_flow_dp_small/2)
                        /Buildings.Utilities.Math.Functions.smoothMax(
                           x1=peak.dp * V_flow^2,
                           x2=V_flow_dp_small,
                           deltaX=V_flow_dp_small/2));
            eta:= peak.eta*
                    Buildings.Fluid.Movers.BaseClasses.Euler.correlation(x=log_r_Eu);

                    annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function uses the correlation of Euler number to compute
the efficiency <i>&eta;</i>.
</p>
</html>", revisions="<html>
<ul>
<li>
December 12, 2022, by Hongxiang Fu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));
          end efficiency;

          function getPeak
            "Find peak condition from power characteristics"
            extends Modelica.Icons.Function;
            input Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters
              pressure "Pressure vs. flow rate";
            input BaseClasses.Characteristics.powerParameters
              power "Power vs. flow rate";
            output Buildings.Fluid.Movers.BaseClasses.Euler.peak
              peak "Operation point at maximum efficiency";

        protected
            parameter Integer nPre = size(pressure.V_flow, 1) "Size of the pressure array";
            parameter Integer nPow = size(power.V_flow, 1) "Size of the power array";
            parameter Integer n = max(nPre, nPow) "Bigger of the two arrays";
            parameter Modelica.Units.SI.VolumeFlowRate V_flow_hal=
              if max(pressure.V_flow) < 1E-6
                then 0
              else (pressure.V_flow[nPre]
                          -(pressure.V_flow[nPre] - pressure.V_flow[nPre - 1])
                          /(pressure.dp[nPre] - pressure.dp[nPre - 1])
                          * pressure.dp[nPre])/2
              "Half of max flow, max flow is where dp=0";
            parameter Modelica.Units.SI.PressureDifference dpHalFlo=
              if max(pressure.V_flow) < 1E-6
                then 0
              else Buildings.Utilities.Math.Functions.smoothInterpolation(
                         x=V_flow_hal,
                         xSup=pressure.V_flow,
                         ySup=pressure.dp,
                         ensureMonotonicity=true)
              "Pressure rise at half flow";

            Modelica.Units.SI.VolumeFlowRate V_flow[n] "Flow rate";
            Modelica.Units.SI.PressureDifference dp[n] "Pressure rise";
            Modelica.Units.SI.Power P[n] "Power";

            Real eta[n] "Efficiency series";
            Boolean etaLes "Efficiency series has less than four points";
            Boolean etaMon "Efficiency series is monotonic";

            // A b = y
            Real A[n,5] "Design matrix";
            Real b[5] "Parameter vector";
            Real r[3,2] "Roots";
          algorithm

            if max(pressure.V_flow) < 1E-6 and
               max(pressure.dp)     < 1E-6 then
              // If there is no pressure curve, no estimation can be made
              peak.V_flow:=0;
              peak.dp:=0;
              peak.eta:=0.7;

            elseif max(power.P) < 1E-6 then
              // If a pressure curve is available, but no power curve,
              //   peak.V_flow = V_flow_max / 2,
              //   peak.dp = dp(V_flow = V_flow_max / 2)
              peak.V_flow:=V_flow_hal;
              peak.dp:=dpHalFlo;
              peak.eta:=0.7;

            else
              // Both a pressure curve and a power curve are available.

              // Create arrays of the equal size
              if nPre == nPow then
                V_flow:= pressure.V_flow;
                dp:= pressure.dp;
                P:= power.P;
              else
                if nPre > nPow then
                  V_flow:= pressure.V_flow;
                  dp:= pressure.dp;
                  for i in 1:n loop
                    P[i]:= Buildings.Utilities.Math.Functions.smoothInterpolation(
                             x=V_flow[i],
                             xSup=power.V_flow,
                             ySup=power.P,
                             ensureMonotonicity=false);
                  end for;
                else
                  V_flow:= power.V_flow;
                  P:= power.P;
                  for i in 1:n loop
                    dp[i]:= Buildings.Utilities.Math.Functions.smoothInterpolation(
                              x=V_flow[i],
                              xSup=pressure.V_flow,
                              ySup=pressure.dp,
                              ensureMonotonicity=true);
                  end for;
                end if;
              end if;

              // Compute efficiency array
              eta:=V_flow.*dp./P;
              etaLes:=n<4;
              etaMon:=Buildings.Utilities.Math.Functions.isMonotonic(
                x=eta,
                strict=false);

              if etaLes or etaMon then
              // If less than four data points are provided or the efficiency curve is
              //   monotonic, use the one of two which has the higher efficiency:
              //   1. the interpolated point at half of max flow;
              //   2. the available point with the highest efficiency.
                peak.eta:=Buildings.Utilities.Math.Functions.smoothInterpolation(
                         x=V_flow_hal,
                         xSup=V_flow,
                         ySup=eta,
                         ensureMonotonicity=
                           Buildings.Utilities.Math.Functions.isMonotonic(eta, strict=false));
                if peak.eta>max(eta) then
                       peak.V_flow:=V_flow_hal;
                       peak.dp:=dpHalFlo;
                else
                  peak.eta:=max(eta);
                  for i in 1:n loop
                    if abs(eta[i]-peak.eta)<1E-6 then
                      peak.V_flow:=V_flow[i];
                      peak.dp:=dp[i];
                    end if;
                  end for;
                end if;
              else

                // Constructs the matrix equation A b = y for quartic regression, where
                //   A is a 5-by-n design matrix,
                //   b is a parameter vector with length 5,
                //   and y = eta is the response vector with length n.
                A[:,1]:=ones(n); // Avoids 0^0
                for i in 2:5 loop
                  A[:,i]:=V_flow[:].^(i-1);
                end for;
                b:=Modelica.Math.Matrices.leastSquares(A,eta);

                // Solve the derivative for the max eta and corresponding V_flow.
                // This assumes that there will only be one real solution
                //   and it falls within the range of V_flow[:].
                r:=Modelica.Math.Polynomials.roots({b[5]*4,b[4]*3,b[3]*2,b[2]});
                for i in 1:3 loop
                  if abs(r[i,2])<=1E-6 and
                    r[i,1]>V_flow[1] and r[i,1]<V_flow[n] then
                    peak.V_flow:=r[i,1];
                  end if;
                end for;
                peak.eta:=Buildings.Utilities.Math.Functions.smoothInterpolation(
                  x=peak.V_flow,
                  xSup=V_flow,
                  ySup=eta,
                  ensureMonotonicity=false);
                peak.dp:=Buildings.Utilities.Math.Functions.smoothInterpolation(
                  x=peak.V_flow,
                  xSup=V_flow,
                  ySup=dp,
                  ensureMonotonicity=false);
              end if;
            end if;

            annotation(Documentation(info="<html>
<p>
This function finds or estimates the peak point
<i>(V&#775;,&Delta;p,&eta;)|&eta;=&eta;<sub>max</sub></i>
from the input power curve <i>P(V&#775;)</i>
and pressure curve <i>&Delta;p(V&#775;)</i>
which may or may not contain non-zero values.
The results are output as an instance of
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Euler.peak\">
Buildings.Fluid.Movers.BaseClasses.Euler.peak</a>.
There are the following branches of computation based on information provided
to the function:
</p>
<ul>
<li>
If <i>&Delta;p(V&#775;)</i> is unavailable, the function simply outputs
<i>(0,0,0.7)</i>.
</li>
<li>
If <i>&Delta;p(V&#775;)</i> is provided but <i>P(V&#775;)</i> is unavailable,
the function provides an estimation of the peak point at half of max flow rate
<i>(V&#775;<sub>max</sub> &frasl; 2,
&Delta;p(V&#775;=V&#775;<sub>max</sub> &frasl; 2),
0.7)</i>.
</li>
<li>
If both <i>&Delta;p(V&#775;)</i> and <i>P(V&#775;)</i> are available,
the function first computes
<i>&eta;(V&#775;)=V&#775;&nbsp;&Delta;p &frasl; P</i>.
<ul>
<li>
If <i>&eta;(V&#775;)</i> has less than four data points or is monotonic,
use one of the two which ever produces a higher <i>&eta;</i>:
<ul>
<li>
The interpolated point at half of max flow rate
<i>(V&#775;<sub>max</sub> &frasl; 2,
&Delta;p(V&#775;=V&#775;<sub>max</sub> &frasl; 2),
&eta;(V&#775;=V&#775;<sub>max</sub> &frasl; 2))</i>
</li>
<li>
The available point with the highest computed efficiency.
</li>
</ul>
</li>
<li>
Otherwise, the function runs a quartic regression on <i>&eta;(V&#775;)</i>
then solves its derivative to find an extremum.
It assumes that there is only one extremum on the open interval
<i>(0,V&#775;<sub>max</sub>)</i>.
</li>
</ul>
</li>
</ul>
</html>", revisions="<html>
<ul>
<li>
August 18, 2022, by Hongxiang Fu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));
          end getPeak;

          function power
            "Computes power as well as its derivative with respect to flow rate using Euler number"
            extends Modelica.Icons.Function;
            input Buildings.Fluid.Movers.BaseClasses.Euler.peak peak "Peak operation point";
            input Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal
              pressure "Pressure curve with both max flow rate and max pressure";
            output Buildings.Fluid.Movers.BaseClasses.Euler.powerWithDerivative power(
              V_flow=zeros(11),P=zeros(11),d=zeros(11))
              "Power and its derivative vs. flow rate";
        protected
            Modelica.Units.SI.VolumeFlowRate V_flow[11]
              "Volumetric flow rate";
            Modelica.Units.SI.PressureDifference dp[11]
              "Pressure rise";
            Real V_flow_dp_small(
              final unit="m3.Pa/s",
              min = Modelica.Constants.eps) "Small value for regularisation";

          algorithm
            // Construct pressure curve of 10% max flow rate increments
            //   from the given pressure curve
            V_flow:={pressure.V_flow[end]*i*0.1 for i in 0:10};
            for i in 1:11 loop
              dp[i]:=Buildings.Utilities.Math.Functions.smoothInterpolation(
                       x=V_flow[i],
                       xSup=pressure.V_flow,
                       ySup=pressure.dp,
                       ensureMonotonicity=false);
            end for;

            // Compute the power and derivative on non-boundary points
            //   using efficiency estimated by Euler number method
            power.V_flow:=V_flow;
            V_flow_dp_small :=1E-4*max(pressure.V_flow)*max(pressure.dp);

            for i in 2:10 loop
              power.P[i]:=V_flow[i] * dp[i]
                          / Buildings.Fluid.Movers.BaseClasses.Euler.efficiency(
                              peak=peak,
                              dp=dp[i],
                              V_flow=V_flow[i],
                              V_flow_dp_small=V_flow_dp_small/2);
            end for;

            power.d[2:10]:=Buildings.Utilities.Math.Functions.splineDerivatives(
                             x=V_flow[2:10],
                             y=power.P[2:10],
                             ensureMonotonicity=false);

            // Use linear extrapolation to find the boundary points
            power.d[1]:=power.d[2];
            power.d[11]:=power.d[10];
            power.P[1]:=power.P[2]-power.d[2]*V_flow[2];
            power.P[11]:=power.P[10]+power.d[10]*(V_flow[11]-V_flow[10]);

          annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function outputs power values as well as its derivative versus
volumetric flow rate in the following steps:
</p>
<ul>
<li>
It first interpolates the input pressure curve to find a new pressure curve of
11 points on 10% increments of max flow rate.
It assumes that the last point on the input pressure curve corresponds to
<i>&Delta;p = 0</i>, which is ensured when this function is called by
<a href=\"Modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>.
</li>
<li>
It then computes power using efficiency evaluated with the Euler number
from 10% to 90% of max flow rate on 10% increments.
</li>
<li>
With the incomplete power curve it computes the spline derivatives
with respect to flow rate at the same points.
</li>
<li>
Once the derivatives are available, the power values at the two boundary points
are found through linear extrapolation.
</li>
</ul>
<p>
These steps are designed to ensure that power and efficiency computation with
the Euler number is handled correctly near zero flow or zero pressure, where<br/>
<p align=\"center\" style=\"font-style:italic;\">
W&#775;<sub>flo</sub> = 0,<br/>
&eta; = 0,<br/>
P &gt; 0
</p>
<p>
in the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
&eta; = W&#775;<sub>flo</sub> &frasl; P.
</p>
</html>", revisions="<html>
<ul>
<li>
December 13, 2022, by Hongxiang Fu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));
          end power;

          record peak
            "Record for the operation condition at peak efficiency"
            extends Modelica.Icons.Record;
            parameter Modelica.Units.SI.VolumeFlowRate
              V_flow(min=0)
              "Volume flow rate at peak efficiency";
            parameter Modelica.Units.SI.PressureDifference
              dp(
                min=0,
                displayUnit="Pa")
              "Pressure rise at peak efficiency";
            parameter Modelica.Units.SI.Efficiency eta=0.7
              "Peak efficiency";
            annotation (
          Documentation(info="<html>
<p>
Record for performance data that describe the operation at peak efficiency.
</p>
</html>", revisions="<html>
<ul>
<li>
October 15, 2021, by Hongxiang Fu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));
          end peak;

          record powerWithDerivative
            "Record for electrical power and its derivative with respect to flow rate"
            extends Modelica.Icons.Record;
            parameter Modelica.Units.SI.VolumeFlowRate V_flow[11](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.Units.SI.Power P[11](each min=0)
              "Fan or pump electrical power at these flow rates";
            parameter Real d[11](each unit="J/m3")
              "Derivative of power with respect to volume flow rate";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe electrical power and its derivative
versus volumetric flow rate.
This record is specifically constructed for the Euler number method
and is the output type of function
<a href=\"Modelica://Buildings.Fluid.Movers.BaseClasses.Euler.power\">
Buildings.Fluid.Movers.BaseClasses.Euler.power</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
December 13, 2022, by Hongxiang Fu:<br/>
First implementation.
</li>
</ul>
</html>"));
          end powerWithDerivative;
          annotation (Documentation(info="<html>
<p>
This package implements a power computation using the Euler number
and its correlation.
</p>
<ul>
<li>
The correlation function using the Euler number is implemented in
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Euler.correlation\">
Buildings.Fluid.Movers.BaseClasses.Euler.correlation</a>.
</li>
<li>
When curves of power and pressure against flow rate is available,
the function
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Euler.getPeak\">
Buildings.Fluid.Movers.BaseClasses.Euler.getPeak</a>
can identify the peak operating condition from them.
This is useful comparing power computation results
against other methods.
</li>
<li>
The peak operating condition (where the efficiency <i>&eta;</i> is
at its maximum) which is used by the correlation is stored in an instance
of the record
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Euler.peak\">
Buildings.Fluid.Movers.BaseClasses.Euler.peak</a>.
</li>
<li>
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>
uses the peak values and the correlation to generate a power curve against
volumetric flow rate. This estimated power curve is used in place of the
measured power that would otherwise be provided.
</li>
</ul>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 13, 2021, by Hongxiang Fu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));
        end Euler;

        package Types "Package with type definitions"
          extends Modelica.Icons.TypesPackage;

          type PrescribedVariable = enumeration(
              Speed "Speed is prescribed",
              FlowRate "Flow rate is prescribed",
              PressureDifference "Pressure difference is prescribed")
            "Enumeration to choose what variable is prescribed";

          type HydraulicEfficiencyMethod = enumeration(
              NotProvided
                "Not provided, computed from other efficiency terms",
              Efficiency_VolumeFlowRate "Array of efficiency vs. volumetric flow rate",
              Power_VolumeFlowRate
                "Array of power vs. volumetric flow rate",
              EulerNumber
                "One peak point to be used for the Euler number")
            "Enumeration to choose the computation method for total efficiency and hydraulic efficiency"
            annotation (Documentation(info="<html>
<p>
Enumeration to specify the calculation of the hydraulic efficiency.
See <a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">Buildings.Fluid.Movers.UsersGuide</a>
for instructions.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 15, 2021, by Hongxiang Fu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));

          type MotorEfficiencyMethod = enumeration(
              NotProvided
                "Not provided, computed from other efficiency terms",
              Efficiency_VolumeFlowRate "Array of efficiency vs. volumetric flow rate",
              Efficiency_MotorPartLoadRatio
                "Rated input and array of efficiency vs. motor part load ratio yMot=WHyd/WMot_nominal",
              GenericCurve
                "Rated input and maximum efficiency to be used for generic curves")
            "Enumeration to choose the computation method for motor efficiency"
            annotation (Documentation(info="<html>
<p>
Enumeration to specify the calculation of the motor efficiency.
See <a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">Buildings.Fluid.Movers.UsersGuide</a>
for instructions.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 15, 2021, by Hongxiang Fu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2668\">#2668</a>.
</li>
</ul>
</html>"));
         annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions for movers.
</p>
</html>"));
        end Types;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Movers\">Buildings.Fluid.Movers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models for fans and pumps.
</html>"),
      Icon(graphics={Ellipse(
            extent={{-66,66},{68,-68}},
            lineColor={0,0,0},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid), Polygon(
            points={{0,66},{0,-68},{68,0},{0,66}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
    end Movers;

    package Sensors "Package with sensor models"
      extends Modelica.Icons.SensorsPackage;

      model MassFlowRate "Ideal sensor for mass flow rate"
      extends Buildings.Fluid.Sensors.BaseClasses.PartialFlowSensor(
        final m_flow_nominal = 0,
        final m_flow_small = 0);
      extends Modelica.Icons.RoundSensor;
      Modelica.Blocks.Interfaces.RealOutput m_flow(quantity="MassFlowRate",
                                                   final unit="kg/s")
        "Mass flow rate from port_a to port_b" annotation (Placement(
            transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));

      equation
      m_flow = port_a.m_flow;
        annotation (
          defaultComponentName="senMasFlo",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Line(points={{70,0},{100,0}}, color={0,128,255}),
            Text(
              extent={{162,120},{2,90}},
              textColor={0,0,0},
              textString="m_flow"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255}),
            Text(
              extent={{-20,116},{-140,66}},
              textColor={0,0,0},
              textString=DynamicSelect("", String(m_flow, leftJustified=false, significantDigits=3)))}),
      Documentation(info="<html>
<p>
This model outputs the mass flow rate flowing from
<code>port_a</code> to <code>port_b</code>.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end MassFlowRate;

      model RelativePressure "Ideal relative pressure sensor"
        extends Modelica.Icons.RectangularSensor;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the sensor"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        Modelica.Fluid.Interfaces.FluidPort_a port_a(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          "Fluid connector of stream a"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          "Fluid connector of stream b"
          annotation (Placement(transformation(extent={{110,-12},{90,8}}), iconTransformation(extent={{110,-10},{90,10}})));

        Modelica.Blocks.Interfaces.RealOutput p_rel(final quantity="PressureDifference",
                                                    final unit="Pa",
                                                    displayUnit="Pa")
          "Relative pressure of port_a minus port_b" annotation (Placement(transformation(
              origin={0,-90},
              extent={{10,-10},{-10,10}},
              rotation=90)));
      equation
        // Zero flow equations for connectors
        port_a.m_flow = 0;
        port_b.m_flow = 0;

        // No contribution of specific quantities
        port_a.h_outflow = 0;
        port_b.h_outflow = 0;
        port_a.Xi_outflow = zeros(Medium.nXi);
        port_b.Xi_outflow = zeros(Medium.nXi);
        port_a.C_outflow  = zeros(Medium.nC);
        port_b.C_outflow  = zeros(Medium.nC);

        // Relative pressure
        p_rel = port_a.p - port_b.p;
        annotation (defaultComponentName="senRelPre",
          Icon(graphics={
              Line(points={{-100,0},{-70,0}}, color={0,127,255}),
              Line(points={{70,0},{100,0}}, color={0,127,255}),
              Line(points={{0,-30},{0,-80}}, color={0,0,127}),
              Text(
                extent={{-150,40},{150,80}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{130,-70},{4,-100}},
                textColor={0,0,0},
                textString="p_rel"),
              Line(
                points={{32,3},{-58,3}},
                color={0,128,255}),
              Polygon(
                points={{22,18},{62,3},{22,-12},{22,18}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-20,-56},{-140,-106}},
                textColor={0,0,0},
                textString=DynamicSelect("", String(p_rel, leftJustified=false, significantDigits=3)))}),
          Documentation(info="<html>
<p>
The relative pressure <code>port_a.p - port_b.p</code> is determined between
the two ports of this component and is provided as output signal. The
sensor should be connected in parallel with other equipment, no flow
through the sensor is allowed.
</p>
</html>",
      revisions="<html>
<ul>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
February 19, 2016, by Michael Wetter:<br/>
Corrected the quantity of the output signal from <code>Pressure</code>
to <code>PressureDifference</code>.
This was needed for the model
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_m_flow\">
Buildings.Fluid.Movers.FlowControlled_m_flow</a>
when revising it for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">
issue 417</a>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation, based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end RelativePressure;

      model TemperatureTwoPort "Ideal two port temperature sensor"
        extends Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor;
        Modelica.Blocks.Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                                final unit="K",
                                                displayUnit = "degC",
                                                min = 0,
                                                start=T_start)
          "Temperature of the passing fluid"
          annotation (Placement(transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));
        parameter Modelica.Units.SI.Temperature T_start=Medium.T_default
          "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));

        parameter Boolean transferHeat = false
          "if true, temperature T converges towards TAmb when no flow"
          annotation(Evaluate=true, Dialog(group="Heat transfer"));
        parameter Modelica.Units.SI.Temperature TAmb=Medium.T_default
          "Fixed ambient temperature for heat transfer"
          annotation (Dialog(enable=transferHeat, group="Heat transfer"));
        parameter Modelica.Units.SI.Time tauHeaTra(min=1) = 1200
          "Time constant for heat transfer, default 20 minutes"
          annotation (Dialog(enable=transferHeat, group="Heat transfer"));

    protected
        parameter Real tauHeaTraInv(final unit = "1/s")=
          if tauHeaTra<1E-10 then 0 else 1/tauHeaTra
          "Dummy parameter to avoid division by tauHeaTra";
        parameter Real ratTau = if dynamic then tauHeaTra/tau else 1
          "Ratio of tau";
        Medium.Temperature TMed(start=T_start)
          "Medium temperature to which the sensor is exposed";
        Medium.Temperature T_a_inflow "Temperature of inflowing fluid at port_a";
        Medium.Temperature T_b_inflow
          "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow";
      initial equation
        if dynamic then
          if initType == Modelica.Blocks.Types.Init.SteadyState then
            der(T) = 0;
           elseif initType == Modelica.Blocks.Types.Init.InitialState or
                 initType == Modelica.Blocks.Types.Init.InitialOutput then
            T = T_start;
          end if;
        end if;
      equation
        if allowFlowReversal then
           T_a_inflow = Medium.temperature(state=
                          Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           T_b_inflow = Medium.temperature(state=
                          Medium.setState_phX(p=port_a.p, h=port_a.h_outflow, X=port_a.Xi_outflow));
           TMed = Modelica.Fluid.Utilities.regStep(
                    x=port_a.m_flow,
                    y1=T_a_inflow,
                    y2=T_b_inflow,
                    x_small=m_flow_small);
        else
           TMed = Medium.temperature(state=
                    Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           T_a_inflow = TMed;
           T_b_inflow = TMed;
        end if;
        // Output signal of sensor
        if dynamic then
          if transferHeat then
            der(T) = (TMed-T)*k*tauInv + (TAmb-T)*tauHeaTraInv/(ratTau*k+1);
          else
            der(T) = (TMed-T)*k*tauInv;
          end if;
        else
          T = TMed;
        end if;
      annotation (defaultComponentName="senTem",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={
              Line(points={{-100,0},{92,0}}, color={0,128,255}),
              Ellipse(
                extent={{-20,-58},{20,-20}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-40,60},{-12,60}}),
              Line(points={{-40,30},{-12,30}}),
              Line(points={{-40,0},{-12,0}}),
              Rectangle(
                extent={{-12,60},{12,-24}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,60},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{12,
                    80},{12,60},{-12,60}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Text(
                extent={{102,140},{-18,90}},
                textColor={0,0,0},
                textString="T"),
              Line(
                points={{-12,60},{-12,-25}},
                thickness=0.5),
              Line(
                points={{12,60},{12,-24}},
                thickness=0.5),
              Line(points={{0,100},{0,50}}, color={0,0,127}),
          Line(
          origin={-77.5,-22.3333},
          points={{43.5,8.3333},{37.5,0.3333},{21.5,-3.6667},{37.5,-17.6667},{7.5,-17.6667},
                    {19.5,-37.6667},{3.5,-38.3333},{-2.5,-48.3333}},
            smooth=Smooth.Bezier,
            visible=transferHeat),
              Polygon(
                points={{-90,-80},{-84,-66},{-76,-74},{-90,-80}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={0,0,0},
                visible=transferHeat),
              Text(
               extent={{-20,120},{-140,70}},
                textColor={0,0,0},
                textString=DynamicSelect("", String(T-273.15, format=".1f")))}),
          Documentation(info="<html>
<p>
This model outputs the temperature of the medium in the flow
between its fluid ports. The sensor does not influence the fluid.
</p>
<h4>Typical use and important parameters</h4>
<p>
If the parameter <code>tau</code> is non-zero, then its output <i>T</i>
converges to the temperature of the incoming fluid using
a first order differential equation.
Setting <code>tau=0</code> is <i>not</i> recommend. See
<a href=\"modelica://Buildings.Fluid.Sensors.UsersGuide\">
Buildings.Fluid.Sensors.UsersGuide</a> for an explanation.
</p>
<p>
If <code>transferHeat = true</code>, then heat transfer with the ambient is
approximated and <i>T</i> converges towards the fixed ambient
temperature <i>T<sub>Amb</sub></i> using a first order approximation
with a time constant of <code>tauHeaTra</code>
when the flow rate is small.
Note that no energy is exchanged with the fluid as the
sensor does not influence the fluid temperature.
</p>
<p>
Setting <code>transferHeat = true</code> is useful, for example,
if the sensor is used to measure the fluid temperature in
a system with on/off control on the mass flow rate.
If <code>transferHeat</code> were <code>false</code>, then the sensor output <i>T</i>
would remain constant if the mass flow rate is set to zero, and hence
the controller may never switch the mass flow rate on again.
</p>
<p>
In general, applications in which the sensor output is not used to switch
the mass flow rate on should set <code>transferHeat=false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
October 23, 2017 by Filip Jorissen:<br/>
Revised implementation of equations
when <code>transferHeat=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/840\">#840</a>.
</li>
<li>
January 12, 2016 by Filip Jorissen:<br/>
Removed parameter <code>tauInv</code>
since this now exists in
<a href=\"modelica://Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor\">Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor</a>.
</li>
<li>
June 19, 2015 by Michael Wetter:<br/>
Revised model and documentation.
</li>
<li>
June 18, 2015 by Filip Jorissen:<br/>
Added option for simulating thermal losses.
</li>
<li>
June 3, 2011 by Michael Wetter:<br/>
Revised implementation to add dynamics in such a way that
the time constant increases as the mass flow rate tends to zero.
This significantly improves the numerics.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Set start attribute for temperature output. Prior to this change,
the output was 0 at initial time, which caused the plot of the output to
use 0 Kelvin as the lower value of the ordinate.
</li>
<li>
September 10, 2008, by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://Buildings.Fluid.Sensors.Temperature\">Buildings.Fluid.Sensors.Temperature</a>.
</li>
</ul>
</html>"));
      end TemperatureTwoPort;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Sensors"
        extends Modelica.Icons.BasesPackage;

        partial model PartialDynamicFlowSensor
          "Partial component to model sensors that measure flow properties using a dynamic model"
          extends PartialFlowSensor;

          parameter Modelica.Units.SI.Time tau(min=0) = 1
            "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
          parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState
            "Type of initialization (InitialState and InitialOutput are identical)"
          annotation(Evaluate=true, Dialog(group="Initialization"));
      protected
          Real k(start=1)
            "Gain to take flow rate into account for sensor time constant";
          final parameter Boolean dynamic = tau > 1E-10 or tau < -1E-10
            "Flag, true if the sensor is a dynamic sensor"
            annotation(Evaluate=true);
          Real mNor_flow "Normalized mass flow rate";
          final parameter Real tauInv(final unit="s-1")= if dynamic then 1/tau else 0
            "Inverse of tau";
        equation
          if dynamic then
            mNor_flow = port_a.m_flow/m_flow_nominal;
            k = Modelica.Fluid.Utilities.regStep(x=port_a.m_flow,
                                                 y1= mNor_flow,
                                                 y2=-mNor_flow,
                                                 x_small=m_flow_small);
          else
            mNor_flow = 1;
            k = 1;
          end if;
          annotation (Icon(graphics={
                Line(visible=(tau > 0),
                points={{52,60},{58,74},{66,86},{76,92},{88,96},{98,96}}, color={0,
                      0,127})}), Documentation(info="<html>
<p>
Partial component to model a sensor that measures any intensive properties
of a flow, e.g., to get temperature or density in the flow
between fluid connectors.</p>
<p>
The sensor computes a gain that is zero at zero mass flow rate.
This avoids fast transients if the flow is close to zero, thereby
improving the numerical efficiency.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 10, 2022, by Michael Wetter:<br/>
Corrected annotation to avoid comparing a real-valued parameter
for equality.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1671\">IBPSA, #1671</a>.
</li>
<li>
August 9, 2016, by Michael Wetter:<br/>
Improved documentation for <code>tau</code>.
</li>
<li>
January 12, 2016, by Filip Jorissen:<br/>
Added optional parameter <code>tauInv</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Changed the parameter <code>initType</code> to
<code>Modelica.Blocks.Types.Init.InitialState</code>.
This allows a pedantic model check in Dymola 2014 of models that instanciate sensors
but do not set this parameter. It also ensures that different Modelica simulators solve
the same initialization problem.
</li>
<li>
July 7, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialDynamicFlowSensor;

        partial model PartialFlowSensor
          "Partial component to model sensors that measure flow properties"
          extends Buildings.Fluid.Interfaces.PartialTwoPort;
          parameter Modelica.Units.SI.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate, used for regularization near zero flow"
            annotation (Dialog(group="Nominal condition"));
          parameter Modelica.Units.SI.MassFlowRate m_flow_small(min=0) = 1E-4*
            m_flow_nominal
            "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)"
            annotation (Dialog(tab="Advanced"));
        equation
          // mass balance
          port_b.m_flow = -port_a.m_flow;
          // momentum equation (no pressure loss)
          port_a.p = port_b.p;
          // isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
          port_b.h_outflow = inStream(port_a.h_outflow);
          port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
          port_b.C_outflow = inStream(port_a.C_outflow);
          annotation (Documentation(info="<html>
<p>
Partial component to model a sensor.
The sensor is ideal. It does not influence mass, energy,
species or substance balance, and it has no flow friction.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
June 19, 2015, by Michael Wetter:<br/>
Moved <code>m_flow_small</code> to the <code>Advanced</code> tab
as it usually need not be changed by the user.
Other models such as heat exchangers also have this parameter
on the <code>Advanced</code> tab.
</li>
<li>
February 12, 2011, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
        end PartialFlowSensor;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Sensors\">Buildings.Fluid.Sensors</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <code>Sensors</code> consists of idealized sensor components that
provide variables of a medium as
output signals. These signals can be, e.g., further processed
with components of the
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>
library.
</p>
</html>", revisions="<html>
<ul>
<li><i>22 Dec 2008</i>
    by R&uuml;diger Franke
    <ul>
    <li>flow sensors based on Modelica.Fluid.Interfaces.PartialTwoPort</li>
    <li>adapted documentation to stream connectors, i.e. less need for two port sensors</li>
    </ul>
</li>
<li><i>4 Dec 2008</i>
    by Michael Wetter<br/>
       included sensors for trace substance</li>
<li><i>31 Oct 2007</i>
    by Carsten Heinrich<br/>
       updated sensor models, included one and two port sensors for thermodynamic state variables</li>
</ul>
</html>"));
    end Sensors;

    package Sources "Package with boundary condition models"
      extends Modelica.Icons.SourcesPackage;

      model Boundary_pT
        "Boundary with prescribed pressure, temperature, composition and trace substances"
        extends Buildings.Fluid.Sources.BaseClasses.PartialSource_Xi_C;

        parameter Boolean use_p_in = false
          "Get the pressure from the input connector"
          annotation(Evaluate=true, Dialog(group="Conditional inputs"));
        parameter Medium.AbsolutePressure p = Medium.p_default
          "Fixed value of pressure"
          annotation (Dialog(enable = not use_p_in, group="Fixed inputs"));

        parameter Boolean use_T_in= false
          "Get the temperature from the input connector"
          annotation(Evaluate=true, Dialog(group="Conditional inputs"));
        parameter Medium.Temperature T = Medium.T_default
          "Fixed value of temperature"
          annotation (Dialog(enable = not use_T_in,group="Fixed inputs"));

        Modelica.Blocks.Interfaces.RealInput p_in(final unit="Pa") if use_p_in
          "Prescribed boundary pressure"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

        Modelica.Blocks.Interfaces.RealInput T_in(final unit="K",
                                                  displayUnit="degC") if use_T_in
          "Prescribed boundary temperature"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

          // Boolean constants to avoid a potential string comparison in an equation section
    protected
        constant Boolean checkWaterPressure = Medium.mediumName == "SimpleLiquidWater"
          "Evaluates to true if the pressure should be checked";
        constant Boolean checkAirPressure = Medium.mediumName == "Air"
          "Evaluates to true if the pressure should be checked";

        Modelica.Blocks.Interfaces.RealInput T_in_internal(final unit="K",
                                                           displayUnit="degC")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput h_internal=
          Medium.specificEnthalpy(Medium.setState_pTX(p_in_internal, T_in_internal, X_in_internal))
          "Internal connector for enthalpy";

      initial equation
        if not use_p_in then
          if checkWaterPressure then
            assert(p_in_internal>1e4, "In "+getInstanceName() +
              ": The parameter value p="+String(p_in_internal)+" is low for water. This is likely an error.");
          end if;
          if checkAirPressure then
            assert(p_in_internal>5e4 and p_in_internal < 1.5e5, "In "+getInstanceName() +
              ": The parameter value p="+String(p_in_internal)+" is not within a realistic range for air. This is likely an error.");
          end if;
        end if;
      equation
        if use_p_in then
          if checkWaterPressure then
            assert(p_in_internal>1e4, "In "+getInstanceName() +
              ": The value of p_in="+String(p_in_internal)+" is low for water. This is likely an error.");
          end if;
          if checkAirPressure then
            assert(p_in_internal>5e4 and p_in_internal < 1.5e5, "In "+getInstanceName() +
              ": The value of p_in="+String(p_in_internal)+" is not within a realistic range for air. This is likely an error.");
          end if;
        end if;
        // Pressure
        connect(p_in, p_in_internal);
        if not use_p_in then
          p_in_internal = p;
        end if;
        for i in 1:nPorts loop
          ports[i].p = p_in_internal;
        end for;

        // Temperature
        connect(T_in, T_in_internal);
        if not use_T_in then
          T_in_internal = T;
        end if;
        for i in 1:nPorts loop
           ports[i].h_outflow  = h_internal;
        end for;
        connect(medium.h, h_internal);
        annotation (defaultComponentName="bou",
          Documentation(info="<html>
<p>
Defines prescribed values for boundary conditions:
</p>
<ul>
<li> Prescribed boundary pressure.</li>
<li> Prescribed boundary temperature.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<h4>Typical use and important parameters</h4>
<p>
If <code>use_p_in</code> is false (default option),
the <code>p</code> parameter is used as boundary pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code>
parameter is ignored, and the value provided by the
input connector is used instead.
</p>
<p>
The same applies to the temperature <i>T</i>, composition <i>X<sub>i</sub></i> or <i>X</i> and trace substances <i>C</i>.
</p>
<h4>Options</h4>
<p>
Instead of using <code>Xi_in</code> (the <i>independent</i> composition fractions),
the advanced tab provides an option for setting all
composition fractions using <code>X_in</code>.
<code>use_X_in</code> and <code>use_Xi_in</code> cannot be used
at the same time.
</p>
<p>
Parameter <code>verifyInputs</code> can be set to <code>true</code>
to enable a check that verifies the validity of the used temperatures
and pressures.
This removes the corresponding overhead from the model, which is
a substantial part of the overhead of this model.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>
for more information.
</p>
<p>
Note, that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
      revisions="<html>
<ul>
<li>
March 11, 2024, by Michael Wetter:<br/>
Corrected use of <code>HideResult</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1850\">#1850</a>.
</li>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
Juni 7, 2019, by Michael Wetter:<br/>
Added constant boolean expressions to avoid a potential string comparison in an equation section.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1148\">#1148</a>.
</li>
<li>
Juni 4, 2019, by Filip Jorissen:<br/>
Added check for the value of <code>p</code> and <code>p_in</code>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1148\">#1148</a>.
</li>
<li>
January 25, 2019, by Michael Wetter:<br/>
Refactored use of base classes.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1072\">#1072</a>.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Made <code>medium</code> conditional and refactored inputs.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
<li>
April 18, 2017, by Filip Jorissen:<br/>
Changed <code>checkBoundary</code> implementation
such that it is run as an initial equation
when it depends on parameters only.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/728\">#728</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>unit</code> and <code>quantity</code> attributes.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"),Icon(graphics={
              Text(
                visible=use_p_in,
                extent={{-152,134},{-68,94}},
                textColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="p"),
              Text(
                visible=use_T_in,
                extent={{-162,34},{-60,-6}},
                textColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor=DynamicSelect({0,127,255},
                  min(1, max(0, (1-((if use_T_in then T_in else T)-273.15)/50)))*{28,108,200}+
                  min(1, max(0, ((if use_T_in then T_in else T)-273.15)/50))*{255,0,0})),
              Text(
                extent={{62,28},{-58,-22}},
                textColor={255,255,255},
                textString=DynamicSelect("", String((if use_T_in then T_in else T)-273.15, format=".1f")))}));
      end Boundary_pT;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Sources"
        extends Modelica.Icons.BasesPackage;

        partial model PartialSource
          "Partial component source with one fluid connector"

          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choices(
                choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
                choice(redeclare package Medium = Buildings.Media.Water "Water"),
                choice(redeclare package Medium =
                    Buildings.Media.Antifreeze.PropyleneGlycolWater (
                      property_T=293.15,
                      X_a=0.40)
                      "Propylene glycol water, 40% mass fraction")));

          parameter Integer nPorts=0 "Number of ports" annotation(Dialog(connectorSizing=true));
          parameter Boolean verifyInputs = false
            "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          Modelica.Fluid.Interfaces.FluidPorts_b ports[nPorts](
            redeclare each package Medium = Medium,
            each m_flow(max=if flowDirection == Modelica.Fluid.Types.PortFlowDirection.Leaving
                            then 0 else +Modelica.Constants.inf,
                        min=if flowDirection == Modelica.Fluid.Types.PortFlowDirection.Entering
                            then 0 else -Modelica.Constants.inf))
            "Fluid ports"
            annotation (Placement(transformation(extent={{90,40},{110,-40}})));

      protected
          parameter Modelica.Fluid.Types.PortFlowDirection flowDirection=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
            "Allowed flow direction" annotation (Evaluate=true, Dialog(tab="Advanced"));
          Modelica.Blocks.Interfaces.RealInput p_in_internal(final unit="Pa")
            "Needed to connect to conditional connector";
          Medium.BaseProperties medium if verifyInputs "Medium in the source";
          Modelica.Blocks.Interfaces.RealInput Xi_in_internal[Medium.nXi](
            each final unit = "kg/kg")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput X_in_internal[Medium.nX](
            each final unit = "kg/kg")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput C_in_internal[Medium.nC](
            final quantity=Medium.extraPropertiesNames)
            "Needed to connect to conditional connector";


        initial equation
          // Only one connection allowed to a port to avoid unwanted ideal mixing
          for i in 1:nPorts loop
            assert(cardinality(ports[i]) <= 1,"
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");       end for;

        equation
          connect(medium.p, p_in_internal);

          annotation (defaultComponentName="bou",
          Documentation(info="<html>
<p>
Partial model for a fluid source that either prescribes
pressure or mass flow rate.
Models that extend this partial model need to prescribe the outflowing
specific enthalpy, composition and trace substances.
This partial model only declares the <code>ports</code>
and ensures that the pressures at all ports are equal.
</p>
<h4>Implementation</h4>
<p>
If the parameter <code>verifyInputs</code> is set to <code>true</code>,
then a protected instance of medium base properties is enabled.
This instance verifies that the
medium temperature is within the bounds <code>T_min</code> and <code>T_max</code>,
where <code>T_min</code> and <code>T_max</code> are constants of the <code>Medium</code>.
If the temperature is outside these bounds, the simulation will stop with an error.
</p>
<h4>Usage</h4>
<p>
This partial model provides medium selection for water, moist air and glycol.
For a model that only provides moist air as a selection, use
<a href=\"modelica://Buildings.Fluid.Sources.BaseClasses.PartialAirSource\">
Buildings.Fluid.Sources.BaseClasses.PartialAirSource</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 1, 2021, by Michael Wetter:<br/>
Corrected misplaced <code>each</code> and added missing instance comment.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1462\">IBPSA, #1462</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">IBPSA, #1050</a>.
</li>
<li>
May 30, 2018, by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">IBPSA, #882</a>.
</li>
</ul>
</html>"));
        end PartialSource;

        partial model PartialSource_Xi_C
          "Partial component source with parameter definitions for Xi and C"
          extends Buildings.Fluid.Sources.BaseClasses.PartialSource;

          parameter Boolean use_X_in = false
            "Get the composition (all fractions) from the input connector"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean use_Xi_in = false
            "Get the composition (independent fractions) from the input connector"
            annotation(Evaluate=true, Dialog(group="Conditional inputs"));
          parameter Boolean use_C_in = false
            "Get the trace substances from the input connector"
            annotation(Evaluate=true, Dialog(group="Conditional inputs"));
          parameter Medium.MassFraction X[Medium.nX](
            final quantity=Medium.substanceNames) = Medium.X_default
            "Fixed value of composition"
            annotation (Dialog(enable = (not use_X_in) and Medium.nXi > 0, group="Fixed inputs"));
          parameter Medium.ExtraProperty C[Medium.nC](
            final quantity=Medium.extraPropertiesNames) = fill(0, Medium.nC)
            "Fixed values of trace substances"
            annotation (Dialog(enable = (not use_C_in) and Medium.nC > 0, group="Fixed inputs"));
          Modelica.Blocks.Interfaces.RealInput X_in[Medium.nX](
            each final unit = "kg/kg",
            final quantity=Medium.substanceNames) if use_X_in
            "Prescribed boundary composition"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput Xi_in[Medium.nXi](
            each final unit = "kg/kg",
            final quantity=Medium.substanceNames[1:Medium.nXi]) if use_Xi_in
            "Prescribed boundary composition"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput C_in[Medium.nC](
            final quantity=Medium.extraPropertiesNames) if use_C_in
            "Prescribed boundary trace substances"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

        initial equation
          assert(not use_X_in or not use_Xi_in,
            "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");

          if not use_X_in and not use_Xi_in then
            Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
              Medium.singleState, true, X_in_internal, "Boundary_pT");
          end if;

        equation
          if use_X_in or use_Xi_in then
            Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
              Medium.singleState, true, X_in_internal, "Boundary_pT");
          end if;

          // Assign Xi_in_internal and X_in_internal
          // Note that at most one of X_in or Xi_in is present
          connect(X_in, X_in_internal);
          connect(Xi_in, Xi_in_internal);

          if use_Xi_in then
            // Must assign all components of X_in_internal, using Xi_in
            X_in_internal[1:Medium.nXi] = Xi_in_internal[1:Medium.nXi];
            // If reducedX = true, medium contains the equation sum(X) = 1.0
            // Media with only one substance (e.g., water) have reducedX=true
            // FlueGas and SimpleNaturalGas has reducedX = false
            if Medium.reducedX then
              X_in_internal[Medium.nX] = 1-sum(Xi_in_internal);
            end if;
          elseif use_X_in then
            X_in_internal[1:Medium.nXi] = Xi_in_internal[1:Medium.nXi];
          else
            // No connector is used. Use parameter X.
            X_in_internal = X;
            Xi_in_internal = X[1:Medium.nXi];
          end if;

          connect(C_in, C_in_internal);

          if not use_C_in then
            C_in_internal = C;
          end if;

          for i in 1:nPorts loop
            ports[i].Xi_outflow = Xi_in_internal;
            ports[i].C_outflow = C_in_internal;
          end for;


          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Text(
                  visible=use_X_in,
                  extent={{-164,4},{-62,-36}},
                  textColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="X"),
                Text(
                  visible=use_Xi_in,
                  extent={{-164,4},{-62,-36}},
                  textColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Xi"),
                Text(
                  visible=use_C_in,
                  extent={{-164,-90},{-62,-130}},
                  textColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="C")}),
                  Documentation(info="<html>
<p>
Partial model that defines outflowing properties
<code>ports.Xi_outflow</code> and <code>ports.C_outflow</code>
using an optional input for both.
Otherwise the parameter value is used.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 11, 2024, by Michael Wetter:<br/>
Corrected use of <code>HideResult</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1850\">#1850</a>.
</li>
<li>
September 19, 2019, by Michael Wetter:<br/>
Refactored handling of mass fractions which was needed to handle media such as
<a href=\"modelica://Modelica.Media.IdealGases.MixtureGases.FlueGasSixComponents\">
Modelica.Media.IdealGases.MixtureGases.FlueGasSixComponents</a> and
<a href=\"modelica://Modelica.Media.IdealGases.MixtureGases.SimpleNaturalGas\">
Modelica.Media.IdealGases.MixtureGases.SimpleNaturalGas</a>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1205\">IBPSA, #1205</a>.
</li>
<li>
February 13, 2018, by Michael Wetter:<br/>
Corrected error in quantity assignment for <code>Xi_in</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
</ul>
</html>"));
        end PartialSource_Xi_C;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Sources\">Buildings.Fluid.Sources</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <b>Sources</b> contains generic sources for fluid connectors
to define fixed or prescribed ambient conditions.
</p>
</html>"));
    end Sources;

    package Types "Package with type definitions"
      extends Modelica.Icons.TypesPackage;

      type CvTypes = enumeration(
          OpPoint "flow coefficient defined by m_flow_nominal/sqrt(dp_nominal)",
          Kv "Kv (metric) flow coefficient",
          Cv "Cv (US) flow coefficient",
          Av "Av (metric) flow coefficient")
        "Enumeration to define the choice of valve flow coefficient" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the choice of valve flow coefficient
(to be selected via choices menu):
</p>

<table summary=\"summary\"  border=\"1\">
<tr><th>Enumeration</th>
    <th>Description</th></tr>

<tr><td>OpPoint</td>
    <td>flow coefficient defined by ratio m_flow_nominal/sqrt(dp_nominal)</td></tr>

<tr><td>Kv</td>
    <td>Kv (metric) flow coefficient</td></tr>

<tr><td>Cv</td>
    <td>Cv (US) flow coefficient</td></tr>

<tr><td>Av</td>
    <td>Av (metric) flow coefficient</td></tr>

</table>

<p>
The details of the coefficients are explained in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">
Users Guide</a>.
</p>

</html>"));

      type InputType = enumeration(
          Constant "Use parameter to set stage",
          Stages "Use integer input to select stage",
          Continuous "Use continuous, real input") "Input options for movers"
        annotation (Documentation(info="<html>
<p>
This type allows defining which type of input should be used for movers.
This can either be
</p>
<ol>
<li>
a constant set point declared by a parameter,
</li>
<li>
a series of possible set points that can be switched using an integer input, or
</li>
<li>
a continuously variable set point.
</li>
</ol>
</html>",     revisions="<html>
<ul>
<li>
April 2, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
     annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>"));
    end Types;

    package Interfaces "Package with interfaces for fluid models"
      extends Modelica.Icons.InterfacesPackage;

      model ConservationEquation "Lumped volume with mass and energy balance"

        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;

        // Constants
        parameter Boolean initialize_p = not Medium.singleState
          "= true to set up initial equations for pressure"
          annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";

        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s")
          if use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow
          if use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that use this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=hStart)
          "Leaving specific enthalpy of the component"
           annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));
        Modelica.Blocks.Interfaces.RealOutput UOut(unit="J")
          "Internal energy of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,20})));
        Modelica.Blocks.Interfaces.RealOutput mXiOut[Medium.nXi](each min=0, each unit="kg")
          "Species mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-20})));
        Modelica.Blocks.Interfaces.RealOutput mOut(min=0, unit="kg")
          "Mass of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,60})));
        Modelica.Blocks.Interfaces.RealOutput mCOut[Medium.nC](each min=0, each unit="kg")
          "Trace substance mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-60})));

        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each final package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-100})));

        // Set nominal attributes where literal values can be used.
        Medium.BaseProperties medium(
          p(start=p_start),
          h(start=hStart),
          T(start=T_start),
          Xi(
            each stateSelect=if medium.preferredMediumStates then StateSelect.prefer else StateSelect.default,
            start=X_start[1:Medium.nXi]),
          X(start=X_start),
          d(start=rho_start)) "Medium properties";

        Modelica.Units.SI.Energy U(
          start=fluidVolume*rho_start*
              Medium.specificInternalEnergy(Medium.setState_pTX(
              T=T_start,
              p=p_start,
              X=X_start[1:Medium.nXi])) + (T_start - Medium.reference_T)*CSen,
            nominal=1E5) "Internal energy of fluid";

        Modelica.Units.SI.Mass m(start=fluidVolume*rho_start, stateSelect=if
              massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
              StateSelect.default else StateSelect.prefer) "Mass of fluid";

        Modelica.Units.SI.Mass[Medium.nXi] mXi(
          each stateSelect=StateSelect.never,
          start=fluidVolume*rho_start*X_start[1:Medium.nXi])
          "Masses of independent components in the fluid";
        Modelica.Units.SI.Mass[Medium.nC] mC(start=fluidVolume*rho_start*C_start)
          "Masses of trace substances in the fluid";
        // C need to be added here because unlike for Xi, which has medium.Xi,
        // there is no variable medium.C
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
          "Trace substance mixture content";

        Modelica.Units.SI.MassFlowRate mb_flow "Mass flows across boundaries";
        Modelica.Units.SI.MassFlowRate[Medium.nXi] mbXi_flow
          "Substance mass flows across boundaries";
        Medium.ExtraPropertyFlowRate[Medium.nC] mbC_flow
          "Trace substance mass flows across boundaries";
        Modelica.Units.SI.EnthalpyFlowRate Hb_flow
          "Enthalpy flow across boundaries or energy source/sink";

        // Parameters that need to be defined by an extending class
        parameter Modelica.Units.SI.Volume fluidVolume "Volume";
        final parameter Modelica.Units.SI.HeatCapacity CSen=(mSenFac - 1)*rho_default
            *cp_default*fluidVolume
          "Aditional heat capacity for implementing mFactor";
    protected
        Medium.EnthalpyFlowRate ports_H_flow[nPorts];
        Modelica.Units.SI.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
        Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];
        parameter Modelica.Units.SI.SpecificHeatCapacity cp_default=
            Medium.specificHeatCapacityCp(state=state_default)
          "Heat capacity, to compute additional dry mass";
        parameter Modelica.Units.SI.Density rho_start=Medium.density(
            Medium.setState_pTX(
            T=T_start,
            p=p_start,
            X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass";

        // Parameter for avoiding extra overhead calculations when CSen==0
        final parameter Boolean computeCSen = abs(mSenFac-1) > Modelica.Constants.eps
          annotation(Evaluate=true);
        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.Units.SI.Density rho_default=Medium.density(state=
            state_default) "Density, used to compute fluid mass";
        // Parameter that is used to construct the vector mXi_flow
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(
                                                  string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";
        parameter Modelica.Units.SI.SpecificEnthalpy hStart=
            Medium.specificEnthalpy_pTX(
            p_start,
            T_start,
            X_start) "Start value for specific enthalpy";

        // Set _simplify_mWat_flow == false for Glycol47; otherwise Dymola 2018FD01
        // cannot differentiate the equations.
        constant Boolean _simplify_mWat_flow = simplify_mWat_flow and Medium.nX > 1
         "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";

        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";

      initial equation
        // Assert that the substance with name 'water' has been found.
        if use_mWat_flow then
          assert(Medium.nXi == 0 or abs(sum(s) - 1) < 1e-5, "In " + getInstanceName()
             + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '"
             + Medium.mediumName + "'.
         Check medium model.");
        end if;

        // Make sure that if energyDynamics is SteadyState, then
        // massDynamics is also SteadyState.
        // Otherwise, the system of ordinary differential equations may be inconsistent.
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          assert(massDynamics == energyDynamics, "In " + getInstanceName() + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
        end if;

        // initialization of balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
            medium.T = T_start;
        else
          if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
              der(medium.T) = 0;
          end if;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          if initialize_p then
            medium.p = p_start;
          end if;
        else
          if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            if initialize_p then
              der(medium.p) = 0;
            end if;
          end if;
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          medium.Xi = X_start[1:Medium.nXi];
        else
          if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(medium.Xi) = zeros(Medium.nXi);
          end if;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          C = C_start[1:Medium.nC];
        else
          if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(C) = zeros(Medium.nC);
          end if;
        end if;

      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Total quantities
        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          m = fluidVolume*rho_start;
        else
          if _simplify_mWat_flow then
            // If moisture is neglected in mass balance, assume for computation
            // of the mass of air that the air is at Medium.X_default.
            m = fluidVolume*Medium.density(Medium.setState_phX(
              p = medium.p,
              h = hOut,
              X = Medium.X_default));
          else
            // Use actual density
            m = fluidVolume*medium.d;
          end if;
        end if;
        mXi = m*medium.Xi;
        if computeCSen then
          U = m*medium.u + CSen*(medium.T-Medium.reference_T);
        else
          U = m*medium.u;
        end if;
        mC = m*C;

        hOut = medium.h;
        XiOut = medium.Xi;
        COut = C;

        for i in 1:nPorts loop
          //The semiLinear function should be used for the equations below
          //for allowing min/max simplifications.
          //See https://github.com/ibpsa/modelica-ibpsa/issues/216 for a discussion and motivation
          ports_H_flow[i]     = semiLinear(ports[i].m_flow, inStream(ports[i].h_outflow), ports[i].h_outflow)
            "Enthalpy flow";
          for j in 1:Medium.nXi loop
            ports_mXi_flow[i,j] = semiLinear(ports[i].m_flow, inStream(ports[i].Xi_outflow[j]), ports[i].Xi_outflow[j])
              "Component mass flow";
          end for;
          for j in 1:Medium.nC loop
            ports_mC_flow[i,j]  = semiLinear(ports[i].m_flow, inStream(ports[i].C_outflow[j]),  ports[i].C_outflow[j])
              "Trace substance mass flow";
          end for;
        end for;

        for i in 1:Medium.nXi loop
          mbXi_flow[i] = sum(ports_mXi_flow[:,i]);
        end for;

        for i in 1:Medium.nC loop
          mbC_flow[i]  = sum(ports_mC_flow[:,i]);
        end for;

        mb_flow = sum(ports.m_flow);
        Hb_flow = sum(ports_H_flow);

        // Energy and mass balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = Hb_flow + Q_flow;
        else
          der(U) = Hb_flow + Q_flow;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        else
          der(m) = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nXi) = mbXi_flow + mWat_flow_internal * s;
        else
          der(medium.Xi) = (mbXi_flow + mWat_flow_internal * s)/m;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nC)  = mbC_flow + C_flow_internal;
        else
          der(mC)  = mbC_flow + C_flow_internal;
        end if;

        // Properties of outgoing flows
        for i in 1:nPorts loop
            ports[i].p          = medium.p;
            ports[i].h_outflow  = medium.h;
            ports[i].Xi_outflow = medium.Xi;
            ports[i].C_outflow  = C;
        end for;
        UOut=U;
        mXiOut=mXi;
        mOut=m;
        mCOut=mC;
        annotation (
          Documentation(info="<html>
<p>
Basic model for an ideally mixed fluid volume with the ability to store mass and energy.
It implements a dynamic or a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code> then adding
moisture does not increase the mass of the volume or the leaving mass flow rate.
It does however change the mass fraction <code>medium.Xi</code>.
This allows to decouple the moisture balance from the pressure drop equations.
If <code>simplify_mWat_flow = false</code>, then
the outlet mass flow rate is
<i>m<sub>out</sub> = m<sub>in</sub>  (1 + &Delta; X<sub>w</sub>)</i>,
where
<i>&Delta; X<sub>w</sub></i> is the change in water vapor mass
fraction across the component. In this case,
this component couples
the energy calculation to the
pressure drop versus mass flow rate calculations.
However, in typical building HVAC systems,
<i>&Delta; X<sub>w</sub></i> &lt; <i>0.005</i> kg/kg.
Hence, by tolerating a relative error of <i>0.005</i> in the mass balance,
one can decouple these equations.
Decoupling these equations avoids having
to compute the energy balance of the humidifier
and its upstream components when solving for the
pressure drop of downstream components.
Therefore, the default value is <code>simplify_mWat_flow = true</code>.
</p>
<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
The model
<a href=\"modelica://Buildings.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling\">
Buildings.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling</a>
shows that the relative error on the temperature difference between these
two options of <code>simplify_mWat_flow</code> is less than
<i>0.1%</i>.
</p>

<h4>Implementation</h4>
<p>
When extending or instantiating this model, the input
<code>fluidVolume</code>, which is the actual volume occupied by the fluid,
needs to be assigned.
For most components, this can be set to a parameter.
</p>
Input connectors of the model are
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can be used as a dynamic model or as a steady-state model.
However, for a steady-state model with exactly two fluid ports connected,
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
provides a more efficient implementation.
</p>
<p>
For a model that instantiates this model, see
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 24, 2022, by Michael Wetter:<br/>
Conditionally removed assertion that checks for water content as this is
only required if water is added to the medium.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1650\">#1650</a>.
</li>
<li>
September 9, 2022, by Michael Wetter:<br/>
Changed state variable from <code>mXi</code> to <code>medium.Xi</code>
as this allows setting a good nominal attribute without having to use the fluid volume,
which is non-literal value that leads to a warning in Dymola.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1634\">1634</a>.
</li>
<li>
April 26, 2019, by Filip Jorissen:<br/>
Returning <code>getInstanceName()</code> in asserts.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1133\">1133</a>.
</li>
<li>
April 16, 2019, by Michael Wetter:<br/>
Changed computation of <code>computeCSen</code> to avoid the volume to become
a structural parameter.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1122\">IBPSA, issue 1122</a>.
</li>
<li>
April 16, 2018, by Michael Wetter:<br/>
Reformulated mass calculation so that Dymola can differentiate the equations.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/910\">IBPSA, issue 910</a>.
</li>
<li>
November 3, 2017, by Michael Wetter:<br/>
Set <code>start</code> attributes.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/727\">727</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
January 27, 2017, by Michael Wetter:<br/>
Added <code>stateSelect</code> for mass <code>m</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/642\">
Buildings, #642</a>.
</li>
<li>
December 22, 2016, by Michael Wetter:<br/>
Set nominal value for <code>U</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/637\">637</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs UOut, mOut, mXiOut, mCOut for being able to
check conservation of quantities.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Added <code>C_flow</code> to the steady-state trace substance balance,
and removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
</li>
<li>
September 3, 2015, by Filip Jorissen and Michael Wetter:<br/>
Revised implementation for allowing moisture mass flow rate
to be approximated using parameter <code>simplify_mWat_flow</code>.
This may lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
June 5, 2015 by Michael Wetter:<br/>
Removed <code>preferredMediumStates= false</code> in
the instance <code>medium</code> as the default
is already <code>false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015 by Filip Jorissen:<br/>
Removed <pre>
Xi(start=X_start[1:Medium.nXi],
       each stateSelect=if (not (substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
       then StateSelect.prefer else StateSelect.default),
</pre>
and set
<code>preferredMediumStates = false</code>
because the previous declaration led to more equations and
translation problems in large models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> of <code>PartialMixingVolume</code>
to this model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
This revison also renames the protected variable
<code>rho_nominal</code> to <code>rho_start</code>
as it depends on the start values and not the nominal values.
</li>
<li>
May 22, 2015 by Michael Wetter:<br/>
Removed <pre>
p(stateSelect=if not (massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
then StateSelect.prefer else StateSelect.default)
</pre>
because the previous declaration led to the translation error
<pre>
The model requires derivatives of some inputs as listed below:
1 inlet.m_flow
1 inlet.p
</pre>
when translating
<code>Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.HeaterCooler_u</code>
with a dynamic energy balance.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
April 13, 2015, by Filip Jorissen:<br/>
Now using <code>semiLinear()</code> function for calculation of
<code>ports_H_flow</code>. This enables Dymola to simplify based on
the <code>min</code> and <code>max</code> attribute of the mass flow rate.
</li>
<li>
February 16, 2015, by Filip Jorissen:<br/>
Fixed SteadyState massDynamics implementation for compressible media.
Mass <code>m</code> is now constant.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Set start attributes in <code>medium</code> to avoid in OpenModelica the warning
alias set with several free start values.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>
September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.<br/>
Corrected the syntax error
<code>Medium.ExtraProperty C[Medium.nC](each nominal=C_nominal)</code>
to
<code>Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)</code>
because <code>C_nominal</code> is a vector.
This syntax error caused a compilation error in OpenModelica.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
July 31, 2011 by Michael Wetter:<br/>
Added test to stop model translation if the setting for
<code>energyBalance</code> and <code>massBalance</code>
can lead to inconsistent equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Removed the option to use <code>h_start</code>, as this
is not needed for building simulation.
Also removed the reference to <code>Modelica.Fluid.System</code>.
Moved parameters and medium to
<a href=\"modelica://Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start value for medium density.
</li>
<li>
March 29, 2011 by Michael Wetter:<br/>
Changed default value for <code>substanceDynamics</code> and
<code>traceDynamics</code> from <code>energyDynamics</code>
to <code>massDynamics</code>.
</li>
<li>
September 28, 2010 by Michael Wetter:<br/>
Changed array index for nominal value of <code>Xi</code>.
</li>
<li>
September 13, 2010 by Michael Wetter:<br/>
Set nominal attributes for medium based on default medium values.
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added parameter <code>C_nominal</code> which is used as the nominal attribute for <code>C</code>.
Without this value, the ODE solver gives wrong results for concentrations around 1E-7.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li><i>February 6, 2010</i> by Michael Wetter:<br/>
Added to <code>Medium.BaseProperties</code> the initialization
<code>X(start=X_start[1:Medium.nX])</code>. Previously, the initialization
was only done for <code>Xi</code> but not for <code>X</code>, which caused the
medium to be initialized to <code>reference_X</code>, ignoring the value of <code>X_start</code>.
</li>
<li><i>October 12, 2009</i> by Michael Wetter:<br/>
Implemented first version in <code>Buildings</code> library, based on model from
<code>Modelica.Fluid 1.0</code>.
</li>
</ul>
</html>"),Icon(graphics={            Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-89,17},{-54,34}},
                textColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-89,52},{-54,69}},
                textColor={0,0,127},
                textString="Q_flow"),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-42,-28},{-6,-28},{18,4},{40,12},{66,14}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Text(
                extent={{-155,-120},{145,-160}},
                textColor={0,0,255},
                textString="%name")}));
      end ConservationEquation;

      model FourPortHeatMassExchanger
        "Model transporting two fluid streams between four ports with storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialFourPortInterface(
          port_a1(h_outflow(start=h1_outflow_start)),
          port_b1(h_outflow(start=h1_outflow_start)),
          port_a2(h_outflow(start=h2_outflow_start)),
          port_b2(h_outflow(start=h2_outflow_start)));
        extends Buildings.Fluid.Interfaces.FourPortFlowResistanceParameters(
           final computeFlowResistance1=true, final computeFlowResistance2=true);

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Modelica.Units.SI.Time tau1=30 "Time constant at nominal flow"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));
        parameter Modelica.Units.SI.Time tau2=30 "Time constant at nominal flow"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));

        // Initialization
        parameter Medium1.AbsolutePressure p1_start = Medium1.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 1"));
        parameter Medium1.Temperature T1_start = Medium1.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 1"));
        parameter Medium1.MassFraction X1_start[Medium1.nX] = Medium1.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nXi > 0));
        parameter Medium1.ExtraProperty C1_start[Medium1.nC](
          final quantity=Medium1.extraPropertiesNames)=fill(0, Medium1.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nC > 0));
        parameter Medium1.ExtraProperty C1_nominal[Medium1.nC](
          final quantity=Medium1.extraPropertiesNames) = fill(1E-2, Medium1.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nC > 0));

        parameter Medium2.AbsolutePressure p2_start = Medium2.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 2"));
        parameter Medium2.Temperature T2_start = Medium2.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 2"));
        parameter Medium2.MassFraction X2_start[Medium2.nX] = Medium2.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nXi > 0));
        parameter Medium2.ExtraProperty C2_start[Medium2.nC](
          final quantity=Medium2.extraPropertiesNames)=fill(0, Medium2.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nC > 0));
        parameter Medium2.ExtraProperty C2_nominal[Medium2.nC](
          final quantity=Medium2.extraPropertiesNames) = fill(1E-2, Medium2.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nC > 0));

        Modelica.Units.SI.HeatFlowRate Q1_flow=vol1.heatPort.Q_flow
          "Heat flow rate into medium 1";
        Modelica.Units.SI.HeatFlowRate Q2_flow=vol2.heatPort.Q_flow
          "Heat flow rate into medium 2";

        replaceable Buildings.Fluid.MixingVolumes.BaseClasses.MixingVolumeHeatPort vol1
          constrainedby
        Buildings.Fluid.MixingVolumes.BaseClasses.MixingVolumeHeatPort(
              redeclare final package Medium = Medium1,
              nPorts = 2,
              V=m1_flow_nominal*tau1/rho1_nominal,
              final allowFlowReversal=allowFlowReversal1,
              final m_flow_nominal=m1_flow_nominal,
              energyDynamics=if tau1 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
              massDynamics=if tau1 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
              final p_start=p1_start,
              final T_start=T1_start,
              final X_start=X1_start,
              final C_start=C1_start,
              final C_nominal=C1_nominal,
              mSenFac=1) "Volume for fluid 1"
          annotation (Placement(transformation(extent={{-10,70}, {10,50}})));

        replaceable Buildings.Fluid.MixingVolumes.MixingVolume vol2
          constrainedby
        Buildings.Fluid.MixingVolumes.BaseClasses.MixingVolumeHeatPort(
              redeclare final package Medium = Medium2,
              nPorts = 2,
              V=m2_flow_nominal*tau2/rho2_nominal,
              final allowFlowReversal=allowFlowReversal2,
              mSenFac=1,
              final m_flow_nominal = m2_flow_nominal,
              energyDynamics=if tau2 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
              massDynamics=if tau2 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
              final p_start=p2_start,
              final T_start=T2_start,
              final X_start=X2_start,
              final C_start=C2_start,
              final C_nominal=C2_nominal) "Volume for fluid 2"
         annotation (Placement(transformation(
              origin={2,-60},
              extent={{-10,10},{10,-10}},
              rotation=180)));

        Buildings.Fluid.FixedResistances.PressureDrop preDro1(
          redeclare final package Medium = Medium1,
          final m_flow_nominal=m1_flow_nominal,
          final deltaM=deltaM1,
          final allowFlowReversal=allowFlowReversal1,
          final show_T=false,
          final from_dp=from_dp1,
          final linearized=linearizeFlowResistance1,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp1_nominal) "Flow resistance of fluid 1"
          annotation (Placement(transformation(extent={{-80,70},{-60,90}})));

        Buildings.Fluid.FixedResistances.PressureDrop preDro2(
          redeclare final package Medium = Medium2,
          final m_flow_nominal=m2_flow_nominal,
          final deltaM=deltaM2,
          final allowFlowReversal=allowFlowReversal2,
          final show_T=false,
          final from_dp=from_dp2,
          final linearized=linearizeFlowResistance2,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp2_nominal) "Flow resistance of fluid 2"
          annotation (Placement(transformation(extent={{80,-90},{60,-70}})));

    protected
        parameter Medium1.ThermodynamicState sta1_nominal=Medium1.setState_pTX(
            T=Medium1.T_default, p=Medium1.p_default, X=Medium1.X_default);
        parameter Modelica.Units.SI.Density rho1_nominal=Medium1.density(sta1_nominal)
          "Density, used to compute fluid volume";
        parameter Medium2.ThermodynamicState sta2_nominal=Medium2.setState_pTX(
            T=Medium2.T_default, p=Medium2.p_default, X=Medium2.X_default);
        parameter Modelica.Units.SI.Density rho2_nominal=Medium2.density(sta2_nominal)
          "Density, used to compute fluid volume";

        parameter Medium1.ThermodynamicState sta1_start=Medium1.setState_pTX(
            T=T1_start, p=p1_start, X=X1_start);
        parameter Modelica.Units.SI.SpecificEnthalpy h1_outflow_start=
            Medium1.specificEnthalpy(sta1_start)
          "Start value for outflowing enthalpy";
        parameter Medium2.ThermodynamicState sta2_start=Medium2.setState_pTX(
            T=T2_start, p=p2_start, X=X2_start);
        parameter Modelica.Units.SI.SpecificEnthalpy h2_outflow_start=
            Medium2.specificEnthalpy(sta2_start)
          "Start value for outflowing enthalpy";

      initial equation
        // Check for tau1
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau1 > Modelica.Constants.eps,
      "The parameter tau1, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau1 = "       + String(tau1) + "\n");

       // Check for tau2
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau2 > Modelica.Constants.eps,
      "The parameter tau2, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau2 = "       + String(tau2) + "\n");

        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        connect(vol1.ports[2], port_b1) annotation (Line(
            points={{0,70},{20,70},{20,60},{100,60}},
            color={0,127,255}));
        connect(vol2.ports[2], port_b2) annotation (Line(
            points={{2,-70},{-30,-70},{-30,-60},{-100,-60}},
            color={0,127,255}));
        connect(port_a1, preDro1.port_a) annotation (Line(
            points={{-100,60},{-90,60},{-90,80},{-80,80}},
            color={0,127,255}));
        connect(preDro1.port_b, vol1.ports[1]) annotation (Line(
            points={{-60,80},{0,80},{0,70}},
            color={0,127,255}));
        connect(port_a2, preDro2.port_a) annotation (Line(
            points={{100,-60},{90,-60},{90,-80},{80,-80}},
            color={0,127,255}));
        connect(preDro2.port_b, vol2.ports[1]) annotation (Line(
            points={{60,-80},{2,-80},{2,-70}},
            color={0,127,255}));
        annotation (
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports.
It provides the basic model for implementing a dynamic heat exchanger.
</p>
<p>
The model can be used as-is, although there will be no heat or mass transfer
between the two fluid streams.
To add heat transfer, heat flow can be added to the heat port of the two volumes.
See for example
<a href=\"modelica://Buildings.Fluid.Chillers.Carnot_y\">
Buildings.Fluid.Chillers.Carnot_y</a>.
To add moisture input into (or moisture output from) volume <code>vol2</code>,
the model can be replaced with
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir\">
Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir</a>.
</p>
<h4>Implementation</h4>
<p>
The variable names follow the conventions used in
<a href=\"modelica://Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX\">
Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 3, 2022, by Michael Wetter:<br/>
Removed <code>massDynamics</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">issue 1542</a>.
</li>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
October 23, 2017, by Michael Wetter:<br/>
Made volume <code>vol1</code> replaceable. This is required for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Set <code>quantity</code> attributes.
</li>
<li>
November 13, 2015, by Michael Wetter:<br/>
Changed assignments of start values in <code>extends</code> statement.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/299\">#299</a>.
</li>
<li>
June 2, 2015, by Filip Jorissen:<br/>
Removed final modifier from <code>mSenFac</code> in
<code>vol1</code> and <code>vol2</code>.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/258=\">#258</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Added missing propagation of <code>allowFlowReversal</code> to
instances <code>vol1</code> and <code>vol2</code>.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">#412</a>.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in pressure drop elements to be final.
</li>
<li>
May 28, 2014, by Michael Wetter:<br/>
Removed <code>annotation(Evaluate=true)</code> for parameters <code>tau1</code>
and <code>tau2</code>.
This is needed to allow changing the time constant after translation.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
September 26, 2013, by Michael Wetter:<br/>
Removed unrequired <code>sum</code> operator.
</li>
<li>
February 6, 2012, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Removed assignment of <code>m_flow_small</code> as it is no
longer used in its base class.
</li>
<li>
July 29, 2011, by Michael Wetter:
<ul>
<li>
Changed values of
<code>h_outflow_a1_start</code>,
<code>h_outflow_b1_start</code>,
<code>h_outflow_a2_start</code> and
<code>h_outflow_b2_start</code>, and
declared them as final.
</li>
<li>
Set nominal values for <code>vol1.C</code> and <code>vol2.C</code>.
</li>
</ul>
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Changed parameterization of fluid volume so that steady-state balance is
used when <code>tau = 0</code>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
September 10, 2008 by Michael Wetter:<br/>
Added <code>stateSelect=StateSelect.always</code> for temperature of volume 1.
</li>
<li>
Changed temperature sensor from Celsius to Kelvin.
Unit conversion should be made during output
processing.
</li>
<li>
August 5, 2008, by Michael Wetter:<br/>
Replaced instances of <code>Delays.DelayFirstOrder</code> with instances of
<code>MixingVolumes.MixingVolume</code>. This allows to extract liquid for a condensing cooling
coil model.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-99,64},{102,54}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-99,-56},{102,-66}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end FourPortHeatMassExchanger;

      block LumpedVolumeDeclarations "Declarations for lumped volumes"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state, must be steady state if energyDynamics is steady state"
          annotation(Evaluate=true, Dialog(tab = "Advanced", group="Dynamics"));
        final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
          "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));
        final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
          "Type of trace substance balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start=Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
             quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
             quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Real mSenFac(min=1)=1
          "Factor for scaling the sensible thermal mass of the volume"
          annotation(Dialog(tab="Dynamics"));

        // The parameter below is evaluated by OCT during compilation, and
        // if false, the assert statement won't be optimized away during
        // code generation.
    protected
        final parameter Boolean wrongEnergyMassBalanceConfiguration=
          not (energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
               massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
          "True if configuration of energy and mass balance is wrong."
          annotation(Evaluate=true);
      initial equation
        if wrongEnergyMassBalanceConfiguration then
        assert(not wrongEnergyMassBalanceConfiguration,
               "In " + getInstanceName() +
               ": energyDynamics is selected as steady state, and therefore massDynamics must also be steady-state.");
        end if;

      annotation (preferredView="info",
      Documentation(info="<html>
<p>
This class contains parameters and medium properties
that are used in the lumped  volume model, and in models that extend the
lumped volume model.
</p>
<p>
These parameters are used for example by
<a href=\"modelica://Buildings.Fluid.Interfaces.ConservationEquation\">
Buildings.Fluid.Interfaces.ConservationEquation</a>,
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a> and
<a href=\"modelica://Buildings.Fluid.HeatExchangers.Radiators.RadiatorEN442_2\">
Buildings.Fluid.HeatExchangers.Radiators.RadiatorEN442_2</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
March 3, 2022, by Michael Wetter:<br/>
Moved <code>massDynamics</code> to <code>Advanced</code> tab,
added assertion for correct combination of energy and mass dynamics and
changed type from <code>record</code> to <code>block</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">issue 1542</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
November 9, 2018 by Michael Wetter:<br/>
Limited choices of media that are displayed in the pull down menu of
graphical editors.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">issue 1050</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
August 2, 2011, by Michael Wetter:<br/>
Set <code>substanceDynamics</code> and <code>traceDynamics</code> to final
and equal to <code>energyDynamics</code>,
as there is no need to make them different from <code>energyDynamics</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.DynamicFreeInitial</code> because
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code> leads
to high order DAE that Dymola cannot reduce.
</li>
<li>
July 31, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LumpedVolumeDeclarations;

      partial model PartialFourPort "Partial model with four ports"

        replaceable package Medium1 =
          Modelica.Media.Interfaces.PartialMedium "Medium 1 in the component"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));
        replaceable package Medium2 =
          Modelica.Media.Interfaces.PartialMedium "Medium 2 in the component"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal1 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal2 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                           redeclare final package Medium = Medium1,
                           m_flow(min=if allowFlowReversal1 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{-110,50},{-90,70}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b1(
                           redeclare final package Medium = Medium1,
                           m_flow(max=if allowFlowReversal1 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{110,50},{90,70}})));

        Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                           redeclare final package Medium = Medium2,
                           m_flow(min=if allowFlowReversal2 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector a2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b2(
                           redeclare final package Medium = Medium2,
                           m_flow(max=if allowFlowReversal2 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector b2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{-90,-70},{-110,-50}})));

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model defines an interface for components with four ports.
The parameters <code>allowFlowReversal1</code> and
<code>allowFlowReversal2</code> may be used by models that extend
this model to treat flow reversal.
</p>
<p>
This model is identical to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>, except for the
fowllowing:
</p>
<ol>
<li>it has four ports, and
</li>
<li>
the parameters <code>port_a_exposesState</code>,
<code>port_b_exposesState</code> and
<code>showDesignFlowDirection</code>
are not implemented.
</li>
</ol>
</html>",       revisions="<html>
<ul>
<li>
April 6, 2020, by Filip Jorissen:<br/>
Added arrows to the icon indicating the intended flow direction
when <code>allowFlowReversal=false</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1336\">#1336</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Renamed model from <code>FourPort</code> to
<code>PartialFourPort</code>.
Removed parameters
<code>h_outflow_a1_start</code>,
<code>h_outflow_b1_start</code>,
<code>h_outflow_a2_start</code> and
<code>h_outflow_b2_start</code>.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/299\">#299</a>.
</li>
<li>
October 30, 2015, by Matthis Thorade:<br/>
Added <code>partial</code> keyword to model declaration.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
September 26, 2013 by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of nominal value for
<code>Xi_outflow</code>.
</li>
<li>
September 17, 2010 by Michael Wetter:<br/>
Fixed bug: The start value for <code>port_b1.h_outflow</code>
was set to <code>h_outflow_b2_start</code> instead of <code>h_outflow_b1_start</code>.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Added start values for outflowing enthalpy because they
are often iteration variables in nonlinear equation systems.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
            Text(
                extent={{-151,147},{149,107}},
                textColor={0,0,255},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                textString="%name"),
            Polygon(
                points={{-5,10},{25,10},{-5,-10},{-5,10}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal1,
                origin={75,50},
                rotation=360),
            Polygon(
                points={{10,10},{-20,-10},{10,-10},{10,10}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal2,
                origin={-79,-50},
                rotation=360)}));
      end PartialFourPort;

      partial model PartialFourPortInterface
        "Partial model with four ports and declaration of quantities that are used by many models"
        extends Buildings.Fluid.Interfaces.PartialFourPort;
        parameter Modelica.Units.SI.MassFlowRate m1_flow_nominal(min=0)
          "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
        parameter Modelica.Units.SI.MassFlowRate m2_flow_nominal(min=0)
          "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
        parameter Medium1.MassFlowRate m1_flow_small(min=0) = 1E-4*abs(m1_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium2.MassFlowRate m2_flow_small(min=0) = 1E-4*abs(m2_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
        parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation (
            Dialog(tab="Advanced", group="Diagnostics"),
            HideResult=true);


        Medium1.MassFlowRate m1_flow = port_a1.m_flow
          "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
        Modelica.Units.SI.PressureDifference dp1(displayUnit="Pa") = port_a1.p - port_b1.p
          "Pressure difference between port_a1 and port_b1";

        Medium2.MassFlowRate m2_flow = port_a2.m_flow
          "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
        Modelica.Units.SI.PressureDifference dp2(displayUnit="Pa") = port_a2.p - port_b2.p
          "Pressure difference between port_a2 and port_b2";

        Medium1.ThermodynamicState sta_a1=
          if allowFlowReversal1 then
            Medium1.setState_phX(port_a1.p,
                                noEvent(actualStream(port_a1.h_outflow)),
                                noEvent(actualStream(port_a1.Xi_outflow)))
          else
            Medium1.setState_phX(port_a1.p,
                                inStream(port_a1.h_outflow),
                                inStream(port_a1.Xi_outflow))
            if show_T "Medium properties in port_a1";
        Medium1.ThermodynamicState sta_b1=
          if allowFlowReversal1 then
            Medium1.setState_phX(port_b1.p,
                                noEvent(actualStream(port_b1.h_outflow)),
                                noEvent(actualStream(port_b1.Xi_outflow)))
          else
            Medium1.setState_phX(port_b1.p,
                                port_b1.h_outflow,
                                port_b1.Xi_outflow)
             if show_T "Medium properties in port_b1";

        Medium2.ThermodynamicState sta_a2=
          if allowFlowReversal2 then
            Medium2.setState_phX(port_a2.p,
                                noEvent(actualStream(port_a2.h_outflow)),
                                noEvent(actualStream(port_a2.Xi_outflow)))
          else
            Medium2.setState_phX(port_a2.p,
                                inStream(port_a2.h_outflow),
                                inStream(port_a2.Xi_outflow))
            if show_T "Medium properties in port_a2";
        Medium2.ThermodynamicState sta_b2=
          if allowFlowReversal2 then
            Medium2.setState_phX(port_b2.p,
                                noEvent(actualStream(port_b2.h_outflow)),
                                noEvent(actualStream(port_b2.Xi_outflow)))
          else
            Medium2.setState_phX(port_b2.p,
                                port_b2.h_outflow,
                                port_b2.Xi_outflow)
             if show_T "Medium properties in port_b2";

    protected
        Medium1.ThermodynamicState state_a1_inflow=
          Medium1.setState_phX(port_a1.p, inStream(port_a1.h_outflow), inStream(port_a1.Xi_outflow))
          "state for medium inflowing through port_a1";
        Medium1.ThermodynamicState state_b1_inflow=
          Medium1.setState_phX(port_b1.p, inStream(port_b1.h_outflow), inStream(port_b1.Xi_outflow))
          "state for medium inflowing through port_b1";
        Medium2.ThermodynamicState state_a2_inflow=
          Medium2.setState_phX(port_a2.p, inStream(port_a2.h_outflow), inStream(port_a2.Xi_outflow))
          "state for medium inflowing through port_a2";
        Medium2.ThermodynamicState state_b2_inflow=
          Medium2.setState_phX(port_b2.p, inStream(port_b2.h_outflow), inStream(port_b2.Xi_outflow))
          "state for medium inflowing through port_b2";

        annotation (
        preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models with four fluid ports
and two fluid streams.
It is similar to
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>,
but it has four ports instead of two.
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 22, 2023, by Michael Wetter:<br/>
Improved documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1796\">IBPSA, #1796</a>.
</li>
<li>
February 3, 2022, by Michael Wetter:<br/>
If <code>allowFlowReversal==false</code>, removed <code>noEvent()</code> declaration
for <code>sta_a</code> and for <code>sta_b</code> because the variable is either
already used with <code>inStream()</code> in the computation of <code>state_*_inflow</code>,
or the result of a variable of the model that already may generate an event.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1578\">IBPSA, #1578</a>.
</li>
<li>
February 2, 2022, by Hongxiang Fu:<br/>
If <code>allowFlowReversal==false</code>, replaced <code>actualStream()</code>
with <code>inStream()</code> for <code>sta_a</code> and
removed <code>actualStream()</code> for <code>sta_b</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1578\">IBPSA, #1578</a>.
</li>
<li>
March 30, 2021, by Michael Wetter:<br/>
Added annotation <code>HideResult=true</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1459\">IBPSA, #1459</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Removed assignment of <code>min</code> and <code>max</code>
attributes of port mass flow rates, as this is already
done in the base class.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a1</code>,
<code>sta_a2</code>, <code>sta_b1</code> and <code>sta_b2</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definitions of <code>dp1</code> and <code>dp2</code> because they cause some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Replaced the erroneous function call <code>Medium.density</code> with
<code>Medium1.density</code> and <code>Medium2.density</code>.
Changed condition to remove <code>sta_a1</code> and <code>sta_a2</code> to also
compute the states at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialFourPortInterface;

      partial model PartialTwoPort "Partial component with two ports"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a(
          redeclare final package Medium = Medium,
           m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector a (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(
          redeclare final package Medium = Medium,
          m_flow(max=if allowFlowReversal then +Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector b (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{110,-10},{90,10}})));

        annotation (
          Documentation(info="<html>
<p>
This partial model defines an interface for components with two ports.
The treatment of the design flow direction and of flow reversal are predefined based on the parameter <code>allowFlowReversal</code>.
The component may transport fluid and may have internal storage for a given fluid <code>Medium</code>.
</p>
<h4>Implementation</h4>
<p>
This model is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>
but it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>
and
<code>showDesignFlowDirection</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
November 13, 2015, by Michael Wetter:<br/>
Assinged <code>start</code> attribute for leaving
enthalpy at <code>port_a</code> and <code>port_b</code>.
This was done to make the model similar to
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialFourPort\">
Buildings.Fluid.Interfaces.PartialFourPort</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Removed import statement.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
Declared medium in ports to be <code>final</code>.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{20,-70},{60,-85},{20,-100},{20,-70}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal),
              Line(
                points={{55,-85},{-60,-85}},
                color={0,128,255},
                visible=not allowFlowReversal),
              Text(
                extent={{-149,-114},{151,-154}},
                textColor={0,0,255},
                textString="%name")}));
      end PartialTwoPort;

      partial model PartialTwoPortInterface
        "Partial model with two ports and declaration of quantities that are used by many models"
        extends Buildings.Fluid.Interfaces.PartialTwoPort(
          port_a(p(start=Medium.p_default)),
          port_b(p(start=Medium.p_default)));

        parameter Modelica.Units.SI.MassFlowRate m_flow_nominal
          "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
        parameter Modelica.Units.SI.MassFlowRate m_flow_small(min=0) = 1E-4*abs(
          m_flow_nominal) "Small mass flow rate for regularization of zero flow"
          annotation (Dialog(tab="Advanced"));
        // Diagnostics
         parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation (
            Dialog(tab="Advanced", group="Diagnostics"),
            HideResult=true);

        Modelica.Units.SI.MassFlowRate m_flow(start=_m_flow_start) = port_a.m_flow
          "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";

        Modelica.Units.SI.PressureDifference dp(
          start=_dp_start,
          displayUnit="Pa") = port_a.p - port_b.p
          "Pressure difference between port_a and port_b";

        Medium.ThermodynamicState sta_a=
          if allowFlowReversal then
            Medium.setState_phX(port_a.p,
                                noEvent(actualStream(port_a.h_outflow)),
                                noEvent(actualStream(port_a.Xi_outflow)))
          else
            Medium.setState_phX(port_a.p,
                                noEvent(inStream(port_a.h_outflow)),
                                noEvent(inStream(port_a.Xi_outflow)))
            if show_T "Medium properties in port_a";

        Medium.ThermodynamicState sta_b=
          if allowFlowReversal then
            Medium.setState_phX(port_b.p,
                                noEvent(actualStream(port_b.h_outflow)),
                                noEvent(actualStream(port_b.Xi_outflow)))
          else
            Medium.setState_phX(port_b.p,
                                noEvent(port_b.h_outflow),
                                noEvent(port_b.Xi_outflow))
             if show_T "Medium properties in port_b";

    protected
        final parameter Modelica.Units.SI.MassFlowRate _m_flow_start=0
          "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window";
        final parameter Modelica.Units.SI.PressureDifference _dp_start(displayUnit=
              "Pa") = 0
          "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window";

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models with two fluid ports.
It is similar to
<a href=\"Modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>, but it does not
include the species balance
</p>
<pre>
  port_b.Xi_outflow = inStream(port_a.Xi_outflow);
</pre>
<p>
Thus, it can be used as a base class for a heat <i>and</i> mass transfer component
</p>
<p>
The partial model extends
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPort\">
Buildings.Fluid.Interfaces.PartialTwoPort</a>
and adds quantities that are used by many models such as
<code>m_flow_nominal</code>, <code>m_flow</code> and <code>dp</code>.
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations. See for example
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 22, 2023, by Michael Wetter:<br/>
Improved documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1796\">IBPSA, #1796</a>.
</li>
<li>
February 2, 2022, by Hongxiang Fu:<br/>
If <code>allowFlowReversal==false</code>, replaced <code>actualStream()</code>
with <code>inStream()</code> for <code>sta_a</code> and
removed <code>actualStream()</code> for <code>sta_b</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1578\">IBPSA, #1578</a>.
</li>
<li>
March 30, 2021, by Michael Wetter:<br/>
Added annotation <code>HideResult=true</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1459\">IBPSA, #1459</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Renamed protected parameter <code>m_flow_start</code> to avoid
a name clash with
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_m_flow\">
Buildings.Fluid.Movers.FlowControlled_m_flow</a>
which leads to an error as the definition were different,
and also renamed protected parameter <code>dp_start</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>
<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a</code> and <code>sta_b</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definition of <code>dp</code> because it causes some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Changed condition to remove <code>sta_a</code> to also
compute the state at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
March 11, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortInterface;

      partial model PartialTwoPortTransport
        "Partial element transporting fluid between two ports without storage of mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPort;

        // Advanced
        // Note: value of dp_start shall be refined by derived model,
        // based on local dp_nominal
        parameter Modelica.Units.SI.PressureDifference dp_start(displayUnit="Pa") = 0
          "Guess value of dp = port_a.p - port_b.p"
          annotation (Dialog(tab="Advanced"));
        parameter Medium.MassFlowRate m_flow_start = 0
          "Guess value of m_flow = port_a.m_flow"
          annotation(Dialog(tab = "Advanced"));
        // Note: value of m_flow_small shall be refined by derived model,
        // based on local m_flow_nominal
        parameter Medium.MassFlowRate m_flow_small
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));

        // Diagnostics
        parameter Boolean show_T = true
          "= true, if temperatures at port_a and port_b are computed"
          annotation (
            Dialog(tab="Advanced", group="Diagnostics"),
            HideResult=true);
        parameter Boolean show_V_flow = true
          "= true, if volume flow rate at inflowing port is computed"
          annotation (
            Dialog(tab="Advanced", group="Diagnostics"),
            HideResult=true);

        // Variables
        Medium.MassFlowRate m_flow(
           min=if allowFlowReversal then -Modelica.Constants.inf else 0,
           start = m_flow_start) "Mass flow rate in design flow direction";
        Modelica.Units.SI.PressureDifference dp(start=dp_start, displayUnit="Pa")
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";

        Modelica.Units.SI.VolumeFlowRate V_flow=m_flow/
            Modelica.Fluid.Utilities.regStep(
            m_flow,
            Medium.density(Medium.setState_phX(
              p=port_a.p,
              h=inStream(port_a.h_outflow),
              X=inStream(port_a.Xi_outflow))),
            Medium.density(Medium.setState_phX(
              p=port_b.p,
              h=inStream(port_b.h_outflow),
              X=inStream(port_b.Xi_outflow))),
            m_flow_small) if show_V_flow
          "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";

        Medium.Temperature port_a_T=
            Modelica.Fluid.Utilities.regStep(port_a.m_flow,
                        Medium.temperature(
                          Medium.setState_phX(
                            p = port_a.p,
                            h = inStream(port_a.h_outflow),
                            X = inStream(port_a.Xi_outflow))),
                        Medium.temperature(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_a, if show_T = true";
        Medium.Temperature port_b_T=
            Modelica.Fluid.Utilities.regStep(port_b.m_flow,
                        Medium.temperature(
                          Medium.setState_phX(
                            p = port_b.p,
                            h = inStream(port_b.h_outflow),
                            X = inStream(port_b.Xi_outflow))),
                        Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_b, if show_T = true";
      equation
        // Pressure drop in design flow direction
        dp = port_a.p - port_b.p;

        // Design direction of mass flow rate
        m_flow = port_a.m_flow;
        assert(m_flow > -m_flow_small or allowFlowReversal,
            "Reverting flow occurs even though allowFlowReversal is false");

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without storing mass or energy.
Energy may be exchanged with the environment though, e.g., in the form of work.
<code>PartialTwoPortTransport</code> is intended as base class for devices like orifices, valves and simple fluid machines.</p>
<p>
Three equations need to be added by an extending class using this component:
</p>
<ul>
<li>The momentum balance specifying the relationship between the pressure drop <code>dp</code> and the mass flow rate <code>m_flow</code>,</li>
<li><code>port_b.h_outflow</code> for flow in design direction, and</li>
<li><code>port_a.h_outflow</code> for flow in reverse direction.</li>
</ul>
<p>
Moreover appropriate values shall be assigned to the following parameters:
</p>
<ul>
<li><code>dp_start</code> for a guess of the pressure drop</li>
<li><code>m_flow_small</code> for regularization of zero flow.</li>
</ul>
<h4>Implementation</h4>
<p>
This is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>
except that it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, and in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 30, 2021, by Michael Wetter:<br/>
Added annotation <code>HideResult=true</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1459\">IBPSA, #1459</a>.
</li>
<li>
September 15, 2016, by Michael Wetter:<br/>
Removed wrong annotation, which caused an error in the pedantic model check
of Dymola 2017 FD01.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/516\">#516</a>.
</li>
<li>
January 22, 2016, by Henning Francke:<br/>
Corrected type declaration of pressure.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignments of parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code> in base class.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/305\">#305</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed protected conditional variables <code>state_a</code> and <code>state_b</code>,
as they were used outside of a connect statement, which causes an
error during pedantic model check in Dymola 2016.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/128\">#128</a>.
</li>
<li>
April 1, 2015, by Michael Wetter:<br/>
Made computation of <code>state_a</code> and <code>state_p</code>
conditional on <code>show_T</code> or <code>show_V_flow</code>.
This avoids computing temperature from enthalpy if temperature is
a state of the medium, and the result is not used.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortTransport;

      model StaticFourPortHeatMassExchanger
        "Partial model transporting two fluid streams between four ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialFourPortInterface;
        extends Buildings.Fluid.Interfaces.FourPortFlowResistanceParameters(
         final computeFlowResistance1=(dp1_nominal > Modelica.Constants.eps),
         final computeFlowResistance2=(dp2_nominal > Modelica.Constants.eps));

        constant Boolean prescribedHeatFlowRate1 = false
          "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature";
        constant Boolean prescribedHeatFlowRate2 = false
          "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature";

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        // Q1_flow is sensible plus latent heat flow rate
        input Modelica.Units.SI.HeatFlowRate Q1_flow
          "Heat transferred into the medium 1";
        input Medium1.MassFlowRate mWat1_flow
          "Moisture mass flow rate added to the medium 1";
        // Q2_flow is sensible plus latent heat flow rate
        input Modelica.Units.SI.HeatFlowRate Q2_flow
          "Heat transferred into the medium 2";
        input Medium2.MassFlowRate mWat2_flow
          "Moisture mass flow rate added to the medium 2";
        constant Boolean sensibleOnly1
          "Set to true if sensible exchange only for medium 1";
        constant Boolean sensibleOnly2
          "Set to true if sensible exchange only for medium 2";

    protected
        Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal1(
          redeclare final package Medium=Medium1,
          final sensibleOnly = sensibleOnly1,
          final prescribedHeatFlowRate=prescribedHeatFlowRate1,
          final m_flow_nominal = m1_flow_nominal,
          final dp_nominal = dp1_nominal,
          final allowFlowReversal = allowFlowReversal1,
          final m_flow_small = m1_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp1,
          final linearizeFlowResistance = linearizeFlowResistance1,
          final deltaM = deltaM1,
          final Q_flow = Q1_flow,
          final mWat_flow = mWat1_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 1";
        Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal2(
          redeclare final package Medium=Medium2,
          final sensibleOnly = sensibleOnly2,
          final prescribedHeatFlowRate=prescribedHeatFlowRate2,
          final m_flow_nominal = m2_flow_nominal,
          final dp_nominal = dp2_nominal,
          final allowFlowReversal = allowFlowReversal2,
          final m_flow_small = m2_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp2,
          final linearizeFlowResistance = linearizeFlowResistance2,
          final deltaM = deltaM2,
          final Q_flow = Q2_flow,
          final mWat_flow = mWat2_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 2";

      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        connect(bal1.port_a, port_a1);
        connect(bal1.port_b, port_b1);
        connect(bal2.port_a, port_a2);
        connect(bal2.port_b, port_b2);
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports, without
storing mass or energy. It is similar to
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>,
but it has four ports instead of two.
</p>
<p>
If <code>dp<i>N</i>_nominal &gt; Modelica.Constants.eps</code>,
where <code><i>N</i></code> denotes the fluid <i>1</i> or <i>2</i>,
then the model computes
pressure drop due to flow friction in the respective fluid stream.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m<i>N</i>_flow_nominal, dp<i>N</i>_nominal)</code>.
At <code>|m<i>N</i>_flow| &lt; deltaM<i>N</i> * m<i>N</i>_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance<i>N</i></code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>

<h4>Implementation</h4>
<p>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned, where <code><i>N</i></code> denotes <code>1</code> or
<code>2</code>:</p>
<ul>
<li>
<code>Q<i>N</i>_flow</code>, which is the sensible and latent heat flow rate added to the medium <i>N</i>.
</li>
<li>
<code>mWat<i>N</i>_flow</code>, which is the moisture mass flow rate added to the medium <i>N</i>.
</li>
</ul>
<p>
Set the constant <code>sensibleOnly<i>N</i>=true</code> if the model that extends
or instantiates this model sets <code>mWat<i>N</i>_flow = 0</code>.
</p>
<p>
     Note that the model does not implement <code>0 = Q1_flow + Q2_flow</code> or
     <code>0 = mXi1_flow + mXi2_flow</code>. If there is no heat or mass transfer
     with the environment, then a model that extends this model needs to provide these
     equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q1_flow</code> and <code>Q2_flow</code>
include latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constants <code>sensibleOnly1</code> and
<code>sensibleOnly2</code> to
simplify species balance equations.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,65},{101,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end StaticFourPortHeatMassExchanger;

      model StaticTwoPortConservationEquation
        "Partial model for static energy and mass conservation equations"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface;

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

        constant Boolean prescribedHeatFlowRate = false
          "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s")
          if use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow
          if use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(final unit="J/kg")
          "Leaving specific enthalpy of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1,
                                                                nominal=0.01*ones(Medium.nXi))
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));

    protected
        final parameter Boolean use_m_flowInv=
          (prescribedHeatFlowRate or use_mWat_flow or use_C_flow)
          "Flag, true if m_flowInv is used in the model"
          annotation (Evaluate=true);
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";

        Real m_flowInv(unit="s/kg") "Regularization of 1/m_flow of port_a";

        Modelica.Units.SI.MassFlowRate mXi_flow[Medium.nXi]
          "Mass flow rates of independent substances added to the medium";

        // Parameters for inverseXRegularized.
        // These are assigned here for efficiency reason.
        // Otherwise, they would need to be computed each time
        // the function is invocated.
        final parameter Real deltaReg = m_flow_small/1E3
          "Smoothing region for inverseXRegularized";

        final parameter Real deltaInvReg = 1/deltaReg
          "Inverse value of delta for inverseXRegularized";

        final parameter Real aReg = -15*deltaInvReg
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real bReg = 119*deltaInvReg^2
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real cReg = -361*deltaInvReg^3
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real dReg = 534*deltaInvReg^4
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real eReg = -380*deltaInvReg^5
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real fReg = 104*deltaInvReg^6
          "Polynomial coefficient for inverseXRegularized";

        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.Units.SI.SpecificHeatCapacity cp_default=
            Medium.specificHeatCapacityCp(state=state_default)
          "Specific heat capacity, used to verify energy conservation";
        constant Modelica.Units.SI.TemperatureDifference dTMax(min=1) = 200
          "Maximum temperature difference across the StaticTwoPortConservationEquation";
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";
      initial equation
        // Assert that the substance with name 'water' has been found.
        if use_mWat_flow then
          assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");
        end if;
      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Species flow rate from connector mWat_flow
        mXi_flow = mWat_flow_internal * s;

        // Regularization of m_flow around the origin to avoid a division by zero
        // m_flowInv is only used if prescribedHeatFlowRate == true, or
        // if the input connectors mWat_flow or C_flow are enabled.
        if use_m_flowInv then
          m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(
                             x=port_a.m_flow,
                             delta=deltaReg, deltaInv=deltaInvReg,
                             a=aReg, b=bReg, c=cReg, d=dReg, e=eReg, f=fReg);
        else
          // m_flowInv is not used.
          m_flowInv = 0;
        end if;

        if prescribedHeatFlowRate then
          assert(noEvent( abs(Q_flow) < dTMax*cp_default*max(m_flow_small/1E3, abs(m_flow))),
         "In " + getInstanceName() + ":
   The heat flow rate equals "       + String(Q_flow) +
         " W and the mass flow rate equals " + String(m_flow) + " kg/s,
   which results in a temperature difference "       +
         String(abs(Q_flow)/ (cp_default*max(m_flow_small/1E3, abs(m_flow)))) +
         " K > dTMax=" +String(dTMax) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
        end if;

        if allowFlowReversal then
          // Formulate hOut using spliceFunction. This avoids an event iteration.
          // The introduced error is small because deltax=m_flow_small/1e3
          hOut = Buildings.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                          y2=port_a.h_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
          XiOut = Buildings.Utilities.Math.Functions.regStep(y1=port_b.Xi_outflow,
                                                           y2=port_a.Xi_outflow,
                                                           x=port_a.m_flow,
                                                           x_small=m_flow_small/1E3);
          COut = Buildings.Utilities.Math.Functions.regStep(y1=port_b.C_outflow,
                                                          y2=port_a.C_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
        else
          hOut =  port_b.h_outflow;
          XiOut = port_b.Xi_outflow;
          COut =  port_b.C_outflow;
        end if;

        //////////////////////////////////////////////////////////////////////////////////////////
        // Energy balance and mass balance

          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = if simplify_mWat_flow then 0 else -mWat_flow_internal;

          // Substance balance
          // a) forward flow
          if use_m_flowInv then
            port_b.Xi_outflow = inStream(port_a.Xi_outflow) + mXi_flow * m_flowInv;
          else // no water is added
            assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for forward flow.");
            port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          end if;

          // b) backward flow
          if allowFlowReversal then
            if use_m_flowInv then
              port_a.Xi_outflow = inStream(port_b.Xi_outflow) - mXi_flow * m_flowInv;
            else // no water added
              assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for reverse flow.");
              port_a.Xi_outflow = inStream(port_b.Xi_outflow);
            end if;
          else // no  flow reversal
            port_a.Xi_outflow = Medium.X_default[1:Medium.nXi];
          end if;

          // Energy balance.
          // This equation is approximate since m_flow = port_a.m_flow is used for the mass flow rate
          // at both ports. Since mWat_flow_internal << m_flow, the error is small.
          if prescribedHeatFlowRate then
            port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
            if allowFlowReversal then
              port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
            else
              port_a.h_outflow = Medium.h_default;
            end if;
          else
            // Case with prescribedHeatFlowRate == false.
            // port_b.h_outflow is known and the equation needs to be solved for Q_flow.
            // Hence, we cannot use m_flowInv as for m_flow=0, any Q_flow would satisfiy
            // Q_flow * m_flowInv = 0.
            // The same applies for port_b.Xi_outflow and mXi_flow.
            port_a.m_flow * (inStream(port_a.h_outflow) - port_b.h_outflow)     = -Q_flow;
            if allowFlowReversal then
              port_a.m_flow * (inStream(port_b.h_outflow)  - port_a.h_outflow)  = +Q_flow;
            else
              // When allowFlowReversal = false, the downstream enthalpy does not matter.
              // Therefore a dummy value is used to avoid algebraic loops
              port_a.h_outflow = Medium.h_default;
            end if;
          end if;

        // Transport of trace substances
        if use_m_flowInv and use_C_flow then
          port_b.C_outflow =  inStream(port_a.C_outflow) + C_flow_internal * m_flowInv;
        else // no trace substance added.
          assert(not use_C_flow, "In " + getInstanceName() + ": Wrong implementation of trace substance balance for forward flow.");
          port_b.C_outflow =  inStream(port_a.C_outflow);
        end if;

        if allowFlowReversal then
          if use_C_flow then
            port_a.C_outflow = inStream(port_b.C_outflow) - C_flow_internal * m_flowInv;
          else
            port_a.C_outflow = inStream(port_b.C_outflow);
          end if;
        else
          port_a.C_outflow = zeros(Medium.nC);
        end if;

        ////////////////////////////////////////////////////////////////////////////
        // No pressure drop in this model
        port_a.p = port_b.p;

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model transports fluid between its two ports, without storing mass or energy.
It implements a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>

<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
<h4>Implementation</h4>
<p>
Input connectors of the model are
</p>
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can only be used as a steady-state model with two fluid ports.
For a model with a dynamic balance, and more fluid ports, use
<a href=\"modelica://Buildings.Fluid.Interfaces.ConservationEquation\">
Buildings.Fluid.Interfaces.ConservationEquation</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
October 24, 2022, by Michael Wetter:<br/>
Conditionally removed assertion that checks for water content as this is
only required if water is added to the medium.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1650\">#1650</a>.
</li>
<li>
September 9, 2022, by Michael Wetter:<br/>
Set nominal attribute for <code>XiOut</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1634\">1634</a>.
</li>
<li>
September 18, 2020, by Michael Wetter:<br/>
Removed start value for <code>hOut</code> as it will be set by
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1397\">#1397</a>.
</li>
<li>
February 12, 2019, by Filip Jorissen:<br/>
Removed obsolete division by <code>TMax</code> in assert.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1097\">#1097</a>.
</li>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Added more details to energy conservation assert to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/962\">#962</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> in asserts to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/901\">#901</a>.
</li>
<li>
April 24, 2017, by Michael Wetter and Filip Jorissen:<br/>
Reimplemented check for energy conversion.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 24, 2017, by Michael Wetter:<br/>
Reverted change from April 21, 2017.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 21, 2017, by Filip Jorissen:<br/>
Revised test for energy conservation at small mass flow rates.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
October 23, 2016, by Filip Jorissen:<br/>
Added test for energy conservation at small mass flow rates.
</li>
<li>
March 17, 2016, by Michael Wetter:<br/>
Refactored model and implmented <code>regStep</code> instead of <code>spliceFunction</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>
and for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a>.
</li>
<li>
September 3, 2015, by Filip Jorissen:<br/>
Revised implementation of conservation of vapor mass.
Added new variable <code>mFlow_inv_b</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Removed <code>constant sensibleOnly</code> as this is no longer used because
the model uses <code>use_mWat_flow</code>.<br/>
Changed condition that determines whether <code>m_flowInv</code> needs to be
computed because the change from January 20 introduced an error in
<a href=\"modelica://Buildings.Fluid.MassExchangers.Examples.ConstantEffectiveness\">
Buildings.Fluid.MassExchangers.Examples.ConstantEffectiveness</a>.
</li>
<li>
January 20, 2016, by Filip Jorissen:<br/>
Removed if-else block in code for parameter <code>sensibleOnly</code>
since this is no longer needed to simplify the equations.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
September 14, 2015, by Filip Jorissen:<br/>
Rewrote some equations for better readability.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
Refactored implementation of
<a href=\"modelica://Buildings.Utilities.Math.Functions.inverseXRegularized\">
Buildings.Utilities.Math.Functions.inverseXRegularized</a>
to allow function to be inlined and to factor out the computation
of arguments that only depend on parameters.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Corrected bug for situation with latent heat exchange and flow reversal not
allowed.
The previous formulation was singular.
This caused some models to not translate.
The error was introduced in
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Revised implementation so that equations are always consistent
and do not lead to division by zero,
also when connecting a <code>prescribedHeatFlowRate</code>
to <code>MixingVolume</code> instances.
Renamed <code>use_safeDivision</code> into <code>prescribedHeatFlowRate</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>
for a discussion.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Corrected sign error in the equation that is used if <code>use_safeDivision=false</code>
and <code>sensibleOnly=true</code>.
This only affects internal numerical tests, but not any examples in the library
as the constant <code>use_safeDivision</code> is set to <code>true</code> by default.
</li>
<li>
September 25, 2013 by Michael Wetter:<br/>
Reformulated computation of outlet properties to avoid an event at zero mass flow rate.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.
</li>
<li>
May 7, 2013 by Michael Wetter:<br/>
Removed <code>for</code> loops for species balance and trace substance balance,
as they cause the error <code>Error: Operand port_a.Xi_outflow[1] to operator inStream is not a stream variable.</code>
in OpenModelica.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
June 22, 2012 by Michael Wetter:<br/>
Reformulated implementation with <code>m_flowInv</code> to use <code>port_a.m_flow * ...</code>
if <code>use_safeDivision=false</code>. This avoids a division by zero if
<code>port_a.m_flow=0</code>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-93,72},{-58,89}},
                textColor={0,0,127},
                textString="Q_flow"),
              Text(
                extent={{-93,37},{-58,54}},
                textColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-41,103},{-10,117}},
                textColor={0,0,127},
                textString="hOut"),
              Text(
                extent={{10,103},{41,117}},
                textColor={0,0,127},
                textString="XiOut"),
              Text(
                extent={{61,103},{92,117}},
                textColor={0,0,127},
                textString="COut"),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{6,14},{6,-37}},     color={255,255,255}),
              Line(points={{54,14},{6,14}},     color={255,255,255}),
              Line(points={{6,-37},{-42,-37}},  color={255,255,255})}));
      end StaticTwoPortConservationEquation;

      model StaticTwoPortHeatMassExchanger
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface;
        extends Buildings.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=(abs(dp_nominal) > Modelica.Constants.eps));

        constant Boolean sensibleOnly "Set to true if sensible exchange only";
        constant Boolean prescribedHeatFlowRate
          "Set to true if the heat flow rate is not a function of the component temperature";

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        // Model inputs
        // Q_flow is the sensible plus latent heat flow rate
        input Modelica.Units.SI.HeatFlowRate Q_flow
          "Heat transferred into the medium";
        input Modelica.Units.SI.MassFlowRate mWat_flow
          "Moisture mass flow rate added to the medium";

        // Models for conservation equations and pressure drop
        Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation vol(
          redeclare final package Medium = Medium,
          final use_mWat_flow = not sensibleOnly,
          final prescribedHeatFlowRate = prescribedHeatFlowRate,
          final m_flow_nominal = m_flow_nominal,
          final allowFlowReversal=allowFlowReversal,
          final m_flow_small=m_flow_small)
          "Control volume for steady-state energy and mass balance"
          annotation (Placement(transformation(extent={{15,-10}, {35,10}})));

        Buildings.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg")
          "Leaving temperature of the component";

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component";
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component";

    protected
        Modelica.Blocks.Sources.RealExpression heaInp(y=Q_flow)
          "Block to set heat input into volume"
          annotation (Placement(transformation(extent={{-20,40},{0,60}})));
        Modelica.Blocks.Sources.RealExpression
          masExc(final y=mWat_flow) "Block to set moisture exchange in volume"
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));

      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        connect(vol.hOut, hOut);
        connect(vol.XiOut, XiOut);
        connect(vol.COut, COut);
        connect(port_a,preDro. port_a) annotation (Line(
            points={{-100,0},{-50,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.port_a) annotation (Line(
            points={{-30,0},{15,0}},
            color={0,127,255}));

        connect(vol.port_b, port_b) annotation (Line(
            points={{35,0},{67,0},{100,5.55112e-16}},
            color={0,127,255}));

        connect(heaInp.y, vol.Q_flow) annotation (Line(
            points={{1,50},{6,50},{6,8},{13,8}},
            color={0,0,127}));
        connect(masExc.y, vol.mWat_flow) annotation (Line(
            points={{1,30},{4,30},{4,4},{13,4}},
            color={0,0,127}));
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without
storing mass or energy. It is based on
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a> but it does
use a different implementation for handling reverse flow because
in this component, mass flow rate can be added or removed from
the medium.
</p>
<p>
If <code>dp_nominal &gt; Modelica.Constants.eps</code>, this component computes
pressure drop due to flow friction.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m_flow_nominal, dp_nominal)</code>. At <code>|m_flow| &lt; deltaM * m_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance</code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>
<h4>Implementation</h4>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned:
<ul>
<li>
<code>Q_flow</code>, which is the sensible and latent heat flow rate added to the medium.
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium.
</li>
</ul>

<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q_flow</code>
includes latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015 by Filip Jorissen:<br/>
Renamed <code>use_safeDivision</code> into
<code>prescribedHeatFlowRate</code>.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to pressure drop calculation, as this model no longer has
that parameter.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
February 8, 2012 by Michael Wetter:<br/>
Changed model to use graphical modeling.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end StaticTwoPortHeatMassExchanger;

      model TwoPortHeatMassExchanger
        "Partial model transporting one fluid stream with storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
          port_a(h_outflow(start=h_outflow_start)),
          port_b(h_outflow(start=h_outflow_start)));
        extends Buildings.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=true);

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Modelica.Units.SI.Time tau=30
          "Time constant at nominal flow (if energyDynamics <> SteadyState)"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));

        // Dynamics
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start = Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
          final quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
          final quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));

        replaceable Buildings.Fluid.MixingVolumes.MixingVolume vol
        constrainedby
        Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          redeclare final package Medium = Medium,
          nPorts = 2,
          V=m_flow_nominal*tau/rho_default,
          final allowFlowReversal=allowFlowReversal,
          final mSenFac=1,
          final m_flow_nominal = m_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=energyDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start) "Volume for fluid stream"
           annotation (Placement(transformation(extent={{-9,0},{11,-20}})));

        Buildings.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

    protected
        parameter Medium.ThermodynamicState sta_default=Medium.setState_pTX(
            T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.Units.SI.Density rho_default=Medium.density(sta_default)
          "Density, used to compute fluid volume";
        parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start, p=p_start, X=X_start);
        parameter Modelica.Units.SI.SpecificEnthalpy h_outflow_start=
            Medium.specificEnthalpy(sta_start) "Start value for outflowing enthalpy";

      initial algorithm
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");

        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        connect(vol.ports[2], port_b) annotation (Line(
            points={{1,0},{100,0}},
            color={0,127,255}));
        connect(port_a, preDro.port_a) annotation (Line(
            points={{-100,0},{-90,0},{-90,0},{-80,0},{-80,0},{-60,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{1,0}},
            color={0,127,255}));
        annotation (
          Documentation(info="<html>
<p>
This component transports one fluid stream.
It provides the basic model for implementing dynamic and steady-state
models that exchange heat and water vapor with the fluid stream.
The model also computes the pressure drop due to the flow resistance.
By setting the parameter <code>dp_nominal=0</code>, the computation
of the pressure drop can be avoided.
The variable <code>vol.heatPort.T</code> always has the value of
the temperature of the medium that leaves the component.
For the actual temperatures at the port, the variables <code>sta_a.T</code>
and <code>sta_b.T</code> can be used. These two variables are provided by
the base class
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>.
</p>

For models that extend this model, see for example
<ul>
<li>
the ideal heater or cooler
<a href=\"modelica://Buildings.Fluid.HeatExchangers.HeaterCooler_u\">
Buildings.Fluid.HeatExchangers.HeaterCooler_u</a>, and
</li>
<li>
the ideal humidifier
<a href=\"modelica://Buildings.Fluid.Humidifiers.Humidifier_u\">
Buildings.Fluid.Humidifiers.Humidifier_u</a>.
</li>
</ul>

<h4>Implementation</h4>
<p>
The variable names follow the conventions used in
<a href=\"modelica://Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX\">
Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX
</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 3, 2022, by Michael Wetter:<br/>
Removed <code>massDynamics</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">issue 1542</a>.
</li>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>final quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Added missing propagation of <code>allowFlowReversal</code> to
instance <code>vol</code>.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">#412</a>.
</li>
<li>
May 1, 2015, by Marcus Fuchs:<br/>
Fixed links in documentation.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in pressure drop element to be final.
</li>
<li>
May 28, 2014, by Michael Wetter:<br/>
Removed <code>annotation(Evaluate=true)</code> for parameter <code>tau</code>.
This is needed to allow changing the time constant after translation.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
October 17, 2012, by Michael Wetter:<br/>
Fixed broken link in documentation.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Removed assignment of <code>m_flow_small</code> as it is no
longer used in the pressure drop model.
</li>
<li>
January 15, 2011, by Michael Wetter:<br/>
Fixed wrong class reference in information section.
</li>
<li>
September 13, 2011, by Michael Wetter:<br/>
Changed assignment of <code>vol(mass/energyDynamics=...)</code> as the
previous assignment caused a non-literal start value that was ignored.
</li>
<li>
July 29, 2011, by Michael Wetter:<br/>
Added start value for outflowing enthalpy.
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Changed parameterization of fluid volume so that steady-state balance is
used when <code>tau = 0</code>.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Removed temperature sensor and changed implementation of fluid volume
to allow use of this model for the steady-state and dynamic humidifier
<a href=\"modelica://Buildings.Fluid.MassExchangers.HumidifierPrescribed\">
Buildings.Fluid.MassExchangers.HumidifierPrescribed</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
January 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,60},{70,-60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-101,5},{100,-4}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,-4},{100,5}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid)}));
      end TwoPortHeatMassExchanger;

      record FourPortFlowResistanceParameters
        "Parameters for flow resistance for models with four ports"

        parameter Boolean computeFlowResistance1 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 1"));

        parameter Boolean from_dp1 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance1,
                      tab="Flow resistance", group="Medium 1"));
        parameter Modelica.Units.SI.PressureDifference dp1_nominal(min=0, displayUnit
            ="Pa") "Pressure difference"
          annotation (Dialog(group="Nominal condition"));
        parameter Boolean linearizeFlowResistance1 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance1,
                     tab="Flow resistance", group="Medium 1"));
        parameter Real deltaM1 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance1,
                            tab="Flow resistance", group="Medium 1"));
        parameter Boolean computeFlowResistance2 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 2"));

        parameter Boolean from_dp2 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance2,
                      tab="Flow resistance", group="Medium 2"));
        parameter Modelica.Units.SI.PressureDifference dp2_nominal(min=0, displayUnit
            ="Pa") "Pressure difference"
          annotation (Dialog(group="Nominal condition"));
        parameter Boolean linearizeFlowResistance2 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance2,
                     tab="Flow resistance", group="Medium 2"));
        parameter Real deltaM2 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance2,
                            tab="Flow resistance", group="Medium 2"));
      annotation (preferredView="info",
      Documentation(info="<html>
<p>
This class contains parameters that are used to
compute the pressure drop in components that have two fluid streams.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialFourPortInterface\">
PartialFourPortInterface</a>
already declares it.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FourPortFlowResistanceParameters;

      record TwoPortFlowResistanceParameters
        "Parameters for flow resistance for models with two ports"

        parameter Boolean computeFlowResistance = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance"));

        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance,
                      tab="Flow resistance"));
        parameter Modelica.Units.SI.PressureDifference dp_nominal(min=0, displayUnit=
              "Pa") "Pressure difference"
          annotation (Dialog(group="Nominal condition"));
        parameter Boolean linearizeFlowResistance = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance,
                     tab="Flow resistance"));
        parameter Real deltaM = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance, tab="Flow resistance"));

      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in models that have one fluid stream.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
PartialTwoPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortFlowResistanceParameters;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains basic classes that are used to build
component models that change the state of the
fluid. The classes are not directly usable, but can
be extended when building a new model.
</p>
</html>"));
    end Interfaces;

    package BaseClasses "Package with base classes for Buildings.Fluid"
      extends Modelica.Icons.BasesPackage;

      block ActuatorFilter
        "Filter used for actuators of valves, dampers and movers"
        import Modelica.Blocks.Types.Init;
        extends Modelica.Blocks.Interfaces.SISO;

        constant Integer n=2 "Order of filter";
        parameter Modelica.Units.SI.Frequency f(start=1) "Cut-off frequency";
        parameter Boolean normalized = true
          "= true, if amplitude at f_cut is 3 dB, otherwise unmodified filter";
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
          annotation (
            Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real x_start[n]=zeros(n) "Initial or guess values of states"
          annotation (Dialog(group="Initialization"));
        parameter Real y_start=0.0
          "Initial value of output (remaining states are in steady state)"
          annotation(Dialog(enable=initType == Init.InitialOutput, group=
                "Initialization"));

        parameter Real u_nominal = 1 "Magnitude of input";

        Real x[n](each final stateSelect=StateSelect.never) = u_nom*s
          "Transformed filter states";


    protected
        final parameter Real u_nom = if abs(u_nominal-1) < 1E-12 then 1-1E-12 else u_nominal
          "Magnitude of input (set to a value different from 1 to avoid elimination by symbolic processing)";

        parameter Real alpha=if normalized then sqrt(2^(1/n) - 1) else 1.0
          "Frequency correction factor for normalized filter";
        parameter Real w_u=2*Modelica.Constants.pi*f/alpha/u_nom;

        Real s[n](start=x_start/u_nom) "Filter states";

      initial equation
        if initType == Init.SteadyState then
          der(s) = zeros(n);
        elseif initType == Init.InitialState then
          s = x_start/u_nom;
        elseif initType == Init.InitialOutput then
          y = y_start;
          der(s[1:n - 1]) = zeros(n - 1);
        end if;

      equation
        der(s[1]) = (u - u_nom*s[1])*w_u;
        for i in 2:n loop
          der(s[i]) = (u_nom*s[i - 1] - u_nom*s[i])*w_u;
        end for;
        y =u_nom*s[n];

        annotation (
          defaultComponentName="act",
          Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
              Line(points={{-80.6897,77.6256},{-80.6897,-90.3744}},
                color={192,192,192}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{-79.7044,90.6305},{-87.7044,68.6305},{-71.7044,68.6305},{-79.7044,90.6305}}),
              Line(points={{-90.0,-80.0},{82.0,-80.0}},
                color={192,192,192}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
              Line(origin = {-17.976,-6.521},
                points = {{96.962,55.158},{16.42,50.489},{-18.988,18.583},{-32.024,-53.479},{-62.024,-73.479}},
                color = {0,0,127},
                smooth = Smooth.Bezier),
              Text(textColor={192,192,192},
                extent={{-70.0,48.0},{26.0,94.0}},
                textString="%n"),
              Text(extent={{8.0,-146.0},{8.0,-106.0}},
                textString="f=%f")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}})),
          Documentation(info="<html>
<p>
This block implements a filter that is used to approximate the actuators
of valves, dampers and fans.
</p>
<h4>Implementation</h4>
<p>
The implementation is based on
<a href=\"modelica://Modelica.Blocks.Continuous.CriticalDamping\">
Modelica.Blocks.Continuous.CriticalDamping</a>.
It differs from that model in that the internal state of the filter <code>s</code>
is transformed using <code>x = u_nominal*s</code>.
It turns out that this transformation leads to smaller system of nonlinear equations if <code>u_nominal &ne; 0</code>, see
<a href=\"https://https://github.com/ibpsa/modelica-ibpsa/issues/1498#issuecomment-885020611\">IBPSA, #1498</a>
for a discussion.
</html>",       revisions="<html>
<ul>
<li>
July 22, 2021, by Michael Wetter:<br/>
First implementation for
<a href=\"https://https://github.com/ibpsa/modelica-ibpsa/issues/1498\">IBPSA, #1498</a>
</li>
</ul>
</html>"));
      end ActuatorFilter;

      partial model PartialResistance "Partial model for a hydraulic resistance"
          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
           show_T=false,
           dp(nominal=if dp_nominal_pos > Modelica.Constants.eps
                then dp_nominal_pos else 1),
           m_flow(
              nominal=if m_flow_nominal_pos > Modelica.Constants.eps
                then m_flow_nominal_pos else 1),
           final m_flow_small = 1E-4*abs(m_flow_nominal));

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.Units.SI.PressureDifference dp_nominal(displayUnit="Pa")
          "Pressure drop at nominal mass flow rate"
          annotation (Dialog(group="Nominal condition"));

        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
          "Turbulent flow if |m_flow| >= m_flow_turbulent";

    protected
        parameter Medium.ThermodynamicState sta_default=
           Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.Units.SI.DynamicViscosity eta_default=
            Medium.dynamicViscosity(sta_default)
          "Dynamic viscosity, used to compute transition to turbulent flow regime";

        final parameter Modelica.Units.SI.MassFlowRate m_flow_nominal_pos=abs(
            m_flow_nominal) "Absolute value of nominal flow rate";
        final parameter Modelica.Units.SI.PressureDifference dp_nominal_pos(
            displayUnit="Pa") = abs(dp_nominal)
          "Absolute value of nominal pressure difference";
      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,22},{100,-24}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Rectangle(
                visible=linearized,
                extent={{-100,22},{100,-22}},
                fillPattern=FillPattern.Backward,
                fillColor={0,128,255},
                pattern=LinePattern.None,
                lineColor={255,255,255}),
              Rectangle(
                extent=DynamicSelect({{-100,10},{-100,10}}, {{100,10},{100+200*max(-1, min(0, m_flow/(abs(m_flow_nominal)))),-10}}),
                lineColor={28,108,200},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{-100,10},{-100,10}}, {{-100,10},{-100+200*min(1, max(0, m_flow/abs(m_flow_nominal))),-10}}),
                lineColor={28,108,200},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None)}),
                defaultComponentName="res",
      Documentation(info="<html>
<p>
Partial model for a flow resistance, possible with variable flow coefficient.
Models that extend this class need to implement an equation that relates
<code>m_flow</code> and <code>dp</code>, and they need to assign the parameter
<code>m_flow_turbulent</code>.
</p>
<p>
See for example
<a href=\"modelica://Buildings.Fluid.FixedResistances.PressureDrop\">
Buildings.Fluid.FixedResistances.PressureDrop</a> for a model that extends
this base class.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
February 26, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start value for pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Avoided assignment of <code>dp(nominal=0)</code> if <code>dp_nominal_pos = 0</code>
and of <code>m_flow(nominal=0)</code> if <code>m_flow_nominal_pos = 0</code>
as nominal values are not allowed to be zero.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
January 13, 2015, by Marcus Fuchs:<br/>
Revised revisions section (there were two revisions statements)
</li>
<li>
November 20, 2014 by Michael Wetter:<br/>
Removed <code>start</code> attribute for <code>m_flow</code>
as this is already set in its base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to base class as it has no longer this parameter.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
February 12, 2012, by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Made assignment of <code>m_flow_small</code> <code>final</code> as it is no
longer used in the base class.
</li>
<li>
January 16, 2012, by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 5, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
June 20, 2011, by Michael Wetter:<br/>
Set start values for <code>m_flow</code> and <code>dp</code> to zero, since
most HVAC systems start at zero flow. With this change, the start values
appear in the GUI and can be set by the user.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>m_flow_nominal_pos</code> and <code>dp_nominal_pos</code> to allow
providing negative nominal values which will be used, for example, to set start
values of flow splitters which may have negative flow rates and pressure drop
at the initial condition.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23, 2011 by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 30, 2010 by Michael Wetter:<br/>
Changed base classes to allow easier initialization.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Extracted pressure drop computation and implemented it in the
new model
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>.
</li>
<li>
September 18, 2008, by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialResistance;

      partial model PartialThreeWayResistance
        "Flow splitter with partial resistance model at each port"
        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations(
          final massDynamics=energyDynamics,
          final mSenFac=1);

        Modelica.Fluid.Interfaces.FluidPort_a port_1(
          redeclare package Medium = Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_1== Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "First port, typically inlet"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_2(
          redeclare package Medium = Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "Second port, typically outlet"
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        Modelica.Fluid.Interfaces.FluidPort_a port_3(
          redeclare package Medium=Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "Third port, can be either inlet or outlet"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));

        parameter Modelica.Units.SI.Time tau=10
          "Time constant at nominal flow for dynamic energy and momentum balance"
          annotation (Dialog(
            tab="Dynamics",
            group="Nominal condition",
            enable=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));
        parameter Modelica.Units.SI.MassFlowRate mDyn_flow_nominal
          "Nominal mass flow rate for dynamic momentum and energy balance"
          annotation (Dialog(tab="Dynamics", group="Conservation equations",
            enable=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));

        parameter Boolean from_dp = true
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_1"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_2"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_3"
         annotation(Dialog(tab="Advanced"));
        parameter Boolean verifyFlowReversal = false
          "=true, to assert that the flow does not reverse when portFlowDirection_* does not equal Bidirectional"
          annotation(Dialog(tab="Advanced"));
        parameter Modelica.Units.SI.MassFlowRate m_flow_small
          "Small mass flow rate for checking flow reversal"
          annotation (Dialog(tab="Advanced", enable=verifyFlowReversal));


        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res1
          constrainedby Buildings.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res2
          constrainedby Buildings.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{60,-10},{40,10}})));
        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res3
          constrainedby Buildings.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_3 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(
              origin={0,-50},
              extent={{-10,10},{10,-10}},
              rotation=90)));

        Buildings.Fluid.Delays.DelayFirstOrder vol(
          redeclare final package Medium = Medium,
          final nPorts=3,
          final tau=tau,
          final m_flow_nominal=mDyn_flow_nominal,
          final energyDynamics=energyDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final allowFlowReversal=true,
          final prescribedHeatFlowRate=false)
          if have_controlVolume "Fluid volume to break algebraic loop"
          annotation (Placement(transformation(extent={{-10,0},{10,20}})));

    protected
        parameter Boolean have_controlVolume=
            energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState
          "Boolean flag used to remove conditional components";

        Modelica.Fluid.Interfaces.FluidPort_a port_internal(
          redeclare package Medium = Medium) if not have_controlVolume
          "Internal dummy port for easier connection of conditional connections"
          annotation (Placement(transformation(extent={{-10,50},{10,70}})));
      initial equation
        assert(portFlowDirection_1<>Modelica.Fluid.Types.PortFlowDirection.Leaving or
               portFlowDirection_2<>Modelica.Fluid.Types.PortFlowDirection.Leaving or
               portFlowDirection_3<>Modelica.Fluid.Types.PortFlowDirection.Leaving,
               "In " + getInstanceName() + ": All ports are configured to
         Modelica.Fluid.Types.PortFlowDirection.Leaving, which is non-physical.");
        assert(portFlowDirection_1<>Modelica.Fluid.Types.PortFlowDirection.Entering or
               portFlowDirection_2<>Modelica.Fluid.Types.PortFlowDirection.Entering or
               portFlowDirection_3<>Modelica.Fluid.Types.PortFlowDirection.Entering,
               "In " + getInstanceName() + ": All ports are configured to
         Modelica.Fluid.Types.PortFlowDirection.Entering, which is non-physical.");

      equation
        if verifyFlowReversal then
          if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_1.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_1 despite portFlowDirection_1=PortFlowDirection.Entering, since m_flow="       +
            String(port_1.m_flow) + "<-"+String(m_flow_small));
          end if;
          if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_1.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_1 despite portFlowDirection_1=PortFlowDirection.Leaving, since m_flow="       +
            String(port_1.m_flow) + ">"+String(m_flow_small));
          end if;
          if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_2.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_2 despite portFlowDirection_2=PortFlowDirection.Entering, since m_flow="       +
            String(port_2.m_flow) + "<-"+String(m_flow_small));
          end if;
          if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_2.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_2 despite portFlowDirection_2=PortFlowDirection.Leaving, since m_flow="       +
            String(port_2.m_flow) + ">"+String(m_flow_small));
          end if;
          if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_3.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_3 despite portFlowDirection_3=PortFlowDirection.Entering, since m_flow="       +
            String(port_3.m_flow) + "<-"+String(m_flow_small));
          end if;
          if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_3.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_3 despite portFlowDirection_3=PortFlowDirection.Leaving, since m_flow="       +
            String(port_3.m_flow) + ">"+String(m_flow_small));
          end if;
        end if;

        if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res1.port_a, port_internal) annotation (Line(
            points={{-60,0},{-60,60},{0,60}},
            color={0,127,255}));
          else
             connect(res1.port_a, vol.ports[1]) annotation (Line(
            points={{-60,0},{-2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_1, res1.port_b) annotation (Line(points={{-100,0},{-100,0},{-40,
                  0}}, color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res1.port_b, port_internal) annotation (Line(
            points={{-40,0},{-40,60},{0,60}},
            color={0,127,255}));
          else
             connect(res1.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{-2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_1, res1.port_a) annotation (Line(points={{-100,0},{-100,0},{-60,0}}, color={0,127,255}));
        end if;

        if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res2.port_a, port_internal) annotation (Line(
            points={{60,0},{60,60},{0,60}},
            color={0,127,255}));
          else
             connect(res2.port_a, vol.ports[2]) annotation (Line(
            points={{60,0},{2.22045e-16,0}},
            color={0,127,255}));
          end if;
          connect(port_2, res2.port_b) annotation (Line(points={{100,0},{100,0},{40,0}},    color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res2.port_b, port_internal) annotation (Line(
            points={{40,0},{40,60},{0,60}},
            color={0,127,255}));
          else
             connect(res2.port_b, vol.ports[2]) annotation (Line(
            points={{40,0},{2.22045e-16,0}},
            color={0,127,255}));
          end if;
          connect(port_2, res2.port_a) annotation (Line(points={{100,0},{100,0},{60,0}},    color={0,127,255}));
        end if;

        if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res3.port_a, port_internal) annotation (Line(
            points={{-4.44089e-16,-60},{20,-60},{20,60},{0,60}},
            color={0,127,255}));
          else
             connect(res3.port_a, vol.ports[3]) annotation (Line(
            points={{-6.66134e-16,-60},{0,-60},{0,0},{2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_3, res3.port_b) annotation (Line(points={{0,-100},{0,-100},{0,-40}}, color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res3.port_b, port_internal) annotation (Line(
            points={{4.44089e-16,-40},{20,-40},{20,60},{0,60}},
            color={0,127,255}));
          else
             connect(res3.port_b, vol.ports[3]) annotation (Line(
            points={{4.44089e-16,-40},{0,-40},{0,0},{2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_3, res3.port_a) annotation (Line(points={{0,-100},{0,-100},{0,-60}}, color={0,127,255}));
        end if;
         annotation (
          Documentation(info="<html>
<p>
Partial model for flow resistances with three ports such as a
flow mixer/splitter or a three way valve.
</p>
<p>
If <code>energyDynamics &ne; Modelica.Fluid.Types.Dynamics.SteadyState</code>,
then at the junction of the three flows,
a mixing volume will be present. This will introduce a dynamic energy and momentum
balance, which often breaks algebraic loops.
The time constant of the mixing volume is determined by the parameter <code>tau</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 7, 2022, by Michael Wetter:<br/>
Set <code>final massDynamics=energyDynamics</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">#1542</a>.
</li>
<li>
March 22, 2020, by Filip Jorissen:<br/>
Corrected error message of asserts that verify whether flow reversal occurs when
<code>verifyFlowReversal=true</code> and <code>portFlowDirection&lt;&gt;Bidirectional</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1327\">#1327</a>.
</li>
<li>
July 7, 2018, by Filip Jorissen:<br/>
Added asserts that verify whether flow reversal occurs when
<code>verifyFlowReversal=true</code> and <code>portFlowDirection&lt;&gt;Bidirectional</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/963\">#963</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added graphical illustrations for the values of <code>portFlowDirection</code>.
Added asserts that verify the consistency of
the values of <code>portFlowDirection</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/902\">#902</a>.
</li>
<li>
February 22, 2016, by Michael Wetter:<br/>
Conditionally removed control volume <code>vol</code>, and added the conditional connnector
<code>port_internal</code>.
This was already done when the parameter <code>dynamicBalance</code> was present, but
was updated wrong when this parameter was removed.
Without these conditional components, the regression test for
<code>Buildings.Fluid.Examples.ResistanceVolumeFlowReversal</code> fails to simulate.
</li>
<li>
December 17, 2015, by Michael Wetter:<br/>
Added assignment <code>redeclare final package Medium=Medium</code>
as this is required for OpenModelica.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/475\">
https://github.com/lbl-srg/modelica-buildings/issues/475</a>.
</li>
<li>
February 20, 2016, by Ruben Baetens:<br/>
Removal of <code>dynamicBalance</code> as parameter for <code>massDynamics</code> and <code>energyDynamics</code>.
</li>
<li>
April 13 2015, by Filip Jorissen:<br/>
Exposed options for flow reversal to users and added corresponding implementation.
</li>
<li>
March 23 2010, by Michael Wetter:<br/>
Changed start values from <code>system.p_start</code> or (code <code>T_start</code>)
to <code>Medium.p_default</code>.
</li>
<li>
September 18, 2008 by Michael Wetter:<br/>
Replaced splitter model with a fluid port since the
splitter model in Modelica.Fluid 1.0 beta does not transport
<code>mC_flow</code>.
</li>
<li>
June 11, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Polygon(
                points={{104,28},{124,20},{104,12},{104,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving),
              Polygon(
                points={{124,28},{104,20},{124,12},{124,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Entering),
              Polygon(
                points={{-124,28},{-104,20},{-124,12},{-124,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Entering),
              Polygon(
                points={{-104,28},{-124,20},{-104,12},{-104,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving),
              Polygon(
                points={{1,8},{21,6.12323e-17},{1,-8},{1,8}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering,
                origin={20,-125},
                rotation=90),
              Polygon(
                points={{21,14},{1,6},{21,-2},{21,14}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving,
                origin={26,-125},
                rotation=90)}));
      end PartialThreeWayResistance;

      package FlowModels "Flow models for pressure drop calculations"
        extends Modelica.Icons.BasesPackage;

        function basicFlowFunction_dp
          "Function that computes mass flow rate for given pressure drop"

          input Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.Units.SI.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
      protected
          Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
           m_flow := smooth(2, if noEvent(abs(dp)>dp_turbulent)
                       then sign(dp)*k*sqrt(abs(dp))
                       else (1.40625  + (0.15625*dpNormSq - 0.5625)*dpNormSq)*m_flow_turbulent*dpNorm);
          annotation(Inline=false,
                   smoothOrder=2,
                   derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der,
                   inverse(dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                     m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent)),
                   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  textColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m&#775; = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m&#775; &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 9, 2019, by Filip Jorissen:<br/>
Added <code>smooth(2, . )</code> for avoiding
a warning in the check valve model.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1240\">#1240</a>.
</li>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
March 19, 2016, by Michael Wetter:<br/>
Added <code>abs</code> function for
<code>Buildings.Fluid.FixedResistances.Validation.PressureDropsExplicit</code>
to work in OpenModelica.
See <a href=\"https://trac.openmodelica.org/OpenModelica/ticket/3778\">
OpenModelica ticket 3778</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
January 9, 2014, by Michael Wetter:<br/>
Correct revision section, of which there were two.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>m_flow=0</code> if <code>dp=0</code>,
as this causes the derivative to be discontinuous at <code>dp=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2010 by Michael Wetter:<br/>
Changed implementation to allow <code>k=0</code>, which is
the case for a closed valve with no leakage
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_dp;

        function basicFlowFunction_dp_der
          "1st derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
      protected
          Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNormSq=(dp/dp_turbulent)^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der := (if noEvent(abs(dp)>dp_turbulent)
                        then 0.5*k/sqrt(abs(dp))
                        else (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*m_flow_turbulent/dp_turbulent)*dp_der;
         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
April 14, 2017, by Filip Jorissen:<br/>
Changed implementation such that it cannot lead to square roots
of negative numbers and reduced the number of required operations.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/723\">#723</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der;

        function basicFlowFunction_dp_der2
          "2nd derivative of flow function2nd derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "1st derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der2
            "2nd derivative of mass flow rate in design flow direction";
      protected
          Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der2 := if noEvent(abs(dp)>dp_turbulent)
                         then 0.5*k/sqrt(abs(dp))*(-0.5/dp * dp_der^2 + dp_der2)
                         else m_flow_turbulent/dp_turbulent*(
                               (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*dp_der2
                             + (-3.375 + 3.125*dpNormSq)*dpNorm/dp_turbulent*dp_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der2;

        function basicFlowFunction_m_flow
          "Function that computes pressure drop for given mass flow rate"

          input Modelica.Units.SI.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";

        algorithm
         dp := smooth(2, if noEvent(abs(m_flow)>m_flow_turbulent)
              then sign(m_flow)*(m_flow/k)^2
              else (0.375 + (0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm);

         annotation (Inline=false,
                     smoothOrder=2,
                     derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der,
                     inverse(m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                       dp=dp, k=k, m_flow_turbulent=m_flow_turbulent)),
                     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  textColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = sign(m&#775;) (m&#775; &frasl; k)<sup>2</sup>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m&#775; &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 9, 2019, by Michael Wetter:<br/>
Added <code>smooth(2, . )</code>, similar to
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1240\">#1240</a>.
</li>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>dp=0</code> if <code>m_flow=0</code>,
as this causes the derivative to be discontinuous at <code>m_flow=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow;

        function basicFlowFunction_m_flow_der
          "1st derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.Units.SI.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
          output Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNormSq = (m_flow/m_flow_turbulent)^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der :=(if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2*m_flow/k^2
                   else (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent/m_flow_turbulent)*m_flow_der;

         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der;

        function basicFlowFunction_m_flow_der2
          "2nd derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.Units.SI.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "1st derivative of mass flow rate in design flow direction";
          input Real m_flow_der2(unit="kg/s3")
            "2nd derivative of mass flow rate in design flow direction";
          output Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der2 :=if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2/k^2 * (m_flow_der^2 + m_flow * m_flow_der2)
                   else dp_turbulent/m_flow_turbulent*(
                         (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*m_flow_der2
                       + (4.5 - 2.5*m_flowNormSq)*m_flowNorm/m_flow_turbulent*m_flow_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der2;
      annotation (Documentation(info="<html>
<p>
This package contains a basic flow model that is used by the
various models that compute pressure drop.
</p>
<h4>Assumption and limitations</h4>
<p>
Because the density does not change signficantly in heating,
ventilation and air conditioning systems for buildings,
the flow models compute the pressure drop based on the mass flow
rate and not the volume flow rate. This typically leads to simpler
equations because it does not require
the mass density, which changes when the flow is reversed.
Although, for conceptual design of building energy system, there is
in general not enough information available that would warrant a more
detailed pressure drop calculation.
If a more detailed computation of the flow resistance is needed,
then a user can use models from the
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a> library.
</p>
<p>
All functions have an argument <code>m_flow_turbulent</code> that determines where the
flow transitions to fully turbulent flow. For smaller mass flow rates,
the quadratic relation is replaced by a function that has finite slope
near zero pressure drop. This is done for numerical reasons, and to approximate
laminar flow, although the implementation does not use a linear function.
</p>
<h4>Implementation</h4>
<p>
The two main functions are
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
and
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
that compute the mass flow rate or the pressure drop, respectively.
Both functions are two times continuously differentiable.
First and second order derivatives are provided
in the function that have the suffix <code>_der</code> and <code>_der2</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 10, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FlowModels;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid\">Buildings.Fluid</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains components for fluid flow systems such as
pumps, valves and sensors. For other fluid flow models, see
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>.
</html>"),
  Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}},
              lineColor={0,0,0}),
          Line(points={{2,42},{2,-10}}, color={0,0,0}),
          Rectangle(
            extent={{-18,50},{22,42}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
  end Fluid;

  package HeatTransfer "Package with heat transfer models"
    extends Modelica.Icons.Package;

    package Sources "Thermal sources"
    extends Modelica.Icons.SourcesPackage;

      model PrescribedHeatFlow "Prescribed heat flow boundary condition"
        Modelica.Blocks.Interfaces.RealInput Q_flow
              annotation (Placement(transformation(
              origin={-100,0},
              extent={{20,-20},{-20,20}},
              rotation=180)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                  -10},{110,10}})));
      equation
        port.Q_flow = -Q_flow;
        annotation (
          defaultComponentName="preHeaFlo",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Line(
                points={{-60,-20},{40,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-60,20},{40,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{40,0},{40,40},{70,20},{40,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{40,-40},{40,0},{70,-20},{40,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{70,40},{90,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,100},{150,60}},
                textString="%name",
                textColor={0,0,255})}),
          Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
This model is identical to
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>, except that
the parameters <code>alpha</code> and <code>T_ref</code> have
been deleted as these can cause division by zero in some fluid flow models.
</p>
</html>",    revisions="<html>
<ul>
<li>
March 29 2011, by Michael Wetter:<br/>
First implementation based on <a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>.
</li>
</ul>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{-60,-20},{68,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-60,20},{68,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{60,0},{60,40},{90,20},{60,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{60,-40},{60,0},{90,-20},{60,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}));
      end PrescribedHeatFlow;

      model PrescribedTemperature "Variable temperature boundary condition in Kelvin"

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                  -10},{110,10}})));
        Modelica.Blocks.Interfaces.RealInput T annotation (Placement(transformation(
                extent={{-140,-20},{-100,20}})));
      equation
        port.T = T;
        annotation (
          defaultComponentName="preTem",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={159,159,223},
                fillPattern=FillPattern.Backward),
              Line(
                points={{-102,0},{64,0}},
                color={191,0,0},
                thickness=0.5),
              Text(
                extent={{0,0},{-100,-100}},
                textColor={0,0,0},
                textString="K"),
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                textColor={0,0,255}),
              Polygon(
                points={{50,-20},{50,20},{90,0},{50,-20}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
This model represents a variable temperature boundary condition.
The temperature in [K] is given as input signal <b>T</b>
to the model. The effect is that an instance of this model acts as
an infinite reservoir able to absorb or generate as much energy
as required to keep the temperature at the specified value.
</p>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={159,159,223},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{0,0},{-100,-100}},
                textColor={0,0,0},
                textString="K"),
              Line(
                points={{-102,0},{64,0}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{52,-20},{52,20},{90,0},{52,-20}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}));
      end PrescribedTemperature;
      annotation (   Documentation(info="<html>
This package is identical to
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources\">
Modelica.Thermal.HeatTransfer.Sources</a>, except that
the parameters <code>alpha</code> and <code>T_ref</code> have
been deleted in the models
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow</a> and
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>
 as these can cause division by zero in some fluid flow models.
</html>"));
    end Sources;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models for heat transfer elements.
</p>
</html>"),
  Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}),
  graphics={
        Polygon(
          origin = {13.758,27.517},
          lineColor = {128,128,128},
          fillColor = {192,192,192},
          fillPattern = FillPattern.Solid,
          points = {{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,-49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},{-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}}),
      Polygon(
          origin = {13.758,27.517},
          fillColor = {160,160,164},
          fillPattern = FillPattern.Solid,
          points = {{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{-57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},{-75,-15},{-75,-15}}),
        Polygon(
          origin = {13.758,27.517},
          lineColor = {160,160,164},
          fillColor = {192,192,192},
          fillPattern = FillPattern.Solid,
          points = {{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},{29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{51,-13},{46,-7},{39,-5},{39,-6}}),
        Polygon(
          origin = {13.758,27.517},
          fillColor = {160,160,164},
          fillPattern = FillPattern.Solid,
          points = {{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},{46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{18,-15}}),
        Polygon(
          origin = {13.758,27.517},
          lineColor = {191,0,0},
          fillColor = {191,0,0},
          fillPattern = FillPattern.Solid,
          points = {{-9,-23},{-9,-10},{18,-17},{-9,-23}}),
        Line(
          origin = {13.758,27.517},
          points = {{-41,-17},{-9,-17}},
          color = {191,0,0},
          thickness = 0.5),
        Line(
          origin = {13.758,27.517},
          points = {{-17,-40},{15,-40}},
          color = {191,0,0},
          thickness = 0.5),
        Polygon(
          origin = {13.758,27.517},
          lineColor = {191,0,0},
          fillColor = {191,0,0},
          fillPattern = FillPattern.Solid,
          points = {{-17,-46},{-17,-34},{-40,-40},{-17,-46}})}));
  end HeatTransfer;

  package Media "Package with medium models"
    extends Modelica.Icons.Package;

    package Air
      "Package with moist air model that decouples pressure and temperature"
      extends Modelica.Media.Interfaces.PartialCondensingGases(
         mediumName="Air",
         final substanceNames={"water", "air"},
         final reducedX=true,
         final singleState = false,
         reference_X={0.01,0.99},
         final fluidConstants = {Modelica.Media.IdealGases.Common.FluidData.H2O,
                                 Modelica.Media.IdealGases.Common.FluidData.N2},
         reference_T=273.15,
         reference_p=101325,
         AbsolutePressure(start=p_default),
         Temperature(start=T_default));
      extends Modelica.Icons.Package;

      constant Integer Water=1
        "Index of water (in substanceNames, massFractions X, etc.)";
      constant Integer Air=2
        "Index of air (in substanceNames, massFractions X, etc.)";

      // In the assignments below, we compute cv as OpenModelica
      // cannot evaluate cv=cp-R as defined in GasProperties.
      constant GasProperties dryair(
        R=Modelica.Media.IdealGases.Common.SingleGasesData.Air.R_s,
        MM=Modelica.Media.IdealGases.Common.SingleGasesData.Air.MM,
        cp=Buildings.Utilities.Psychrometrics.Constants.cpAir,
        cv=Buildings.Utilities.Psychrometrics.Constants.cpAir - Modelica.Media.IdealGases.Common.SingleGasesData.Air.R_s)
        "Dry air properties";
      constant GasProperties steam(
        R=Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R_s,
        MM=Modelica.Media.IdealGases.Common.SingleGasesData.H2O.MM,
        cp=Buildings.Utilities.Psychrometrics.Constants.cpSte,
        cv=Buildings.Utilities.Psychrometrics.Constants.cpSte - Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R_s)
        "Steam properties";

      constant Real k_mair =  steam.MM/dryair.MM "Ratio of molar weights";

      constant Modelica.Units.SI.MolarMass[2] MMX={steam.MM,dryair.MM}
        "Molar masses of components";

      constant AbsolutePressure pStp = reference_p
        "Pressure for which fluid density is defined";
      constant Density dStp = 1.2 "Fluid density at pressure pStp";

      // Redeclare ThermodynamicState to avoid the warning
      // "Base class ThermodynamicState is replaceable"
      // during model check
      redeclare record extends ThermodynamicState
        "ThermodynamicState record for moist air"
      end ThermodynamicState;
      // There must not be any stateSelect=StateSelect.prefer for
      // the pressure.
      // Otherwise, translateModel("Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ResistanceVolume")
      // will fail as Dymola does an index reduction and outputs
      //   Differentiated the equation
      //   vol.dynBal.medium.p+res.dp-inlet.p = 0.0;
      //   giving
      //   der(vol.dynBal.medium.p)+der(res.dp) = der(inlet.p);
      //
      //   The model requires derivatives of some inputs as listed below:
      //   1 inlet.m_flow
      //   1 inlet.p
      // Therefore, the statement
      //   p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
      // has been removed.
      redeclare replaceable model BaseProperties "Base properties (p, d, T, h, u, R, MM and X and Xi) of a medium"

      parameter Boolean preferredMediumStates=false
        "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
        annotation (Evaluate=true, Dialog(tab="Advanced"));
      final parameter Boolean standardOrderComponents=true
        "If true, and reducedX = true, the last element of X will be computed from the other ones";

      InputAbsolutePressure p "Absolute pressure of medium";
      InputMassFraction[1] Xi(
        start=reference_X[1:1],
        nominal={0.01},
        each stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
        "Structurally independent mass fractions";
      InputSpecificEnthalpy h "Specific enthalpy of medium";
      Modelica.Media.Interfaces.Types.Density d "Density of medium";
      Modelica.Media.Interfaces.Types.Temperature T(
       stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
       "Temperature of medium";
      Modelica.Media.Interfaces.Types.MassFraction[2] X(start=reference_X)
        "Mass fractions (= (component mass)/total mass  m_i/m)";
      Modelica.Media.Interfaces.Types.SpecificInternalEnergy u
        "Specific internal energy of medium";
      Modelica.Media.Interfaces.Types.SpecificHeatCapacity R_s
        "Gas constant (of mixture if applicable)";
      Modelica.Media.Interfaces.Types.MolarMass MM
        "Molar mass (of mixture or single fluid)";
      ThermodynamicState state
        "Thermodynamic state record for optional functions";

        Modelica.Units.NonSI.Temperature_degC T_degC=
            Modelica.Units.Conversions.to_degC(T) "Temperature of medium in [degC]";
        Modelica.Units.NonSI.Pressure_bar p_bar=Modelica.Units.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

      // Local connector definition, used for equation balancing check
      connector InputAbsolutePressure = input
          Modelica.Units.SI.AbsolutePressure
        "Pressure as input signal connector";
      connector InputSpecificEnthalpy = input
          Modelica.Units.SI.SpecificEnthalpy
        "Specific enthalpy as input signal connector";
      connector InputMassFraction = input Modelica.Units.SI.MassFraction
        "Mass fraction as input signal connector";

        // Declarations for Air only
    protected
        Modelica.Units.SI.TemperatureDifference dT(start=T_default - reference_T)
          "Temperature difference used to compute enthalpy";

      equation
        MM = 1/(X[1]/steam.MM+(X[2])/dryair.MM);

        dT = T - reference_T;
        h = dT*dryair.cp * X[2] +
           (dT * steam.cp + h_fg) * X[1];
        R_s = dryair.R*X[2] + steam.R*X[1];

        // Equation for ideal gas, from h=u+p*v and R*T=p*v, from which follows that  u = h-R*T.
        // u = h-R*T;
        // However, in this medium, the gas law is d/dStp=p/pStp, from which follows using h=u+pv that
        // u= h-p*v = h-p/d = h-pStp/dStp
        u = h-pStp/dStp;

        // In this medium model, the density depends only
        // on temperature, but not on pressure.
        //  d = p/(R*T);
        d/dStp = p/pStp;

        state.p = p;
        state.T = T;
        state.X = X;

        X[1] = Xi[1];
        X[2] = 1 - X[1];

        // Assertions to test for bounds
        assert(noEvent(X[1] >= -1.e-5) and noEvent(X[1] <= 1 + 1.e-5), "Mass fraction X[1] = " + String(X[1]) + " of substance water"
          + "\nof medium \"Buildings.Media.Air\" is not in the range 0..1");

        assert(noEvent(T >= 200.0), "In "   + getInstanceName() + ": Temperature T exceeded its minimum allowed value of -73.15 degC (200 Kelvin)
as required from medium model \"Buildings.Media.Air\".");
        assert(noEvent(T <= 423.15), "In "   + getInstanceName() + ": Temperature T exceeded its maximum allowed value of 150 degC (423.15 Kelvin)
as required from medium model \"Buildings.Media.Air\".");

      assert(noEvent(p >= 0.0), "Pressure (= " + String(p) + " Pa) of medium \"Buildings.Media.Air\" is negative\n(Temperature = " + String(T) + " K)");
      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}), Text(
              extent={{-152,164},{152,102}},
              textString="%name",
              textColor={0,0,255})}), Documentation(info="<html>
<p>
Model with basic thermodynamic properties.
</p>
<p>
This model provides equation for the following thermodynamic properties:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" summary=\"Thermodynamic properties\">
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
</html>",     revisions="<html>
<ul>
<li>
September 22, 2020, by Michael Wetter:<br/>
First implementation based on Modelica Standard Library,
but with <code>noEvent</code> added to check of bounds.
</li>
</ul>
</html>"));
      end BaseProperties;

    redeclare function density "Gas density"
      extends Modelica.Icons.Function;
      input ThermodynamicState state;
      output Density d "Density";
    algorithm
      d :=state.p*dStp/pStp;
      annotation(smoothOrder=5,
      Inline=true,
      Documentation(info="<html>
Density is computed from pressure, temperature and composition in the thermodynamic state record applying the ideal gas law.
</html>"));
    end density;

    redeclare function extends dynamicViscosity
        "Return the dynamic viscosity of dry air"
    algorithm
      eta := 4.89493640395e-08 * state.T + 3.88335940547e-06;
      annotation (
      smoothOrder=99,
      Inline=true,
    Documentation(info="<html>
<p>
This function returns the dynamic viscosity.
</p>
<h4>Implementation</h4>
<p>
The function is based on the 5th order polynomial
of
<a href=\"modelica://Modelica.Media.Air.MoistAir.dynamicViscosity\">
Modelica.Media.Air.MoistAir.dynamicViscosity</a>.
However, for the typical range of temperatures encountered
in building applications, a linear function sufficies.
This implementation is therefore the above 5th order polynomial,
linearized around <i>20</i>&deg;C.
The relative error of this linearization is
<i>0.4</i>% at <i>-20</i>&deg;C,
and less then
<i>0.2</i>% between  <i>-5</i>&deg;C and  <i>+50</i>&deg;C.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 19, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end dynamicViscosity;

    redeclare function enthalpyOfCondensingGas
        "Enthalpy of steam per unit mass of steam"
      extends Modelica.Icons.Function;

      input Temperature T "temperature";
      output SpecificEnthalpy h "steam enthalpy";
    algorithm
      h := (T-reference_T) * steam.cp + h_fg;
      annotation(smoothOrder=5,
      Inline=true,
      derivative=der_enthalpyOfCondensingGas);
    end enthalpyOfCondensingGas;

    redeclare replaceable function extends enthalpyOfGas
        "Enthalpy of gas mixture per unit mass of gas mixture"
    algorithm
      h := enthalpyOfCondensingGas(T)*X[Water]
           + enthalpyOfDryAir(T)*(1.0-X[Water]);
    annotation (
      Inline=true);
    end enthalpyOfGas;

    redeclare replaceable function extends enthalpyOfLiquid
        "Enthalpy of liquid (per unit mass of liquid) which is linear in the temperature"
    algorithm
      h := (T - reference_T)*cpWatLiq;
      annotation (
        smoothOrder=5,
        Inline=true,
        derivative=der_enthalpyOfLiquid);
    end enthalpyOfLiquid;

    redeclare function enthalpyOfNonCondensingGas
        "Enthalpy of non-condensing gas per unit mass of steam"
      extends Modelica.Icons.Function;

      input Temperature T "temperature";
      output SpecificEnthalpy h "enthalpy";
    algorithm
      h := enthalpyOfDryAir(T);
      annotation (
      smoothOrder=5,
      Inline=true,
      derivative=der_enthalpyOfNonCondensingGas);
    end enthalpyOfNonCondensingGas;

    redeclare function extends enthalpyOfVaporization
        "Enthalpy of vaporization of water"
    algorithm
      r0 := h_fg;
      annotation (
        Inline=true);
    end enthalpyOfVaporization;

    redeclare function extends gasConstant
        "Return ideal gas constant as a function from thermodynamic state, only valid for phi<1"

    algorithm
        R_s := dryair.R*(1 - state.X[Water]) + steam.R*state.X[Water];
      annotation (
        smoothOrder=2,
        Inline=true,
        Documentation(info="<html>
The ideal gas constant for moist air is computed from <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state</a> assuming that all water is in the gas phase.
</html>"));
    end gasConstant;

    redeclare function extends pressure
        "Returns pressure of ideal gas as a function of the thermodynamic state record"

    algorithm
      p := state.p;
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
Pressure is returned from the thermodynamic state record input as a simple assignment.
</html>"));
    end pressure;

    redeclare function extends isobaricExpansionCoefficient
        "Isobaric expansion coefficient beta"
    algorithm
      beta := 0;
      annotation (
        smoothOrder=5,
        Inline=true,
    Documentation(info="<html>
<p>
This function returns the isobaric expansion coefficient at constant pressure,
which is zero for this medium.
The isobaric expansion coefficient at constant pressure is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&beta;<sub>p</sub> = - 1 &frasl; v &nbsp; (&part; v &frasl; &part; T)<sub>p</sub> = 0,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isobaricExpansionCoefficient;

    redeclare function extends isothermalCompressibility
        "Isothermal compressibility factor"
    algorithm
      kappa := -1/state.p;
      annotation (
        smoothOrder=5,
        Inline=true,
        Documentation(info="<html>
<p>
This function returns the isothermal compressibility coefficient.
The isothermal compressibility is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&kappa;<sub>T</sub> = -1 &frasl; v &nbsp; (&part; v &frasl; &part; p)<sub>T</sub>
  = -1 &frasl; p,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isothermalCompressibility;

    redeclare function extends saturationPressure
        "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"

    algorithm
      psat := Buildings.Utilities.Psychrometrics.Functions.saturationPressure(Tsat);
      annotation (
      smoothOrder=5,
      Inline=true);
    end saturationPressure;

    redeclare function extends specificEntropy
        "Return the specific entropy, only valid for phi<1"

    protected
        Modelica.Units.SI.MoleFraction[2] Y "Molar fraction";
    algorithm
        Y := massToMoleFractions(
             state.X, {steam.MM,dryair.MM});
        s := specificHeatCapacityCp(state) * Modelica.Math.log(state.T/reference_T)
             - Modelica.Constants.R *
             sum(state.X[i]/MMX[i]*
                 Modelica.Math.log(max(Y[i], Modelica.Constants.eps)*state.p/reference_p) for i in 1:2);
      annotation (
      Inline=true,
        Documentation(info="<html>
<p>
This function computes the specific entropy.
</p>
<p>
The specific entropy of the mixture is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s = s<sub>s</sub> + s<sub>m</sub>,
</p>
<p>
where
<i>s<sub>s</sub></i> is the entropy change due to the state change
(relative to the reference temperature) and
<i>s<sub>m</sub></i> is the entropy change due to mixing
of the dry air and water vapor.
</p>
<p>
The entropy change due to change in state is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(v/v<sub>0</sub>) <br/>
= c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(&rho;<sub>0</sub>/&rho;)
</p>
<p>If we assume <i>&rho; = p<sub>0</sub>/(R T)</i>,
and because <i>c<sub>p</sub> = c<sub>v</sub> + R</i>,
we can write
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(T/T<sub>0</sub>) <br/>
=c<sub>p</sub> ln(T/T<sub>0</sub>).
</p>
<p>
Next, the entropy of mixing is obtained from a reversible isothermal
expansion process. Hence,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  s<sub>m</sub> = -R &sum;<sub>i</sub>( X<sub>i</sub> &frasl; M<sub>i</sub>
  ln(Y<sub>i</sub> p/p<sub>0</sub>)),
</p>
<p>
where <i>R</i> is the gas constant,
<i>X</i> is the mass fraction,
<i>M</i> is the molar mass, and
<i>Y</i> is the mole fraction.
</p>
<p>
To obtain the state for a given pressure, entropy and mass fraction, use
<a href=\"modelica://Buildings.Media.Air.setState_psX\">
Buildings.Media.Air.setState_psX</a>.
</p>
<h4>Limitations</h4>
<p>
This function is only valid for a relative humidity below 100%.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end specificEntropy;

    redeclare function extends density_derp_T
        "Return the partial derivative of density with respect to pressure at constant temperature"
    algorithm
      ddpT := dStp/pStp;
      annotation (
      Inline=true,
    Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to pressure at constant temperature.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derp_T;

    redeclare function extends density_derT_p
        "Return the partial derivative of density with respect to temperature at constant pressure"
    algorithm
      ddTp := 0;

      annotation (
      smoothOrder=99,
      Inline=true,
      Documentation(info=
    "<html>
<p>
This function computes the derivative of density with respect to temperature
at constant pressure.
</p>
</html>",     revisions=
    "<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derT_p;

    redeclare function extends density_derX
        "Return the partial derivative of density with respect to mass fractions at constant pressure and temperature"
    algorithm
      dddX := fill(0, nX);
    annotation (
      smoothOrder=99,
      Inline=true,
      Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to mass fraction.
This value is zero because in this medium, density is proportional
to pressure, but independent of the species concentration.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derX;

    redeclare replaceable function extends specificHeatCapacityCp
        "Specific heat capacity of gas mixture at constant pressure"
    algorithm
      cp := dryair.cp*(1-state.X[Water]) +steam.cp*state.X[Water];
        annotation (
      smoothOrder=99,
      Inline=true,
      derivative=der_specificHeatCapacityCp);
    end specificHeatCapacityCp;

    redeclare replaceable function extends specificHeatCapacityCv
        "Specific heat capacity of gas mixture at constant volume"
    algorithm
      cv:= dryair.cv*(1-state.X[Water]) +steam.cv*state.X[Water];
      annotation (
        smoothOrder=99,
        Inline=true,
        derivative=der_specificHeatCapacityCv);
    end specificHeatCapacityCv;

    redeclare function setState_dTX
        "Return thermodynamic state as function of density d, temperature T and composition X"
      extends Modelica.Icons.Function;
      input Density d "Density";
      input Temperature T "Temperature";
      input MassFraction X[:]=reference_X "Mass fractions";
      output ThermodynamicState state "Thermodynamic state";

    algorithm
        // Note that d/dStp = p/pStp, hence p = d*pStp/dStp
        state := if size(X, 1) == nX then
                   ThermodynamicState(p=d*pStp/dStp, T=T, X=X)
                 else
                   ThermodynamicState(p=d*pStp/dStp,
                                      T=T,
                                      X=cat(1, X, {1 - sum(X)}));
        annotation (
        smoothOrder=2,
        Inline=true,
        Documentation(info="<html>
<p>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">thermodynamic state record</a>
    is computed from density <code>d</code>, temperature <code>T</code> and composition <code>X</code>.
</p>
</html>"));
    end setState_dTX;

    redeclare function extends setState_phX
        "Return thermodynamic state as function of pressure p, specific enthalpy h and composition X"
    algorithm
      state := if size(X, 1) == nX then
        ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=X)
     else
        ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=cat(1, X, {1 - sum(X)}));
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>"));
    end setState_phX;

    redeclare function extends setState_pTX
        "Return thermodynamic state as function of p, T and composition X or Xi"
    algorithm
        state := if size(X, 1) == nX then
                    ThermodynamicState(p=p, T=T, X=X)
                 else
                    ThermodynamicState(p=p, T=T, X=cat(1, X, {1 - sum(X)}));
        annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, temperature T and composition X.
</html>"));
    end setState_pTX;

    redeclare function extends setState_psX
        "Return the thermodynamic state as function of p, s and composition X or Xi"
    protected
        Modelica.Units.SI.MassFraction[2] X_int "Mass fraction";
        Modelica.Units.SI.MoleFraction[2] Y "Molar fraction";
        Modelica.Units.SI.Temperature T "Temperature";
    algorithm
        if size(X, 1) == nX then
          X_int:=X;
        else
          X_int :=cat(
            1,
            X,
            {1 - sum(X)});
        end if;
       Y := massToMoleFractions(
             X_int, {steam.MM,dryair.MM});
        // The next line is obtained from symbolic solving the
        // specificEntropy function for T.
        // In this formulation, we can set T to any value when calling
        // specificHeatCapacityCp as cp does not depend on T.
        T := 273.15 * Modelica.Math.exp((s + Modelica.Constants.R *
               sum(X_int[i]/MMX[i]*
                 Modelica.Math.log(max(Y[i], Modelica.Constants.eps)) for i in 1:2))
                 / specificHeatCapacityCp(setState_pTX(p=p,
                                                       T=273.15,
                                                       X=X_int)));

        state := ThermodynamicState(p=p,
                                    T=T,
                                    X=X_int);

    annotation (
    Inline=true,
    Documentation(info="<html>
<p>
This function returns the thermodynamic state based on pressure,
specific entropy and mass fraction.
</p>
<p>
The state is computed by symbolically solving
<a href=\"modelica://Buildings.Media.Air.specificEntropy\">
Buildings.Media.Air.specificEntropy</a>
for temperature.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end setState_psX;

    redeclare replaceable function extends specificEnthalpy
        "Compute specific enthalpy from pressure, temperature and mass fraction"
    algorithm
      h := (state.T - reference_T)*dryair.cp * (1 - state.X[Water]) +
           ((state.T-reference_T) * steam.cp + h_fg) * state.X[Water];
      annotation (
       smoothOrder=5,
       Inline=true);
    end specificEnthalpy;

    redeclare replaceable function specificEnthalpy_pTX "Specific enthalpy"
      extends Modelica.Icons.Function;
        input Modelica.Units.SI.Pressure p "Pressure";
        input Modelica.Units.SI.Temperature T "Temperature";
        input Modelica.Units.SI.MassFraction X[:] "Mass fractions of moist air";
        output Modelica.Units.SI.SpecificEnthalpy h "Specific enthalpy at p, T, X";

    algorithm
      h := specificEnthalpy(setState_pTX(p, T, X));
      annotation(smoothOrder=5,
                 Inline=true,
                 inverse(T=temperature_phX(p, h, X)),
                 Documentation(info="<html>
Specific enthalpy as a function of temperature and species concentration.
The pressure is input for compatibility with the medium models, but the specific enthalpy
is independent of the pressure.
</html>",
    revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
    end specificEnthalpy_pTX;

    redeclare replaceable function extends specificGibbsEnergy
        "Specific Gibbs energy"
    algorithm
      g := specificEnthalpy(state) - state.T*specificEntropy(state);
      annotation (
        Inline=true);
    end specificGibbsEnergy;

    redeclare replaceable function extends specificHelmholtzEnergy
        "Specific Helmholtz energy"
    algorithm
      f := specificEnthalpy(state) - gasConstant(state)*state.T - state.T*specificEntropy(state);
      annotation (
        Inline=true);
    end specificHelmholtzEnergy;

    redeclare function extends isentropicEnthalpy "Return the isentropic enthalpy"
    algorithm
      h_is := specificEnthalpy(setState_psX(
                p=p_downstream,
                s=specificEntropy(refState),
                X=refState.X));
    annotation (
      Inline=true,
      Documentation(info="<html>
<p>
This function computes the specific enthalpy for
an isentropic state change from the temperature
that corresponds to the state <code>refState</code>
to <code>reference_T</code>.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isentropicEnthalpy;

    redeclare function extends specificInternalEnergy "Specific internal energy"
      extends Modelica.Icons.Function;
    algorithm
      u := specificEnthalpy(state) - pStp/dStp;
      annotation (
        Inline=true);
    end specificInternalEnergy;

    redeclare function extends temperature
        "Return temperature of ideal gas as a function of the thermodynamic state record"
    algorithm
      T := state.T;
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
Temperature is returned from the thermodynamic state record input as a simple assignment.
</html>"));
    end temperature;

    redeclare function extends molarMass "Return the molar mass"
    algorithm
        MM := 1/(state.X[Water]/MMX[Water]+(1.0-state.X[Water])/MMX[Air]);
        annotation (
    Inline=true,
    smoothOrder=99,
    Documentation(info="<html>
<p>
This function returns the molar mass.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end molarMass;

    redeclare replaceable function temperature_phX
        "Compute temperature from specific enthalpy and mass fraction"
        extends Modelica.Icons.Function;
      input AbsolutePressure p "Pressure";
      input SpecificEnthalpy h "specific enthalpy";
      input MassFraction[:] X "mass fractions of composition";
      output Temperature T "temperature";
    algorithm
      T := reference_T + (h - h_fg * X[Water])
           /((1 - X[Water])*dryair.cp + X[Water] * steam.cp);
      annotation(smoothOrder=5,
                 Inline=true,
                 inverse(h=specificEnthalpy_pTX(p, T, X)),
                 Documentation(info="<html>
Temperature as a function of specific enthalpy and species concentration.
The pressure is input for compatibility with the medium models, but the temperature
is independent of the pressure.
</html>",
    revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
    end temperature_phX;

    redeclare function extends thermalConductivity
        "Thermal conductivity of dry air as a polynomial in the temperature"
    algorithm
      lambda :=Modelica.Math.Polynomials.evaluate({(-4.8737307422969E-008),
          7.67803133753502E-005,0.0241814385504202},
          Modelica.Units.Conversions.to_degC(state.T));
    annotation(LateInline=true);
    end thermalConductivity;
    //////////////////////////////////////////////////////////////////////
    // Protected classes.
    // These classes are only of use within this medium model.
    // Models generally have no need to access them.
    // Therefore, they are made protected. This also allows to redeclare the
    // medium model with another medium model that does not provide an
    // implementation of these classes.
  protected
      record GasProperties
        "Coefficient data record for properties of perfect gases"
        extends Modelica.Icons.Record;

        Modelica.Units.SI.MolarMass MM "Molar mass";
        Modelica.Units.SI.SpecificHeatCapacity R "Gas constant";
        Modelica.Units.SI.SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
        Modelica.Units.SI.SpecificHeatCapacity cv=cp - R
          "Specific heat capacity at constant volume";
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This data record contains the coefficients for perfect gases.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 12, 2014, by Michael Wetter:<br/>
Corrected the wrong location of the <code>preferredView</code>
and the <code>revisions</code> annotation.
</li>
<li>
November 21, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end GasProperties;
      constant Modelica.Units.SI.SpecificEnergy h_fg=Buildings.Utilities.Psychrometrics.Constants.h_fg
        "Latent heat of evaporation of water";
      constant Modelica.Units.SI.SpecificHeatCapacity cpWatLiq=Buildings.Utilities.Psychrometrics.Constants.cpWatLiq
        "Specific heat capacity of liquid water";

    replaceable function der_enthalpyOfLiquid
        "Temperature derivative of enthalpy of liquid per unit mass of liquid"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of liquid enthalpy";
    algorithm
      der_h := cpWatLiq*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfLiquid;

    function der_enthalpyOfCondensingGas
        "Derivative of enthalpy of steam per unit mass of steam"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of steam enthalpy";
    algorithm
      der_h := steam.cp*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfCondensingGas;

    replaceable function enthalpyOfDryAir
        "Enthalpy of dry air per unit mass of dry air"
      extends Modelica.Icons.Function;

      input Temperature T "Temperature";
      output SpecificEnthalpy h "Dry air enthalpy";
    algorithm
      h := (T - reference_T)*dryair.cp;
      annotation (
        smoothOrder=5,
        Inline=true,
        derivative=der_enthalpyOfDryAir);
    end enthalpyOfDryAir;

    replaceable function der_enthalpyOfDryAir
        "Derivative of enthalpy of dry air per unit mass of dry air"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of dry air enthalpy";
    algorithm
      der_h := dryair.cp*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfDryAir;

    replaceable function der_enthalpyOfNonCondensingGas
        "Derivative of enthalpy of non-condensing gas per unit mass of steam"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of steam enthalpy";
    algorithm
      der_h := der_enthalpyOfDryAir(T, der_T);
      annotation (
        Inline=true);
    end der_enthalpyOfNonCondensingGas;

    replaceable function der_specificHeatCapacityCp
        "Derivative of specific heat capacity of gas mixture at constant pressure"
      extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        input ThermodynamicState der_state "Derivative of thermodynamic state";
        output Real der_cp(unit="J/(kg.K.s)")
          "Derivative of specific heat capacity";
    algorithm
      der_cp := (steam.cp-dryair.cp)*der_state.X[Water];
      annotation (
        Inline=true);
    end der_specificHeatCapacityCp;

    replaceable function der_specificHeatCapacityCv
        "Derivative of specific heat capacity of gas mixture at constant volume"
      extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        input ThermodynamicState der_state "Derivative of thermodynamic state";
        output Real der_cv(unit="J/(kg.K.s)")
          "Derivative of specific heat capacity";
    algorithm
      der_cv := (steam.cv-dryair.cv)*der_state.X[Water];
      annotation (
        Inline=true);
    end der_specificHeatCapacityCv;
      annotation(Documentation(info="<html>
<p>
This medium package models moist air using a gas law in which pressure and temperature
are independent, which often leads to significantly faster and more robust computations.
The specific heat capacities at constant pressure and at constant volume are constant.
The air is assumed to be not saturated.
</p>
<p>
This medium uses the gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho;/&rho;<sub>stp</sub> = p/p<sub>stp</sub>,
</p>
<p>
where
<i>p<sub>std</sub></i> and <i>&rho;<sub>stp</sub></i> are constant reference
temperature and density, rathern than the ideal gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho; = p &frasl;(R T),
</p>
<p>
where <i>R</i> is the gas constant and <i>T</i> is the temperature.
</p>
<p>
This formulation often leads to smaller systems of nonlinear equations
because equations for pressure and temperature are decoupled.
Therefore, if air inside a control volume such as room air is heated, it
does not increase its specific volume. Consequently, merely heating or cooling
a control volume does not affect the air flow calculations in a duct network
that may be connected to that volume.
Note that multizone air exchange simulation in which buoyancy drives the
air flow is still possible as the models in
<a href=\"modelica://Buildings.Airflow.Multizone\">
Buildings.Airflow.Multizone</a> compute the mass density using the function
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.density_pTX\">
Buildings.Utilities.Psychrometrics.Functions.density_pTX</a> in which density
is a function of temperature.
</p>
<p>
Note that models in this package implement the equation for the internal energy as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p<sub>stp</sub> &frasl; &rho;<sub>stp</sub>,
</p>
<p>
where
<i>u</i> is the internal energy per unit mass,
<i>h</i> is the enthalpy per unit mass,
<i>p<sub>stp</sub></i> is the static pressure and
<i>&rho;<sub>stp</sub></i> is the mass density at standard pressure and temperature.
The reason for this implementation is that in general,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  h = u + p v,
</p>
<p>
from which follows that
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p v = h - p &frasl; &rho; = h - p<sub>stp</sub> &frasl; &rho;<sub>std</sub>,
</p>
<p>
because <i>p &frasl; &rho; = p<sub>stp</sub> &frasl; &rho;<sub>stp</sub></i> in this medium model.
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C and no water vapor is present.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 9, 2022, by Michael Wetter:<br/>
Set nominal attribute for <code>BaseProperties.Xi</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1634\">#1634</a>.
</li>
<li>
September 28, 2020, by Michael Wetter:<br/>
Reformulated <code>BaseProperties</code> to avoid event-triggering assertions.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1401\">#1401</a>.
</li>
<li>
January 11, 2019 by Michael Wetter:<br/>
Reforulated assignment of <code>X_int</code> in <code>setState_psX</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1079\">#1079</a>.
</li>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
November 4, 2016, by Michael Wetter:<br/>
Set default value for <code>dT.start</code> in base properties.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/575\">#575</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://Buildings.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
Buildings.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>.
Note that the default is <code>preferredMediumState=false</code>
and hence the same states are used as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
May 11, 2015, by Michael Wetter:<br/>
Removed
<code>p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)</code>
in declaration of <code>BaseProperties</code>.
Otherwise, when models that contain a fluid volume
are exported as an FMU, their pressure would be
differentiated with respect to time. This would require
the time derivative of the inlet pressure, which is not available,
causing the translation to stop with an error.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
March 20, 2015, by Michael Wetter:<br/>
Added missing term <code>state.p/reference_p</code> in function
<code>specificEntropy</code>.
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/193\">#193</a>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
Changed implementation to use
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Constants\">
Buildings.Utilities.Psychrometrics.Constants</a>.
This was done to use consistent values throughout the library.
</li>
<li>
November 16, 2013, by Michael Wetter:<br/>
Revised and simplified the implementation.
</li>
<li>
November 14, 2013, by Michael Wetter:<br/>
Removed function
<code>HeatCapacityOfWater</code>
which is neither needed nor implemented in the
Modelica Standard Library.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed non-used computations in <code>specificEnthalpy_pTX</code> and
in <code>temperature_phX</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Added <code>final standardOrderComponents=true</code> in the
<code>BaseProperties</code> declaration. This avoids an error
when models are checked in Dymola 2014 in the pedenatic mode.
</li>
<li>
April 12, 2012, by Michael Wetter:<br/>
Added keyword <code>each</code> to <code>Xi(stateSelect=...)</code>.
</li>
<li>
April 4, 2012, by Michael Wetter:<br/>
Added redeclaration of <code>ThermodynamicState</code> to avoid a warning
during model check and translation.
</li>
<li>
August 3, 2011, by Michael Wetter:<br/>
Fixed bug in <code>u=h-R*T</code>, which is only valid for ideal gases.
For this medium, the function is <code>u=h-pStd/dStp</code>.
</li>
<li>
January 27, 2010, by Michael Wetter:<br/>
Fixed bug in <code>else</code> branch of function <code>setState_phX</code>
that lead to a run-time error when the constructor of this function was called.
</li>
<li>
January 22, 2010, by Michael Wetter:<br/>
Added implementation of function
<a href=\"modelica://Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfNonCondensingGas\">
enthalpyOfNonCondensingGas</a> and its derivative.
</li>
<li>
January 13, 2010, by Michael Wetter:<br/>
Fixed implementation of derivative functions.
</li>
<li>
August 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(graphics={
            Ellipse(
              extent={{-78,78},{-34,34}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-18,86},{26,42}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{48,58},{92,14}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-22,32},{22,-12}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{36,-32},{80,-76}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-36,-30},{8,-74}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-90,-6},{-46,-50}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120})}));
    end Air;

    package Water "Package with model for liquid water with constant density"
       extends Modelica.Media.Water.ConstantPropertyLiquidWater(
         p_default=300000,
         reference_p=300000,
         reference_T=273.15,
         reference_X={1},
         AbsolutePressure(start=p_default),
         Temperature(start=T_default),
         Density(start=d_const),
         final cv_const=cp_const);
      // cp_const and cv_const have been made final because the model sets u=h.
      extends Modelica.Icons.Package;

      redeclare replaceable model BaseProperties "Base properties (p, d, T, h, u, R, MM and X and Xi) of a medium"
        parameter Boolean preferredMediumStates=false
          "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        final parameter Boolean standardOrderComponents=true
          "If true, and reducedX = true, the last element of X will be computed from the other ones";
        Modelica.Units.SI.Density d=d_const "Density of medium";
        Temperature T(stateSelect=
          if preferredMediumStates then StateSelect.prefer else StateSelect.default)
          "Temperature of medium";
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi=fill(0, 0)
          "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Modelica.Units.SI.SpecificInternalEnergy u
          "Specific internal energy of medium";

        Modelica.Units.SI.MassFraction[nX] X={1}
          "Mass fractions (= (component mass)/total mass  m_i/m)";
        final Modelica.Units.SI.SpecificHeatCapacity R_s=0
          "Gas constant (of mixture if applicable)";
        final Modelica.Units.SI.MolarMass MM=MM_const
          "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
          "Thermodynamic state record for optional functions";


        Modelica.Units.NonSI.Temperature_degC T_degC=
            Modelica.Units.Conversions.to_degC(T) "Temperature of medium in [degC]";
        Modelica.Units.NonSI.Pressure_bar p_bar=Modelica.Units.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input
          Modelica.Units.SI.AbsolutePressure
          "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input
          Modelica.Units.SI.SpecificEnthalpy
          "Specific enthalpy as input signal connector";
        connector InputMassFraction = input Modelica.Units.SI.MassFraction
          "Mass fraction as input signal connector";

      equation
        h = cp_const*(T-reference_T);
        u = h;
        state.T = T;
        state.p = p;

        // Assertions to test for bounds
        assert(noEvent(T >= T_min), "In " + getInstanceName() + ": Temperature T = " + String(T) + " K exceeded its minimum allowed value of " +
      String(T_min-273.15) + " degC (" + String(T_min) + " Kelvin) as required from medium model \"Buildings.Media.Water\".");

        assert(noEvent(T <= T_max), "In " + getInstanceName() + ": Temperature T = " + String(T) + " K exceeded its maximum allowed value of " +
      String(T_max-273.15) + " degC (" + String(T_max) + " Kelvin) as required from medium model \"Buildings.Media.Water\".");

        assert(noEvent(p >= 0.0), "Pressure (= " + String(p) + " Pa) of medium \"Buildings.Media.Water\" is negative\n(Temperature = " + String(T) + " K)");

        annotation(Documentation(info="<html>
<p>
Model with basic thermodynamic properties.
</p>
<p>
This base properties model is identical to
<a href=\"modelica://Modelica.Media.Water.ConstantPropertyLiquidWater\">
Modelica.Media.Water.ConstantPropertyLiquidWater</a>,
except that the equation
<code>u = cv_const*(T - reference_T)</code>
has been replaced by <code>u=h</code> because
<code>cp_const=cv_const</code>.
</p>
<p>
This model provides equation for the following thermodynamic properties:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" summary=\"Thermodynamic properties\">
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
</html>"));
      end BaseProperties;

    function enthalpyOfLiquid "Return the specific enthalpy of liquid"
      extends Modelica.Icons.Function;
        input Modelica.Units.SI.Temperature T "Temperature";
        output Modelica.Units.SI.SpecificEnthalpy h "Specific enthalpy";
    algorithm
      h := cp_const*(T-reference_T);
    annotation (
      smoothOrder=5,
      Inline=true,
    Documentation(info="<html>
<p>
Enthalpy of the water.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 16, 2014 by Michael Wetter:<br/>
First implementation.
This function is used by
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir\">
Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir</a>.
</li>
</ul>
</html>"));
    end enthalpyOfLiquid;
      annotation(Documentation(info="<html>
<p>
This medium package models liquid water.
</p>
<p>
The mass density is computed using a constant value of <i>995.586</i> kg/s.
For a medium model in which the density is a function of temperature, use
<a href=\"modelica://Buildings.Media.Specialized.Water.TemperatureDependentDensity\">
Buildings.Media.Specialized.Water.TemperatureDependentDensity</a> which may have considerably higher computing time.
</p>
<p>
For the specific heat capacities at constant pressure and at constant volume,
a constant value of <i>4184</i> J/(kg K), which corresponds to <i>20</i>&deg;C
is used.
The figure below shows the relative error of the specific heat capacity that
is introduced by this simplification.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Media/Water/plotCp.png\" border=\"1\"
alt=\"Relative variation of specific heat capacity with temperature\"/>
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C.
</p>
<h4>Limitations</h4>
<p>
Density, specific heat capacity, thermal conductivity and viscosity are constant.
Water is modeled as an incompressible liquid.
There are no phase changes.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 28, 2020, by Michael Wetter:<br/>
Reformulated <code>BaseProperties</code> to avoid event-triggering assertions.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1401\">#1401</a>.
</li>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://Buildings.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
Buildings.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
(if used with water instead of air)
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure and density.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Changed type of <code>BaseProperties.T</code> from
<code>Modelica.Units.SI.Temperature</code> to <code>Temperature</code>.
Otherwise, it has a different start value than <code>Medium.T</code>, which
causes an error if
<a href=\"modelica://Buildings.Media.Examples.WaterProperties\">
Buildings.Media.Examples.WaterProperties</a>
is translated in pedantic mode.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>,
and set <code>preferredMediumState=false</code>
to keep the same states as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Removed <code>ThermodynamicState</code> declaration as this lead to
the error
\"Attempting to redeclare record ThermodynamicState when the original was not replaceable.\"
in Dymola 2016 using the pedantic model check.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
February 25, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect</code> attribute on pressure as this caused
<a href=\"modelica://Buildings.Examples.Tutorial.SpaceCooling.System3\">
Buildings.Examples.Tutorial.SpaceCooling.System3</a>
to fail with the error message
\"differentiated if-then-else was not continuous\".
</li>
<li>
October 15, 2014, by Michael Wetter:<br/>
Reimplemented media based on
<a href=\"https://github.com/ibpsa/modelica-ibpsa/blob/446aa83720884052476ad6d6d4f90a6a29bb8ec9/Buildings/Media/Water.mo\">446aa83</a>.
</li>
<li>
November 15, 2013, by Michael Wetter:<br/>
Complete new reimplementation because the previous version
had the option to add a compressibility to the medium, which
has never been used.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Polygon(
              points={{16,-28},{32,-42},{26,-48},{10,-36},{16,-28}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Polygon(
              points={{10,34},{26,44},{30,36},{14,26},{10,34}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Ellipse(
              extent={{-82,52},{24,-54}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={0,0,0}),
            Ellipse(
              extent={{22,82},{80,24}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Ellipse(
              extent={{20,-30},{78,-88}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95})}));
    end Water;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains media models for water and moist air.
The media models in this package are
compatible with
<a href=\"modelica://Modelica.Media\">
Modelica.Media</a>
but the implementation is in general simpler, which often
leads to more efficient simulation.
Due to the simplifications, the media model of this package
are generally accurate for a smaller temperature range than the
models in <a href=\"modelica://Modelica.Media\">
Modelica.Media</a>, but the smaller temperature range may often be
sufficient for building HVAC applications.
</p>
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package Utilities "Package with utility functions such as for I/O"
    extends Modelica.Icons.Package;

    package IO "Input and output"
      extends Modelica.Icons.Package;

      package SignalExchange "External Signal Exchange Package"
        extends Modelica.Icons.Package;

        block Overwrite "Block that allows a signal to overwritten by an FMU input"
          extends Modelica.Blocks.Interfaces.SISO;

          parameter String description "Description of the signal being overwritten";

          final parameter Boolean boptestOverwrite = true
            "Parameter that is used by tools to search for overwrite block in models";

          Modelica.Blocks.Logical.Switch swi
            "Switch between external signal and direct feedthrough signal"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          Modelica.Blocks.Sources.RealExpression uExt "External input signal"
            annotation (Placement(transformation(extent={{-60,10},{-40,30}})));
          Modelica.Blocks.Sources.BooleanExpression activate
            "Block to activate use of external signal"
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

        equation
          connect(activate.y, swi.u2)
            annotation (Line(points={{-39,0},{-12,0}}, color={255,0,255}));
          connect(swi.u3, u) annotation (Line(points={{-12,-8},{-80,-8},{-80,0},{-120,
                  0}}, color={0,0,127}));
          connect(uExt.y, swi.u1) annotation (Line(points={{-39,20},{-26,20},{-26,8},
                  {-12,8}}, color={0,0,127}));
          connect(swi.y, y)
            annotation (Line(points={{11,0},{110,0}}, color={0,0,127}));

          annotation (Documentation(info="<html>
<p>
This block enables the overwriting of a control signal by an external program,
as well as reading of its meta-data, without the need to explicitly propogate
the external input or activation switch to a top-level model.
</p>
<h4>Typical use and important parameters</h4>
<p>
This block is typically used by the BOPTEST framework
(see <a href=\"https://github.com/ibpsa/project1-boptest\">BOPTEST</a>)
to identify and activate control signals that can be overwritten by test
controllers. It is used in combination with a dedicated parser to perform
this task (see <a href=\"https://github.com/ibpsa/project1-boptest/tree/master/parsing\">Parser Code</a>).
</p>
<p>
The input <code>u</code> is the signal to be overwritten. The output
<code>y</code> will be equal to the input signal if the <code>activate</code>
flag is <code>false</code> and will be equal to the external input signal <code>uExt</code>
if the flag is <code>true</code>.
</p>
<p>
It is important to add a brief description of the signal using the
<code>description</code> parameter and assign a <code>min</code>,
<code>max</code>, and <code>unit</code> to the input variable <code>u</code>
by modifying its attributes.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 17, 2022 by David Blum:<br/>
Made parameter <code>boptestOverwrite</code> unprotected.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1585\">#1585</a>.
</li>
<li>
July 17, 2019 by Michael Wetter:<br/>
Changed parameter name from <code>Description</code> to <code>description</code>.
</li>
<li>
December 17, 2018 by David Blum:<br/>
First implementation.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1059\">#1059</a>.
</li>
</ul>
</html>"),        Icon(graphics={
                Line(points={{100,0},{42,0}}, color={0,0,127}),
                Line(points={{42,0},{-20,60}},
                color={0,0,127}),
                Line(points={{42,0},{-20,0}},
                color = DynamicSelect({235,235,235}, if activate.y then {235,235,235}
                            else {0,0,0})),
                Line(points={{-100,0},{-20,0}}, color={0,0,127}),
                Line(points={{-62,60},{-20,60}},  color={0,0,127}),
                Polygon(
                  points={{-58,70},{-28,60},{-58,50},{-58,70}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-22,62},{-18,58}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-22,2},{-18,-2}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,2},{44,-2}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Line(points={{-16,0},{16,0}},     color={0,0,127},
                  origin={-62,60},
                  rotation=90),
                Line(points={{-16,0},{16,0}},     color={0,0,127},
                  origin={-66,60},
                  rotation=90),
                Line(points={{-16,0},{16,0}},     color={0,0,127},
                  origin={-70,60},
                  rotation=90),
                Ellipse(
                  extent={{-77,67},{-91,53}},
                  fillPattern=FillPattern.Solid,
                  lineColor=DynamicSelect({235,235,235}, if activate.y then {0,255,0}
                            else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if activate.y then {0,255,0}
                            else {235,235,235}))}));
        end Overwrite;

        model Read "Block that allows a signal to be read as an FMU output"
          extends Modelica.Blocks.Routing.RealPassThrough;

          parameter String description "Description of the signal being read";

          parameter SignalTypes.SignalsForKPIs KPIs = SignalTypes.SignalsForKPIs.None
            "Tag with the type of signal for the calculation of the KPIs";

          parameter String zone = "1" if (
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.AirZoneTemperature or
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.RadiativeZoneTemperature or
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.OperativeZoneTemperature or
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.RelativeHumidity or
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.CO2Concentration)
            "Zone designation, required if KPIs is AirZoneTemperature, 
    RadiativeZoneTemperature, OperativeZoneTemperature, RelativeHumidity, 
    or CO2Concentration"
          annotation(Dialog(enable=(
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.AirZoneTemperature or
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.RadiativeZoneTemperature or
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.OperativeZoneTemperature or
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.RelativeHumidity or
            KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.CO2Concentration)));

          final parameter Boolean boptestRead = true
            "Parameter that is used by tools to search for read block in models";

          annotation (Documentation(info="<html>
<p>
This block enables the reading of a signal and its meta-data by an external
program without the need to explicitly propogate the signal to a top-level model.
</p>
<h4>Typical use and important parameters</h4>
<p>
This block is typically used by the BOPTEST framework
(see <a href=\"https://github.com/ibpsa/project1-boptest\">BOPTEST</a>)
to identify and read signals as measurements by test
controllers. It is used in combination with a dedicated parser to perform
this task (see <a href=\"https://github.com/ibpsa/project1-boptest/tree/master/parsing\">Parser Code</a>).
This block is also used by BOPTEST to specify if the signal is needed
for calculation of specific key performance indicators (KPI).
</p>
<p>
The block output <code>y</code> is equal to the input <code>u</code> so that
the block can be used in line with connections.  However, input signal will
also be directed to an external program as an output.
</p>
<p>
It is important to add a brief description of the signal using the
<code>description</code> parameter, assign a <code>unit</code> to the output 
variable <code>y</code>, assign a type if needed for KPI
calculation using the <code>KPIs</code> parameter, and assign a zone 
designation using the <code>zone</code> parameter if the KPI calculation is
specific to a particular zone (for multi-zone models). See documentation for 
the parameter <code>zone</code> for more details.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 17, 2022 by David Blum:<br/>
Made parameter <code>boptestRead</code> unprotected.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1585\">#1585</a>.
</li>
<li>
February 23, 2020 by David Blum:<br/>
Added zone designation for KPI calculation by parameter <code>zone</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1257\">#1257</a>.
</li>
<li>
January 9, 2020 by David Blum:<br/>
Updated documentation to prompt user to add unit to output.  
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1276\">#1276</a>.
</li>
<li>
July 17, 2019 by Michael Wetter:<br/>
Changed parameter name from <code>Description</code> to <code>description</code>.
</li>
<li>
April 11, 2019 by Javier Arroyo:<br/>
Enumeration type KPI tags added.
</li>
<li>
December 17, 2018 by David Blum:<br/>
First implementation.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1059\">#1059</a>.
</li>
</ul>
</html>"),         Icon(graphics={
                Line(points={{22,60},{70,60}},  color={0,0,127}),
                Line(points={{-38,0},{22,60}}, color={0,0,127}),
                Line(points={{-100,0},{-38,0}}, color={0,0,127}),
                Line(points={{-38,0},{100,0}}, color={0,0,127}),
                Ellipse(
                  extent={{-40,2},{-36,-2}},
                  lineColor={28,108,200},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{36,70},{66,60},{36,50},{36,70}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Line(points={{-16,0},{16,0}},     color={0,0,127},
                  origin={78,60},
                  rotation=90),
                Line(points={{-16,0},{16,0}},     color={0,0,127},
                  origin={74,60},
                  rotation=90),
                Line(points={{-16,0},{16,0}},     color={0,0,127},
                  origin={70,60},
                  rotation=90),
                Text(
                  extent={{-50,-24},{54,-72}},
                  textColor={153,153,153},
                  textString=DynamicSelect("", if (
                    (KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.AirZoneTemperature) or
                    (KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.RadiativeZoneTemperature) or
                    (KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.OperativeZoneTemperature) or
                    (KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.RelativeHumidity) or
                    (KPIs==Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.CO2Concentration)) then "zone" else ""))}));
        end Read;

        package SignalTypes "Package with signal type definitions"
         extends Modelica.Icons.TypesPackage;

          type SignalsForKPIs = enumeration(
              None
                "Not used for KPI",
              AirZoneTemperature
                "Air zone temperature",
              RadiativeZoneTemperature
                "Radiative zone temperature",
              OperativeZoneTemperature
                "Operative zone temperature",
              RelativeHumidity
                "Relative humidity",
              CO2Concentration
                "CO2 concentration",
              ElectricPower
                "Electric power from grid",
              DistrictHeatingPower
                "Thermal power from district heating",
              GasPower
                "Thermal power from natural gas",
              BiomassPower
                "Thermal power from biomass",
              SolarThermalPower
                "Thermal power from solar thermal",
              FreshWaterFlowRate
                "FreshWaterFlowRate") "Signals used for the calculation of key performance indicators"
            annotation (Documentation(info="<html>
<p>
This enumeration defines the signal types that are used by BOPTEST
to compute the key performance indices (KPI).
</p>
<p>
The following signal types are supported.
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr><th>Value</th>
    <th>Description</th>
</tr>
<tr><td><code>None</code></td>
    <td>Not used for KPI</td>
</tr>
<tr><td><code>AirZoneTemperature</code></td>
    <td>Air zone temperature</td>
</tr>
<tr><td><code>RadiativeZoneTemperature</code></td>
    <td>Radiative zone temperature</td>
</tr>
<tr><td><code>OperativeZoneTemperature</code></td>
    <td>Operative zone temperature</td>
</tr>
<tr><td><code>RelativeHumidity</code></td>
    <td>Relative humidity</td>
</tr>
<tr><td><code>CO2Concentration</code></td>
    <td>CO<sub>2</sub> concentration</td>
</tr>
<tr><td><code>ElectricPower</code></td>
    <td>Electric power from grid</td>
</tr>
<tr><td><code>DistrictHeatingPower</code></td>
    <td>Thermal power from district heating</td>
</tr>
<tr><td><code>GasPower</code></td>
    <td>Thermal power from natural gas</td>
</tr>
<tr><td><code>BiomassPower</code></td>
    <td>Thermal power from biomass</td>
</tr>
<tr><td><code>SolarThermalPower</code></td>
    <td>Thermal power from solar thermal</td>
</tr>
<tr><td><code>FreshWaterFlowRate</code></td>
    <td>FreshWaterFlowRate</td>
</tr>
</table>
</html>",           revisions="<html>
<ul>
<li>
July 17, 2019, by Michael Wetter:<br/>
Added documentation.
</li>
<li>
April 10, 2019, by Javier Arroyo:<br/>
First implementation.
</li>
</ul>
</html>"));
        annotation (Documentation(info="<html>
<p>
Package that defines the the signal types that are used by BOPTEST
to compute the key performance indices.
</p>
</html>"));
        end SignalTypes;
        annotation (Documentation(info="<html>
<p>
Package with blocks that can be used
to identify and activate control signal overwrites, and
to identify and read sensor signals. This package is used
by the Building Optimization Performance Test software
<a href=\"https://github.com/ibpsa/project1-boptest\">BOPTEST</a>.
</p>
</html>",       Icon(graphics={Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,
                    0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-30,10},{-10,-10}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{10,10},{30,-10}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-10,0},{10,0}}, color={0,0,0}),
              Line(
                points={{-60,0},{-30,0}},
                color={0,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{30,0},{60,0}},
                color={0,0,0},
                pattern=LinePattern.Dot),
              Polygon(
                points={{-80,10},{-80,-10},{-60,0},{-80,10}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{60,10},{60,-10},{80,0},{60,10}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)})));
      end SignalExchange;
      annotation (Icon(graphics={Text(
              extent={{-92,72},{84,-66}},
              textColor={0,0,0},
              textString="I/O")}), Documentation(info="<html>
<p>
This package contains models for input and output.
</p>
</html>"));
    end IO;

    package Math "Library with functions such as for smoothing"
      extends Modelica.Icons.Package;

      block IntegratorWithReset "Output the integral of the input signal"
        extends Modelica.Blocks.Interfaces.SISO(y(start=y_start));

        parameter Real k(unit="1")=1 "Integrator gain";

        /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.InitialState
          "Type of initialization (1: no init, 2: steady state, 3,4: initial output)"
          annotation(Evaluate=true,
            Dialog(group="Initialization"));

        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));

        parameter Buildings.Types.Reset reset = Buildings.Types.Reset.Disabled
          "Type of integrator reset";

        parameter Real y_reset = 0
          "Value to which integrator is reset, used if reset = Buildings.Types.Reset.Parameter"
          annotation(Evaluate=true,
                     Dialog(
                       enable=reset == Buildings.Types.Reset.Parameter,
                       group="Integrator reset"));

        Modelica.Blocks.Interfaces.RealInput y_reset_in
          if reset == Buildings.Types.Reset.Input
          "Input signal for state to which integrator is reset, enabled if reset = Buildings.Types.Reset.Input"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

        Modelica.Blocks.Interfaces.BooleanInput trigger
          if reset <> Buildings.Types.Reset.Disabled
          "Resets the integrator output when trigger becomes true"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}}, rotation=90,
              origin={0,-120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={0,-120})));
    protected
        Modelica.Blocks.Interfaces.RealInput y_reset_internal
         "Internal connector for integrator reset"
         annotation(Evaluate=true);

        Modelica.Blocks.Interfaces.BooleanInput trigger_internal
          "Needed to use conditional connector trigger";

      initial equation
        if initType == Modelica.Blocks.Types.Init.SteadyState then
           der(y) = 0;
        elseif initType == Modelica.Blocks.Types.Init.InitialState or
               initType == Modelica.Blocks.Types.Init.InitialOutput then
          y = y_start;
        end if;

      equation
        der(y) = k*u;

        // Equations for integrator reset
        connect(trigger, trigger_internal);
        connect(y_reset_in, y_reset_internal);

        if reset <> Buildings.Types.Reset.Input then
          y_reset_internal = y_reset;
        end if;

        if reset == Buildings.Types.Reset.Disabled then
          trigger_internal = false;
        else
          when trigger_internal then
            reinit(y, y_reset_internal);
          end when;
        end if;

        annotation (
      defaultComponentName="intWitRes",
          Documentation(info="<html>
<p>
This model is similar to
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
except that it optionally allows to reset the output <code>y</code>
of the integrator.
</p>
<p>
The output of the integrator can be reset as follows:
</p>
<ul>
<li>
If <code>reset = Buildings.Types.Reset.Disabled</code>, which is the default,
then the integrator is never reset.
</li>
<li>
If <code>reset = Buildings.Types.Reset.Parameter</code>, then a boolean
input signal <code>trigger</code> is enabled. Whenever the value of
this input changes from <code>false</code> to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the parameter <code>y_reset</code>.
</li>
<li>
If <code>reset = Buildings.Types.Reset.Input</code>, then a boolean
input signal <code>trigger</code> is enabled. Whenever the value of
this input changes from <code>false</code> to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the input signal <code>y_reset_in</code>.
</li>
</ul>
<p>
See <a href=\"modelica://Buildings.Utilities.Math.Examples.IntegratorWithReset\">
Buildings.Utilities.Math.Examples.IntegratorWithReset</a> for an example.
</p>
<h4>Implementation</h4>
<p>
To adjust the icon layer, the code of
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
has been copied into this model rather than extended.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 1, 2016, by Michael Wetter:<br/>
Corrected wrong annotation for <code>y_reset</code>,
and made rendering of <code>y_reset_in</code> conditional.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/562\">#562</a>.
</li>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model to use a <code>type</code> for configuration
of the integrator reset.
</li>
<li>
August 9, 2016, by Michael Wetter:<br/>
Reformulated model using a conditional connector to use the same
design pattern as is used in other models.
</li>
<li>
August 9, 2016, by Michael Wetter:<br/>
Revised model.
</li>
<li>
July 18, 2016, by Philipp Mehrfeld:<br/>
First implementation.
</li>
</ul>
</html>"),
      Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Text(
                  extent={{-88,-94},{212,-54}},
                textColor={0,0,0},
                textString="y_reset_in",
                visible=reset == Buildings.Types.Reset.Input,
                horizontalAlignment=TextAlignment.Left),
              Bitmap(extent={{-54,-50},{60,50}}, fileName=
                    "modelica://Buildings/Resources/Images/Utilities/Math/int.png"),
                Text(
                  extent={{-88,56},{206,92}},
                textColor={0,0,0},
                textString="k=%k",
                horizontalAlignment=TextAlignment.Left),
                Text(
                  extent={{-92,-12},{208,28}},
                textColor={0,0,0},
                horizontalAlignment=TextAlignment.Left,
                textString="u"),
                Text(
                  extent={{70,-14},{370,26}},
                textColor={0,0,0},
                horizontalAlignment=TextAlignment.Left,
                textString="y")}));
      end IntegratorWithReset;

      package Functions "Package with mathematical functions"
        extends Modelica.Icons.VariantsPackage;

        function biquadratic "Biquadratic function"
          extends Modelica.Icons.Function;
         input Real a[6] "Coefficients";
         input Real x1 "Independent variable";
         input Real x2 "Independent variable";
         output Real y "Result";
        algorithm
          y :=a[1] + x1*(a[2] + a[3]*x1) + x2*(a[4]+ a[5]*x2) + a[6]*x1*x2;

          annotation (smoothOrder=999, Documentation(info="<html>
This function computes
<p align=\"center\" style=\"font-style:italic;\">
  y =   a<sub>1</sub> + a<sub>2</sub>  x<sub>1</sub>
        + a<sub>3</sub>  x<sub>1</sub><sup>2</sup>
        + a<sub>4</sub>  x<sub>2</sub> + a<sub>5</sub>  x<sub>2</sub><sup>2</sup>
        + a<sub>6</sub>  x<sub>1</sub>  x<sub>2</sub>
</p>
</html>",         revisions="<html>
<ul>
<li>
Sep 8, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end biquadratic;

        function cubicHermiteLinearExtrapolation
          "Interpolate using a cubic Hermite spline with linear extrapolation"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower gradient";
          input Real y2d "Upper gradient";
          output Real y "Interpolated ordinate value";
        algorithm
          if (x > x1 and x < x2) then
            y:=Modelica.Fluid.Utilities.cubicHermite(
              x=x,
              x1=x1,
              x2=x2,
              y1=y1,
              y2=y2,
              y1d=y1d,
              y2d=y2d);
          elseif x <= x1 then
            // linear extrapolation
            y:=y1 + (x - x1)*y1d;
          else
            y:=y2 + (x - x2)*y2d;
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>x<sub>1</sub> &lt; x &lt; x<sub>2</sub></i>, this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function
linearly extrapolates.
</p>
<p>
For how to use this function, see
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.CubicHermite\">
Buildings.Utilities.Math.Functions.Examples.CubicHermite</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end cubicHermiteLinearExtrapolation;

        function inverseXRegularized
          "Function that approximates 1/x by a twice continuously differentiable function"
          extends Modelica.Icons.Function;
         input Real x "Abscissa value";
         input Real delta(min=Modelica.Constants.eps)
            "Abscissa value below which approximation occurs";
         input Real deltaInv = 1/delta "Inverse value of delta";

         input Real a = -15*deltaInv "Polynomial coefficient";
         input Real b = 119*deltaInv^2 "Polynomial coefficient";
         input Real c = -361*deltaInv^3 "Polynomial coefficient";
         input Real d = 534*deltaInv^4 "Polynomial coefficient";
         input Real e = -380*deltaInv^5 "Polynomial coefficient";
         input Real f = 104*deltaInv^6 "Polynomial coefficient";

         output Real y "Function value";

        algorithm
          y :=if (x > delta or x < -delta) then 1/x elseif (x < delta/2 and x > -delta/2) then x/(delta*delta) else
            Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition(
               x=x,
               delta=delta, deltaInv=deltaInv,
               a=a, b=b, c=c, d=d, e=e, f=f);

          annotation (smoothOrder=2,
          derivative(order=1,
                  zeroDerivative=delta,
                  zeroDerivative=deltaInv,
                  zeroDerivative=a,
                  zeroDerivative=b,
                  zeroDerivative=c,
                  zeroDerivative=d,
                  zeroDerivative=e,
                  zeroDerivative=f)=Buildings.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized,
                      Inline=true,
        Documentation(info="<html>
<p>
Function that approximates <i>y=1 &frasl; x</i>
inside the interval <i>-&delta; &le; x &le; &delta;</i>.
The approximation is twice continuously differentiable with a bounded derivative on the whole
real line.
</p>
<p>
See the plot of
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.InverseXRegularized\">
Buildings.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for the graph.
</p>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Typically, these coefficients only depend on parameters and hence
can be computed once.
They must be equal to their default values, otherwise the function
is not twice continuously differentiable.
By exposing these coefficients as function arguments, models
that call this function can compute them as parameters, and
assign these parameter values in the function call.
This avoids that the coefficients are evaluated for each time step,
as they would otherwise be if they were to be computed inside the
body of the function. However, assigning the values is optional
as otherwise, at the expense of efficiency, the values will be
computed each time the function is invoked.
See
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.InverseXRegularized\">
Buildings.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for how to efficiently call this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 10, 2015, by Michael Wetter:<br/>
Removed dublicate entry <code>smoothOrder = 1</code>
and reimplmented the function so it is twice continuously differentiable.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 18, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end inverseXRegularized;

        function isMonotonic "Returns true if the argument is a monotonic sequence"
          extends Modelica.Icons.Function;
          input Real x[:] "Sequence to be tested";
          input Boolean strict=false "Set to true to test for strict monotonicity";
          output Boolean monotonic "True if x is monotonic increasing or decreasing";
      protected
          Integer n=size(x, 1) "Number of data points";

        algorithm
          if n == 1 then
            monotonic := true;
          else
            monotonic := true;
            if strict then
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] > x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] < x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            else
              // not strict
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] >= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] <= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            end if;
            // strict
          end if;

          annotation (Documentation(info="<html>
<p>
This function returns <code>true</code> if its argument is
monotonic increasing or decreasing, and <code>false</code> otherwise.
If <code>strict=true</code>, then strict monotonicity is tested,
otherwise weak monotonicity is tested.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isMonotonic;

        function regNonZeroPower
          "Power function, regularized near zero, but nonzero value for x=0"
          extends Modelica.Icons.Function;

         input Real x "Abscissa value";
         input Real n(
           min=0.000001,
           max=1.999999) "Exponent";
         input Real delta = 0.01 "Abscissa value where transition occurs";
         output Real y "Function value";
      protected
          Real a1;
          Real a3;
          Real a5;
          Real delta2;
          Real x2;
          Real y_d "=y(delta)";
          Real yP_d "=dy(delta)/dx";
          Real yPP_d "=d^2y(delta)/dx^2";
        algorithm
          if abs(x) > delta then
           y := abs(x)^n;
          else
           delta2 :=delta*delta;
           x2 :=x*x;
           y_d :=delta^n;
           yP_d :=n*delta^(n - 1);
           yPP_d :=n*(n - 1)*delta^(n - 2);
           a1 := -(yP_d/delta - yPP_d)/delta2/8;
           a3 := (yPP_d - 12 * a1 * delta2)/2;
           a5 := (y_d - delta2 * (a3 + delta2 * a1));
           y := a5 + x2 * (a3 + x2 * a1);
           assert(a5 > 0 and 0 < n and n < 2, "Delta is too small for this exponent or n is outside (0, 2).");
          end if;
          annotation (
            Documentation(info="<html>
<p>
Function that approximates <i>y=|x|<sup>n</sup></i> where <i>0 &lt; n &lt; 2</i>
so that
</p>
<ul>
<li><i>y(0)</i> is not equal to zero.</li>
<li><i>dy/dx</i> is bounded and continuous everywhere.</li>
</ul>
<p>
This function replaces <i>y=|x|<sup>n</sup></i> in the interval
<i>-&delta;...+&delta;</i> by a 4-th order polynomial that has the same
function value and the first and second derivative at <i>x=&plusmn; &delta;</i>.
</p>
<p>
A typical use of this function is to replace the
function for the convective heat transfer
coefficient for forced or free convection that is of the form
<i>h=c |dT|<sup>n</sup></i> for some constant <i>c</i> and exponent
<i>0 &lt; n &le; 1</i>.
By using this function, the original function
that has an infinite derivative near zero and that takes on zero
at the origin is replaced by a function with a bounded derivative and
a non-zero value at the origin. Physically,
the region <i>-&delta;...+&delta;</i> may be interpreted as the region
where heat conduction dominates convection in the boundary layer.
</p>
<p>
See the package <code>Examples</code> for the graph.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 2, 2022, by Michael Wetter:<br/>
Set minimum and maximum attribute on <code>n</code>, improved assertion and documentation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3135\">Buildings, #3135</a>.
</li>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 14, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Inline=true,
                   smoothOrder=2,
                   derivative(zeroDerivative=n, zeroDerivative=delta)=BaseClasses.der_regNonZeroPower);
        end regNonZeroPower;

        function regStep
          "Approximation of a general step, such that the approximation is continuous and differentiable"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real y1 "Ordinate value for x > 0";
          input Real y2 "Ordinate value for x < 0";
          input Real x_small(min=0) = 1e-5
            "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
          output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
        algorithm
          y := smooth(1, if x >  x_small then y1 else
                         if x < -x_small then y2 else
                         if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);

          annotation(Inline=true,
          Documentation(revisions="<html>
<ul>
<li><i>February 18, 2016</i>
    by Marcus Fuchs:<br/>
    Add function with <code>Inline = true</code> in annotations to package for better performance,
    as suggested in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a> .</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br/>
    Designed and implemented.</li>
</ul>
</html>",         info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region <code>-x_small &lt; x &lt; x_small</code> a 2nd order polynomial is used
for a smooth transition from <code>y1</code> to <code>y2</code>.
</p>
</html>"));
        end regStep;

        function smoothInterpolation
          "Interpolate using a cubic Hermite spline with linear extrapolation for a vector xSup[], ySup[] and independent variable x"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real xSup[:] "Support points (strictly increasing)";
          input Real ySup[size(xSup,1)] "Function values at xSup";
          input Boolean ensureMonotonicity=isMonotonic(ySup, strict=false)
            "Set to true to ensure monotonicity of the cubic hermite";
          output Real yInt "Interpolated ordinate value";

      protected
          Integer n = size(xSup,1) "Number of support points";
          Real dy_dx[size(xSup,1)] "Derivative at xSup";
          Integer i "Integer to select data interval";
        algorithm
          if n > 2 then
            // Most common case with more than 2 data points.
            // Do cubic spline interpolation.
            dy_dx :=Buildings.Utilities.Math.Functions.splineDerivatives(
              x=xSup,
              y=ySup,
              ensureMonotonicity=ensureMonotonicity);

            // i is a counter that is used to pick the derivative
            // that corresponds to the interval that contains x
            i := 1;
            for j in 1:n-1 loop
              if x > xSup[j] then
                i := j;
               end if;
             end for;
             assert(xSup[i] < xSup[i+1], "Support points xSup must be increasing.");
             yInt:=cubicHermiteLinearExtrapolation(
                x=x,
                x1=xSup[i],
                x2=xSup[i+1],
                y1=ySup[i],
                y2=ySup[i+1],
                y1d=dy_dx[i],
                y2d=dy_dx[i+1]);
          elseif n == 2 then
            // Linear interpolation.
            yInt := ySup[1] + (x - xSup[1]) * (ySup[2] - ySup[1])/(xSup[2] - xSup[1]);
          else // n == 1
            yInt :=ySup[1];
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>xSup<sub>1</sub> &le; x &le; xSup<sub>n</sub></i>,
where <i>n</i> is the size of the support points <i>xSup</i>,
which must be strictly monotonically increasing,
this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function
linearly extrapolates.
</p>
<p>
If <i>n=2</i>, linear interpolation is used an if <i>n=1</i>, the
function value <i>y<sup>1</sup></i> is returned.
</p>
<p>
Note that if <code>xSup</code> and <code>ySup</code> only depend on parameters
or constants, and therefore will not change during the simulation,
it is more efficient to first call
<a href=\"modelica://Buildings.Utilities.Math.Functions.splineDerivatives\">
Buildings.Utilities.Math.Functions.splineDerivatives</a>
to find the derivatives, and then call
<a href=\"modelica://Buildings.Utilities.Math.Functions.interpolate\">
Buildings.Utilities.Math.Functions.interpolate</a> to perform the interpolation.
This way the derivatives only need to be computed once upon initialisation,
not at each step during the simulation.
See the example implemented in
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.Interpolate\">
Buildings.Utilities.Math.Functions.Examples.Interpolate</a>.
</p>
<p>
In contrast to the function
<a href=\"modelica://Modelica.Math.Vectors.interpolate\">
Modelica.Math.Vectors.interpolate</a>
which provides linear interpolation, this function does
not trigger events.
</p>
<p>
For how to use this function, see
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.SmoothInterpolation\">
Buildings.Utilities.Math.Functions.Examples.SmoothInterpolation</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 1, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothInterpolation;

        function smoothMax
          "Once continuously differentiable approximation to the maximum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := Buildings.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x1-x2, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>max(.,.)</code> function.
</p>
<p>
Note that the maximum need not be respected, such as illustrated in
<a href=\"modelica://Buildings.Utilities.Math.Examples.SmoothMin\">
Buildings.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMax;

        function smoothMin
          "Once continuously differentiable approximation to the minimum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := Buildings.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x2-x1, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>min(.,.)</code> function.
</p>
<p>
Note that the minimum need not be respected, such as illustrated in
<a href=\"modelica://Buildings.Utilities.Math.Examples.SmoothMin\">
Buildings.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMin;

        function spliceFunction
          extends Modelica.Icons.Function;
            input Real pos "Argument of x > 0";
            input Real neg "Argument of x < 0";
            input Real x "Independent value";
            input Real deltax "Half width of transition interval";
            output Real out "Smoothed value";
      protected
            constant Real lim = 0.9999999999;
            Real scaledX1;
            Real y;
            constant Real asin1 = Modelica.Math.asin(1);
        algorithm
            scaledX1 := x/deltax;
            if scaledX1 <= -lim then
              out := neg;
            elseif scaledX1 >= lim then
              out := pos;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX1*asin1)) + 1)/2;
              out := pos*y + (1 - y)*neg;
            end if;

            annotation (
        smoothOrder=3,
        derivative=BaseClasses.der_spliceFunction,
        Documentation(info="<html>
<p>
Function to provide a once continuously differentiable transition between
to arguments.
</p><p>
The function is adapted from
<a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">
Modelica.Media.Air.MoistAir.Utilities.spliceFunction</a> and provided here
for easier accessability to model developers.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 27, 2022, by Matthis Thorade:<br/>
Changed limits.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1640\">IBPSA, issue #1640</a>.
</li>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
May 11, 2010, by Michael Wetter:<br/>
Removed default value for transition interval as this is problem dependent.
</li>
<li>
May 20, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end spliceFunction;

        function splineDerivatives
          "Function to compute the derivatives for cubic hermite spline interpolation"
          extends Modelica.Icons.Function;
          input Real x[:] "Support point, strictly increasing";
          input Real y[size(x, 1)] "Function values at x";
          input Boolean ensureMonotonicity=isMonotonic(y, strict=false)
            "Set to true to ensure monotonicity of the cubic hermite";
          output Real d[size(x, 1)] "Derivative at the support points";
      protected
          Integer n=size(x, 1) "Number of data points";
          Real delta[n - 1] "Slope of secant line between data points";
          Real alpha "Coefficient to ensure monotonicity";
          Real beta "Coefficient to ensure monotonicity";
          Real tau "Coefficient to ensure monotonicity";

        algorithm
          if (n>1) then
            assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = "         + String(x[1]) + "
           x["         + String(n) + "] = " + String(x[n]));
          // Check data
            assert(isMonotonic(x, strict=true),
              "x-values must be strictly increasing or decreasing.");
            if ensureMonotonicity then
              assert(isMonotonic(y, strict=false),
                "If ensureMonotonicity=true, y-values must be strictly increasing or decreasing.");
            end if;
          end if;

          // Compute derivatives at the support points
          if n == 1 then
            // only one data point
            d[1] :=0;
          elseif n == 2 then
            // linear function
            d[1] := (y[2] - y[1])/(x[2] - x[1]);
            d[2] := d[1];
          else
            // Slopes of the secant lines between i and i+1
            for i in 1:n - 1 loop
              delta[i] := (y[i + 1] - y[i])/(x[i + 1] - x[i]);
            end for;
            // Initial values for tangents at the support points.
            // End points use one-sided derivatives
            d[1] := delta[1];
            d[n] := delta[n - 1];

            for i in 2:n - 1 loop
              d[i] := (delta[i - 1] + delta[i])/2;
            end for;

          end if;
          // Ensure monotonicity
          if n > 2 and ensureMonotonicity then
            for i in 1:n - 1 loop
              if (abs(delta[i]) < Modelica.Constants.small) then
                d[i] := 0;
                d[i + 1] := 0;
              else
                alpha := d[i]/delta[i];
                beta := d[i + 1]/delta[i];
                // Constrain derivative to ensure monotonicity in this interval
                if (alpha^2 + beta^2) > 9 then
                  tau := 3/(alpha^2 + beta^2)^(1/2);
                  d[i] := delta[i]*alpha*tau;
                  d[i + 1] := delta[i]*beta*tau;
                end if;
              end if;
            end for;
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the derivatives at the support points <i>x<sub>i</sub></i>
that can be used as input for evaluating a cubic hermite spline.
</p>
<p>
If <code>ensureMonotonicity=true</code>, then the support points <i>y<sub>i</sub></i>
need to be monotone increasing (or decreasing), and the computed derivatives
<i>d<sub>i</sub></i> are such that the cubic hermite is monotone increasing (or decreasing).
The algorithm to ensure monotonicity is based on the method described in Fritsch and Carlson (1980) for
<i>&rho; = &rho;<sub>2</sub></i>.
</p>
<p>
This function is typically used with
<a href=\"modelica://Buildings.Utilities.Math.Functions.interpolate\">
Buildings.Utilities.Math.Functions.interpolate</a>
which is used to evaluate the cubic spline.
Because in many applications, the shape of the spline depends on parameters
which will no longer change once the initialisation is complete,
this function computes and returns the derivatives so that they can be stored by the calling
model to avoid repetitive computations.
</p>
<h4>References</h4>
<p>
F.N. Fritsch and R.E. Carlson, <a href=\"http://dx.doi.org/10.1137/0717021\">Monotone piecewise cubic interpolation</a>.
<i>SIAM J. Numer. Anal.</i>, 17 (1980), pp. 238-246.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 26, 2016 by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
September 29, 2011 by Michael Wetter:<br/>
Added special case for one data point and two data points.
</li>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end splineDerivatives;

        package BaseClasses
        "Package with base classes for Buildings.Utilities.Math.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_2_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           input Real der_2_x;
           output Real der_2_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_2_y := n*(abs(x)^(n-1)*sign(x)*der_2_x
                        + (n-1)*abs(x)^(n-2)*der_x^2);
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;

             der_2_y := (12*a1*x2+2*a3)*der_x^2
                        +x * ( 4 * a1 * x2 + 2 * a3)*der_2_x;
            end if;
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the second derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.regNonZeroPower\">
Buildings.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
August 17, 2015 by Michael Wetter:<br/>
Corrected wrong derivative implementation which omitted the <code>der_x</code> term.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/303\">issue 303</a>.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_regNonZeroPower;

          function der_2_smoothTransition
            "Second order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";

            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";

            input Real x_der "Derivative of x";
            input Real x_der2 "Second order derivative of x";
            output Real y_der2 "Second order derivative of function value";
        protected
            Real aX "Absolute value of x";
            Real ex "Intermediate expression";
          algorithm
           aX:= abs(x);
           ex     := 2*c + aX*(6*d + aX*(12*e + aX*20*f));
           y_der2 := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der2
                   + x_der*x_der*( if x > 0 then ex else -ex);

          annotation (
          Documentation(info="<html>
<p>
This function is the 2nd order derivative of
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_smoothTransition;

          function der_inverseXRegularized "Derivative of inverseXRegularised function"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
           input Real deltaInv = 1/delta "Inverse value of delta";

           input Real a = -15*deltaInv "Polynomial coefficient";
           input Real b = 119*deltaInv^2 "Polynomial coefficient";
           input Real c = -361*deltaInv^3 "Polynomial coefficient";
           input Real d = 534*deltaInv^4 "Polynomial coefficient";
           input Real e = -380*deltaInv^5 "Polynomial coefficient";
           input Real f = 104*deltaInv^6 "Polynomial coefficient";

           input Real x_der "Abscissa value";
           output Real y_der "Function value";

          algorithm
            y_der :=if (x > delta or x < -delta) then -x_der/x/x elseif (x < delta/2 and x > -delta/2) then x_der/(delta*delta) else
              Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition(
                 x=x,
                 x_der=x_der,
                 delta=delta,
                 deltaInv=deltaInv,
                 a=a, b=b, c=c, d=d, e=e, f=f);
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.inverseXRegularized\">
Buildings.Utilities.Math.Functions.inverseXRegularized</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
June 22, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_inverseXRegularized;

          function der_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           output Real der_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_y := sign(x)*n*abs(x)^(n-1)*der_x;
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;
             der_y := x * ( 4 * a1 * x * x + 2 * a3) * der_x;
            end if;
           annotation(derivative(order=2, zeroDerivative=n, zeroDerivative=delta)=der_2_regNonZeroPower,
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.regNonZeroPower\">
Buildings.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
August 17, 2015 by Michael Wetter:<br/>
Corrected wrong derivative implementation which omitted the <code>der_x</code> term.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/303\">issue 303</a>.
</li>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_regNonZeroPower;

          function der_smoothTransition
            "First order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";

            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";

            input Real x_der "Derivative of x";
            output Real y_der "Derivative of function value";

        protected
            Real aX "Absolute value of x";
          algorithm
           aX:= abs(x);
           y_der := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der;
           annotation(smoothOrder=1,
                    derivative(order=2,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition,
          Documentation(info="<html>
<p>
This function is the 1st order derivative of
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
its derivative is provided in
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_smoothTransition;

          function der_spliceFunction "Derivative of splice function"
            extends Modelica.Icons.Function;
            input Real pos;
            input Real neg;
            input Real x;
            input Real deltax=1;
            input Real dpos;
            input Real dneg;
            input Real dx;
            input Real ddeltax=0;
            output Real out;
        protected
            constant Real lim = 0.9999999999 "Limit in criterion for smoothing range";
            Real scaledX1 "x scaled to -1 ... 1 interval";
            Real scaledXp "x scaled to -pi/2 ... pi/2 interval";
            Real scaledXt "x scaled to -inf ... inf interval";
            Real dscaledX1;
            Real y;
          algorithm
            scaledX1 := x/deltax;
            if scaledX1 <= -lim then
              y := 0.0;
            elseif scaledX1 >= lim then
              y := 1.0;
            else
              scaledXp := scaledX1*0.5*Modelica.Constants.pi;
              scaledXt := Modelica.Math.tan(scaledXp);
              y := 0.5*Modelica.Math.tanh(scaledXt) + 0.5;
            end if;
            out := dpos*y + (1 - y)*dneg;

            if (abs(scaledX1) < lim) then
              dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
              out := out + (pos - neg)*dscaledX1*0.25*Modelica.Constants.pi*(1 - Modelica.Math.tanh(scaledXt)^2)*(scaledXt^2 + 1);
            end if;

          annotation (
            smoothOrder=2,
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.spliceFunction\">
Buildings.Utilities.Math.Functions.spliceFunction</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
September 27, 2022, by Matthis Thorade:<br/>
Changed limits.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1640\">IBPSA, issue #1640</a>.
</li>
<li>
October 13, 2021, by Michael Wetter:<br/>
Changed implementation to not use <code>cosh</code> which overflows around <i>800</i>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1531\">IBPSA, issue 1531</a>.
</li>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 7, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_spliceFunction;

          function smoothTransition
            "Twice continuously differentiable transition between the regions"
            extends Modelica.Icons.Function;

            // The function that transitions between the regions is implemented
            // using its own function. This allows Dymola 2016 to inline the function
            // inverseXRegularized.

          input Real x "Abscissa value";
          input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
          input Real deltaInv = 1/delta "Inverse value of delta";

          input Real a = -15*deltaInv "Polynomial coefficient";
          input Real b = 119*deltaInv^2 "Polynomial coefficient";
          input Real c = -361*deltaInv^3 "Polynomial coefficient";
          input Real d = 534*deltaInv^4 "Polynomial coefficient";
          input Real e = -380*deltaInv^5 "Polynomial coefficient";
          input Real f = 104*deltaInv^6 "Polynomial coefficient";
          output Real y "Function value";
        protected
            Real aX "Absolute value of x";

          algorithm
           aX:= abs(x);
           y := (if x >= 0 then 1 else -1) * (a + aX*(b + aX*(c + aX*(d + aX*(e + aX*f)))));
          annotation(smoothOrder=2,
            derivative(order=1,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition,
              Documentation(info="<html>
<p>
This function is used by
<a href=\"modelica://Buildings.Utilities.Math.Functions.inverseXRegularized\">
Buildings.Utilities.Math.Functions.inverseXRegularized</a>
to provide a twice continuously differentiable transition between
the different regions.
The code has been implemented in a function as this allows
to implement the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.inverseXRegularized\">
Buildings.Utilities.Math.Functions.inverseXRegularized</a>
in such a way that Dymola inlines it.
However, this function will not be inlined as its body is too large.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
derivatives are provided in
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition</a>
and in
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 12, 2018, by David Blum:<br/>
Change if-statement to if-expression.  
For issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1019\">#1019</a>.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end smoothTransition;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Math.Functions\">Buildings.Utilities.Math.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for commonly used
mathematical operations. The functions are used in
the blocks
<a href=\"modelica://Buildings.Utilities.Math\">
Buildings.Utilities.Math</a>.
</p>
</html>"));
      end Functions;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for commonly used
mathematical operations.
The classes in this package augment the classes
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</p>
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
              {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
                {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
                -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
                -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
                {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
                0,0,0}, smooth=Smooth.Bezier)}));
    end Math;

    package Psychrometrics "Library with psychrometric functions"
      extends Modelica.Icons.VariantsPackage;

      package Constants "Library of constants for psychometric functions"
        extends Modelica.Icons.Package;

        constant Modelica.Units.SI.Temperature T_ref=273.15
          "Reference temperature for psychrometric calculations";

        constant Modelica.Units.SI.SpecificHeatCapacity cpAir=1006
          "Specific heat capacity of air";

        constant Modelica.Units.SI.SpecificHeatCapacity cpSte=1860
          "Specific heat capacity of water vapor";

        constant Modelica.Units.SI.SpecificHeatCapacity cpWatLiq=4184
          "Specific heat capacity of liquid water";

        constant Modelica.Units.SI.SpecificEnthalpy h_fg=2501014.5
          "Enthalpy of evaporation of water at the reference temperature";
        annotation (
          Documentation(info="<html>
<p>
This package provides constants for functions used
in the calculation of thermodynamic properties of moist air.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Added reference temperature.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
            Polygon(
              origin={-9.2597,25.6673},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={-19.9923,-8.3993},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={23.753,-11.5422},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
              smooth=Smooth.Bezier)}));
      end Constants;

      block TWetBul_TDryBulPhi
        "Model to compute the wet bulb temperature based on relative humidity"
        extends Modelica.Blocks.Icons.Block;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialCondensingGases "Medium model"
          annotation (choicesAllMatching = true);

        parameter Boolean approximateWetBulb=false
          "Set to true to approximate wet bulb temperature" annotation (Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          start=Medium.T_default,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,70},{-100,90}})));

        Modelica.Blocks.Interfaces.RealInput phi(min=0, max=1)
          "Relative air humidity"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));

        Modelica.Blocks.Interfaces.RealInput p(final quantity="Pressure",
                                               final unit="Pa",
                                               min = 0) "Pressure"
          annotation (Placement(transformation(extent={{-120,-90},{-100,-70}})));

        Modelica.Blocks.Interfaces.RealOutput TWetBul(
          start=Medium.T_default-2,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Wet bulb temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        // Modelica.Math.atan returns a value with unit set to "rad".
        // The following constant is used to satisfy the unit check.
    protected
        constant Real uniCon1(final unit="1/rad") = 1 "Constant to satisfy unit check";
        constant Real uniConK(final unit="K/rad") = 1 "Constant to satisfy unit check";

        Modelica.Units.NonSI.Temperature_degC TDryBul_degC
          "Dry bulb temperature in degree Celsius";
        Real rh_per(min=0) "Relative humidity in percentage";
        Modelica.Units.SI.MassFraction XiDryBul
          "Water vapor mass fraction at dry bulb state";
        Modelica.Units.SI.MassFraction XiSat
          "Water vapor mass fraction at saturation";
        Modelica.Units.SI.MassFraction XiSatRefIn
          "Water vapor mass fraction at saturation, referenced to inlet mass flow rate";

      equation
        if approximateWetBulb then
          TDryBul_degC = TDryBul - 273.15;
          rh_per       = 100*phi;
          TWetBul      = 273.15 + uniCon1 * TDryBul_degC
             * Modelica.Math.atan(0.151977 * sqrt(rh_per + 8.313659))
             + uniConK * (Modelica.Math.atan(TDryBul_degC + rh_per)
               - Modelica.Math.atan(rh_per-1.676331)
               + 0.00391838 * rh_per^(1.5) * Modelica.Math.atan( 0.023101 * rh_per))
             - 4.686035;
          XiSat    = 0;
          XiDryBul = 0;
          XiSatRefIn=0;
        else
          XiSatRefIn=(1-XiDryBul)*XiSat/(1-XiSat);
          XiSat  = Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
            pSat = Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TWetBul),
            p =    p,
            phi =  1);
          XiDryBul =Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
            p =    p,
            pSat = Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TDryBul),
            phi =  phi);
          (TWetBul-Buildings.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-XiDryBul) * Buildings.Utilities.Psychrometrics.Constants.cpAir +
                    XiSatRefIn * Buildings.Utilities.Psychrometrics.Constants.cpSte +
                    (XiDryBul-XiSatRefIn) * Buildings.Utilities.Psychrometrics.Constants.cpWatLiq)
          =
          (TDryBul-Buildings.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-XiDryBul) * Buildings.Utilities.Psychrometrics.Constants.cpAir +
                    XiDryBul * Buildings.Utilities.Psychrometrics.Constants.cpSte)  +
          (XiDryBul-XiSatRefIn) * Buildings.Utilities.Psychrometrics.Constants.h_fg;

          TDryBul_degC = 0;
          rh_per       = 0;
        end if;

      annotation (
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-92,100},{-62,56}},
                textColor={0,0,127},
                textString="TDryBul"),
              Text(
                extent={{-92,14},{-72,-12}},
                textColor={0,0,127},
                textString="phi"),
              Text(
                extent={{-90,-72},{-72,-90}},
                textColor={0,0,127},
                textString="p"),
              Text(
                extent={{62,22},{92,-22}},
                textColor={0,0,127},
                textString="TWetBul"),
              Line(points={{78,-74},{-48,-74}}),
              Text(
                extent={{76,-78},{86,-94}},
                textColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Line(
                points={{76,-46},{26,-4}},
                color={255,0,0},
                thickness=0.5),
              Line(points={{-48,-48},{-2,-30},{28,-4},{48,32},{52,72}},
                color={0,0,0},
                smooth=Smooth.Bezier),
              Line(points={{-48,84},{-48,-74}}),
              Text(
                extent={{-44,82},{-22,64}},
                textColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Polygon(
                points={{86,-74},{76,-72},{76,-76},{86,-74}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-48,88},{-46,74},{-50,74},{-48,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          defaultComponentName="wetBul",
          Documentation(info="<html>
<p>
This block computes the wet bulb temperature for a given dry bulb temperature, relative air humidity
and atmospheric pressure.
</p>
<p>
If the constant <code>approximateWetBulb</code> is <code>true</code>,
then the block uses the approximation of Stull (2011) to compute
the wet bulb temperature without requiring a nonlinear equation.
Otherwise, the model will introduce one nonlinear equation.
The approximation by Stull is valid for a relative humidity of <i>5%</i> to <i>99%</i>,
a temperature range from <i>-20</i>&deg;C to <i>50</i>&deg;C
and standard sea level pressure.
For this range of data, the approximation error is <i>-1</i> Kelvin to <i>+0.65</i> Kelvin,
with a mean error of less than <i>0.3</i> Kelvin.
</p>
<p>
Otherwise a calculation based on an energy balance is used.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a> for a discussion.
The model is validated in
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Examples.TWetBul_TDryBulPhi\">
Buildings.Utilities.Psychrometrics.Examples.TWetBul_TDryBulPhi</a>.
</p>
<p>
For a model that takes the mass fraction instead of the relative humidity as an input, see
<a href=\"modelica://Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi\">
Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi</a>.
</p>
<h4>References</h4>
<p>
Stull, Roland.
<i><a href=\"http://dx.doi.org/10.1175/JAMC-D-11-0143.1\">
Wet-Bulb Temperature from Relative Humidity and Air Temperature
Roland Stull.</a></i>
Journal of Applied Meteorology and Climatology.
Volume 50, Issue 11, pp. 2267-2269. November 2011
DOI: 10.1175/JAMC-D-11-0143.1
</p>
</html>",
      revisions="<html>
<ul>
<li>
March 6, 2023, by Michael Wetter:<br/>
Added a constant in order for unit check to pass.<br/>
See  <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1711\">#1711</a>
for a discussion.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Changed icon.
</li>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Corrected exact implementation.
See  <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a>
for a discussion.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
Updated model to use
<code>Buildings.Utilities.Psychrometrics.Functions.saturationPressure()</code>
and
<code>Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid()</code>
as these functions have been moved from the medium to the psychrometrics package.
</li>
<li>
October 1, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TWetBul_TDryBulPhi;

      package Functions "Package with psychrometric functions"
        extends Modelica.Icons.Package;

        function X_pSatpphi "Humidity ratio for given water vapor pressure"
          extends Modelica.Icons.Function;
          input Modelica.Units.SI.AbsolutePressure pSat "Saturation pressure";
          input Modelica.Units.SI.Pressure p "Pressure of the fluid";
          input Real phi(min=0, max=1) "Relative humidity";
          output Modelica.Units.SI.MassFraction X_w(
            min=0,
            max=1,
            nominal=0.01) "Water vapor concentration per total mass of air";

      protected
          constant Real k = 0.621964713077499 "Ratio of molar masses";
        algorithm
          X_w := phi*k/(k*phi+p/pSat-phi);

          annotation (
            smoothOrder=99,
            Inline=true,
            Documentation(info="<html>
<p>
Function to compute the water vapor concentration based on
saturation pressure, absolute pressure and relative humidity.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 21, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end X_pSatpphi;

        function saturationPressure
          "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"
          extends Modelica.Icons.Function;
          input Modelica.Units.SI.Temperature TSat(displayUnit="degC", nominal=300)
            "Saturation temperature";
          output Modelica.Units.SI.AbsolutePressure pSat(displayUnit="Pa", nominal=1000)
            "Saturation pressure";

        algorithm
          pSat := Buildings.Utilities.Math.Functions.regStep(
                     y1=Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TSat),
                     y2=Buildings.Utilities.Psychrometrics.Functions.sublimationPressureIce(TSat),
                     x=TSat-273.16,
                     x_small=1.0);
          annotation(Inline=true,
            smoothOrder=1,
            Documentation(info="<html>
<p>
Saturation pressure of water, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
August 19, 2015 by Michael Wetter:<br/>
Changed <code>smoothOrder</code> from <i>5</i> to <i>1</i> as
<a href=\"modelica://Buildings.Utilities.Math.Functions.spliceFunction\">
Buildings.Utilities.Math.Functions.spliceFunction</a> is only once
continuously differentiable.
Inlined the function.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressure;

        function saturationPressureLiquid
          "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"
          extends Modelica.Icons.Function;
          input Modelica.Units.SI.Temperature TSat(displayUnit="degC", nominal=300)
            "Saturation temperature";
          output Modelica.Units.SI.AbsolutePressure pSat(displayUnit="Pa", nominal=1000)
            "Saturation pressure";
        algorithm
          pSat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(TSat - 35.719));

          annotation (
            smoothOrder=99,
            derivative=Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid,
            Inline=true,
            Documentation(info="<html>
<p>
Saturation pressure of water above the triple point temperature computed from temperature
according to Wagner <i>et al.</i> (1993). The range of validity is between
<i>273.16</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressureLiquid;

        function sublimationPressureIce
          "Return sublimation pressure of water as a function of temperature T between 190 and 273.16 K"
          extends Modelica.Icons.Function;
          input Modelica.Units.SI.Temperature TSat(displayUnit="degC", nominal=300)
            "Saturation temperature";
          output Modelica.Units.SI.AbsolutePressure pSat(displayUnit="Pa", nominal=1000)
            "Saturation pressure";
      protected
          Modelica.Units.SI.Temperature TTriple=273.16 "Triple point temperature";
          Modelica.Units.SI.AbsolutePressure pTriple=611.657 "Triple point pressure";
          Real r1=TSat/TTriple "Common subexpression";
          Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
          Real n[2]={-1.5,-1.25} "Coefficients n[:]";
        algorithm
          pSat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple;
          annotation (
            Inline=false,
            smoothOrder=5,
            derivative=Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_sublimationPressureIce,
            Documentation(info="<html>
<p>
Sublimation pressure of water below the triple point temperature, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>273.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
        end sublimationPressureIce;

        package BaseClasses
        "Package with base classes for Buildings.Utilities.Psychrometrics.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_saturationPressureLiquid
            "Derivative of the function saturationPressureLiquid"
            extends Modelica.Icons.Function;
            input Modelica.Units.SI.Temperature TSat "Saturation temperature";
            input Real dTSat(unit="K/s") "Saturation temperature derivative";
            output Real psat_der(unit="Pa/s") "Differential of saturation pressure";

          algorithm
            psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99
                      /(TSat - 35.719))*4102.99*dTSat/(TSat - 35.719)^2;

            annotation(Inline=false,
              smoothOrder=98,
              Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid\">
Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
September 12, 2020, by Michael Wetter:<br/>
Corrected name of argument to comply with derivative specification.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1393\">#1393</a>.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
          end der_saturationPressureLiquid;

          function der_sublimationPressureIce
            "Derivative of function sublimationPressureIce"
              extends Modelica.Icons.Function;
            input Modelica.Units.SI.Temperature TSat(displayUnit="degC", nominal=300)
              "Saturation temperature";
              input Real dTSat(unit="K/s") "Sublimation temperature derivative";
              output Real psat_der(unit="Pa/s") "Sublimation pressure derivative";
        protected
            Modelica.Units.SI.Temperature TTriple=273.16 "Triple point temperature";
            Modelica.Units.SI.AbsolutePressure pTriple=611.657 "Triple point pressure";
              Real r1=TSat/TTriple "Common subexpression 1";
              Real r1_der=dTSat/TTriple "Derivative of common subexpression 1";
              Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
              Real n[2]={-1.5,-1.25} "Coefficients n[:]";
          algorithm
              psat_der := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple*(-(a[1]
                *(r1^(n[1] - 1)*n[1]*r1_der)) - (a[2]*(r1^(n[2] - 1)*n[2]*r1_der)));
              annotation (
                Inline=false,
                smoothOrder=5,
                Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.sublimationPressureIce\">
Buildings.Utilities.Psychrometrics.Functions.sublimationPressureIce</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
September 12, 2020, by Michael Wetter:<br/>
Change name of argument <code>dTsat</code> to <code>dTSat</code> for consistency
with
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid\">
Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid</a>.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
          end der_sublimationPressureIce;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions\">Buildings.Utilities.Psychrometrics.Functions</a>.
</p>
</html>"));
        end BaseClasses;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for psychrometric calculations.
</p>

The nomenclature used in this package is described at
<a href=\"modelica://Buildings.UsersGuide.Conventions\">
Buildings.UsersGuide.Conventions</a>.
</html>"));
      end Functions;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for psychrometric calculations.
</p>
<p>
The nomenclature used in this package is described at
<a href=\"modelica://Buildings.UsersGuide.Conventions\">
Buildings.UsersGuide.Conventions</a>.
</p>
</html>"));
    end Psychrometrics;

    package Time "Package with models for time"
      extends Modelica.Icons.Package;

      block ModelTime "Model time"
        extends Modelica.Blocks.Icons.Block;

        Modelica.Blocks.Interfaces.RealOutput y "Model time"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = time;

        annotation (
          defaultComponentName="modTim",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(points={{0,80},{0,60}}, color={160,160,164}),
              Line(points={{80,0},{60,0}}, color={160,160,164}),
              Line(points={{0,-80},{0,-60}}, color={160,160,164}),
              Line(points={{-80,0},{-60,0}}, color={160,160,164}),
              Line(points={{37,70},{26,50}}, color={160,160,164}),
              Line(points={{70,38},{49,26}}, color={160,160,164}),
              Line(points={{71,-37},{52,-27}}, color={160,160,164}),
              Line(points={{39,-70},{29,-51}}, color={160,160,164}),
              Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
              Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
              Line(points={{-71,37},{-54,28}}, color={160,160,164}),
              Line(points={{-38,70},{-28,51}}, color={160,160,164}),
              Line(
                points={{0,0},{-50,50}},
                thickness=0.5),
              Line(
                points={{0,0},{40,0}},
                thickness=0.5)}),
          Documentation(info="<html>
<p>
This component outputs the model time, which starts at the value at which the simulation starts.
For example, if a simulation starts at <i>t=-1</i>, then this block outputs first <i>t=-1</i>,
and its output is advanced at the same rate as the simulation time.
</p>
<p>
The model is used to allow the simulation to start from any time without having to set
the parameters for the clock, as would be necessary for the model
<a href=\"modelica://Modelica.Blocks.Sources.ContinuousClock\">Modelica.Blocks.Sources.ContinuousClock</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 2, 2022, by Michael Wetter:<br/>
Corrected hyperlink in documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1609\">IBPSA, #1609</a>.
</li>
<li>
April 17, 2020, by Michael Wetter:<br/>
Refactored so that the output connector has a better comment string, because
this comment string is displayed on the weather data bus.
</li>
<li>
January 16, 2015, by Michael Wetter:<br/>
Moved block from
<code>Buildings.Utilities.SimulationTime</code>
to
<code>Buildings.Utilities.Time.ModelTime</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ModelTime;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models for time.
</p>
</html>"),
      Icon(graphics={
            Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Line(points={{0,80},{0,60}}, color={160,160,164}),
            Line(points={{80,0},{60,0}}, color={160,160,164}),
            Line(points={{0,-80},{0,-60}}, color={160,160,164}),
            Line(points={{-80,0},{-60,0}}, color={160,160,164}),
            Line(points={{37,70},{26,50}}, color={160,160,164}),
            Line(points={{70,38},{49,26}}, color={160,160,164}),
            Line(points={{71,-37},{52,-27}}, color={160,160,164}),
            Line(points={{39,-70},{29,-51}}, color={160,160,164}),
            Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
            Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
            Line(points={{-71,37},{-54,28}}, color={160,160,164}),
            Line(points={{-38,70},{-28,51}}, color={160,160,164}),
            Line(
              points={{0,0},{-50,50}},
              thickness=0.5),
            Line(
              points={{0,0},{40,0}},
              thickness=0.5)}));
    end Time;
  annotation (
  preferredView="info", Documentation(info="<html>
<p>
This package contains utility models such as for thermal comfort calculation, input/output, co-simulation, psychrometric calculations and various functions that are used throughout the library.
</p>
</html>"),
  Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
  end Utilities;

  package Types "Package with type definitions"
    extends Modelica.Icons.TypesPackage;

    type Reset = enumeration(
      Disabled   "Disabled",
      Parameter   "Use parameter value",
      Input   "Use input signal")
      "Options for integrator reset"
      annotation (
      Documentation(info="<html>
<p>
Enumeration to define the choice of integrator reset
(to be selected via choices menu):
</p>
<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td>Disabled</td>
<td>
Use this setting to disable the integrator reset.
</td></tr>
<tr><td>Parameter</td>
<td>
Use this setting to use reset the integrator to the value of the parameter.
</td></tr>
<tr><td>Input</td>
<td>Use this setting to reset the integrator to the value obtained
from the input signal.
</td></tr>
 </table>
</html>",   revisions="<html>
<ul>
<li>
September 29, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>",   revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
  end Types;

  package Examples
  "Collection of models that illustrate model use and test models"
    extends Modelica.Icons.ExamplesPackage;

    package ChillerPlant
    "Chiller plant with water side economizer for data center"
    extends Modelica.Icons.ExamplesPackage;

      package BaseClasses
      "Package with base classes for Buildings.Examples.ChillerPlant"
      extends Modelica.Icons.BasesPackage;

        model SimplifiedRoom "Simplified data center room"
          extends Buildings.BaseClasses.BaseIcon;
          replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
            "Medium model";
          parameter Integer nPorts=0 "Number of parts" annotation (Evaluate=true,
              Dialog(
              connectorSizing=true,
              tab="General",
              group="Ports"));
          parameter Modelica.Units.SI.Length rooLen "Length of the room";
          parameter Modelica.Units.SI.Length rooWid "Width of the room";
          parameter Modelica.Units.SI.Height rooHei "Height of the room";
          parameter Modelica.Units.SI.Power QRoo_flow
            "Heat generation of the computer room";

          Buildings.Fluid.MixingVolumes.MixingVolume rooVol(
            redeclare package Medium = Medium,
            nPorts=nPorts,
            V=rooLen*rooWid*rooHei,
            m_flow_nominal=m_flow_nominal,
            energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
            final T_start=293.15,
            final prescribedHeatFlowRate=true) "Volume of air in the room" annotation (Placement(
                transformation(extent={{41,-40},{61,-20}})));
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b airPorts[nPorts](
              redeclare each package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(
                extent={{-38,-12},{38,12}},
                rotation=180,
                origin={0,-100}), iconTransformation(
                extent={{-40.5,-13},{40.5,13}},
                rotation=180,
                origin={4.5,-87})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow QSou
            "Heat source of the room"
            annotation (Placement(transformation(extent={{-18,-40},{2,-20}})));
          Modelica.Blocks.Sources.Ramp ramp(
            height=QRoo_flow,
            offset=0,
            duration=36000,
            startTime=0)
            annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
          parameter Modelica.Units.SI.MassFlowRate m_flow_nominal
            "Nominal mass flow rate";
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor TAir
            "Room air temperature"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          Modelica.Blocks.Interfaces.RealOutput TRooAir(unit="K", displayUnit="degC")
            "Room air temperature" annotation (Placement(transformation(extent={{100,-10},
                    {120,10}}), iconTransformation(extent={{100,-10},{120,10}})));
        equation
          connect(rooVol.ports, airPorts) annotation (Line(
              points={{51,-40},{52,-40},{52,-80},{0,-80},{0,-100}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(QSou.port, rooVol.heatPort) annotation (Line(
              points={{2,-30},{41,-30}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(ramp.y, QSou.Q_flow) annotation (Line(
              points={{-39,-30},{-18,-30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(TAir.port, rooVol.heatPort) annotation (Line(points={{40,0},{30,0},{
                  30,-30},{41,-30}}, color={191,0,0}));
          connect(TAir.T, TRooAir) annotation (Line(points={{60,0},{76,0},{110,0}},
                       color={0,0,127}));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineThickness=1)}),
            Documentation(info="<html>
<p>
This is a simplified room model for a data center. There is no heat exchange between the room and ambient environment through the building envelope since it is negligible compared to the heat released by the servers.
</p></html>",         revisions="<html>
<ul>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added <code>prescribedHeatFlowRate=false</code> for both volumes.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> of the Annex 60 library.
</li>
<li>
July 21, 2011 by Wangda Zuo:<br/>
Merge to library.
</li>
<li>
December 10, 2010 by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end SimplifiedRoom;

        package Controls
        "Package with control components for Buildings.Examples.ChillerPlant"
        extends Modelica.Icons.VariantsPackage;

          block ChillerSwitch "Control unit for enabling/disabling chiller"
            extends Modelica.Blocks.Icons.Block;
            Modelica.Blocks.Interfaces.RealInput chiCHWST(
              final quantity="ThermodynamicTemperature",
              final unit="K")
              "Chiller chilled water supply temperature (water entering chiller)"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}}),
                  iconTransformation(extent={{-120,60},{-100,80}})));
            Modelica.Blocks.Interfaces.BooleanOutput y
              "Control signal for chiller. 1: Enable, 0: Disable" annotation (Placement(
                  transformation(extent={{100,-22},{144,22}}), iconTransformation(extent=
                      {{100,-16},{120,4}})));
            Modelica.Blocks.Interfaces.RealInput TSet(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              displayUnit="degC") "Set temperature of chiller" annotation (Placement(
                  transformation(extent={{-140,-80},{-100,-40}}), iconTransformation(
                    extent={{-120,-60},{-100,-40}})));
            parameter Modelica.Units.SI.Temperature deaBan
              "Dead band of temperature to prevent chiller short cycling";
            Modelica.Blocks.Logical.Hysteresis hysteresis(uLow=0, uHigh=deaBan)
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            Modelica.Blocks.Math.Add add(k1=+1, k2=-1)
              annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
          equation
            connect(hysteresis.y, y) annotation (Line(
                points={{41,6.10623e-16},{52.5,6.10623e-16},{52.5,1.11022e-16},{122,
                    1.11022e-16}},
                color={255,0,255},
                smooth=Smooth.None));

            connect(chiCHWST, add.u1) annotation (Line(
                points={{-120,60},{-80,60},{-80,6},{-42,6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(TSet, add.u2) annotation (Line(
                points={{-120,-60},{-80,-60},{-80,-6},{-42,-6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add.y, hysteresis.u) annotation (Line(
                points={{-19,6.10623e-16},{-1.5,6.10623e-16},{-1.5,6.66134e-16},{18,
                    6.66134e-16}},
                color={0,0,127},
                smooth=Smooth.None));

            annotation (
              defaultComponentName="chiSwi",
              Documentation(info="<html>
The controls for enabling/disabling chiller are as follows:
<ul>
<li>
The chiller is enabled when
<p align=\"left\" style=\"font-style:italic;\">
  T<sub>Chi_CHWST</sub> &gt; T<sub>ChiSet</sub> + T<sub>DeaBan</sub> </p>
  </li>
<li>
The chiller is disabled when
<p align=\"left\" style=\"font-style:italic;\">
  T<sub>Chi_CHWST</sub> &le; T<sub>ChiSet</sub></p>
</li>
</ul>
where <i>T<sub>Chi_CHWST</sub></i> is chiller chilled water supply temperature, <i>T<sub>ChiSet</sub></i> is set temperature for chilled water leaving chiller, and <i>T<sub>DeaBan</sub></i> is dead band to prevent short cycling.
</html>",           revisions="<html>
<ul>
<li>
July 20, 2011, by Wangda Zuo:<br/>
Add comments, change variable names, and merge to library.
</li>
<li>
January 18, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul></html>"),
              Icon(graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Polygon(
                    points={{-78,94},{-86,72},{-70,72},{-78,94}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-78,72},{-78,-25}}, color={192,192,192}),
                  Polygon(
                    points={{94,-25},{72,-17},{72,-33},{94,-25}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-77,-25},{86,-25}}, color={192,192,192}),
                  Line(points={{-77,-25},{43,-25}}, color={0,0,0}),
                  Line(points={{-13,-17},{3,-25},{-13,-32}}, color={0,0,0}),
                  Line(points={{43,55},{43,-25}}, color={0,0,0}),
                  Line(points={{35,7},{43,26},{52,7}}, color={0,0,0}),
                  Line(points={{-47,55},{83,55}}, color={0,0,0}),
                  Line(points={{-2,63},{-17,55},{-2,47}}, color={0,0,0}),
                  Line(points={{-57,33},{-47,15},{-37,33}}, color={0,0,0}),
                  Line(points={{-47,55},{-47,-25}}, color={0,0,0}),
                  Text(
                    extent={{-90,-45},{-7,-88}},
                    textColor={192,192,192},
                    textString="%uLow"),
                  Text(
                    extent={{4,-45},{93,-88}},
                    textColor={192,192,192},
                    textString="%uHigh"),
                  Rectangle(extent={{-89,-45},{-6,-88}}, lineColor={192,192,192}),
                  Line(points={{-47,-25},{-47,-45}}, color={192,192,192}),
                  Rectangle(extent={{4,-45},{93,-88}}, lineColor={192,192,192}),
                  Line(points={{43,-25},{43,-45}}, color={192,192,192})}));
          end ChillerSwitch;

          block LinearPiecewiseTwo "A two-pieces linear piecewise function"
            extends Modelica.Blocks.Icons.Block;
            parameter Real x0 "First interval [x0, x1]";
            parameter Real x1 "First interval [x0, x1] and second interval (x1, x2]";
            parameter Real x2 "Second interval (x1, x2]";
            parameter Real y10 "y[1] at u = x0";
            parameter Real y11 "y[1] at u = x1";
            parameter Real y20 "y[2] at u = x1";
            parameter Real y21 "y[2] at u = x2";
            Modelica.Blocks.Interfaces.RealInput u "Set point" annotation (
            extent={{-190,80},{-150,120}}, Placement(transformation(extent={{-140,-20},{-100,20}})));
            Modelica.Blocks.Interfaces.RealOutput y[2] "Connectors of Real output signal"
              annotation (Placement(transformation(extent={{
                      100,-12},{120,8}})));
            Buildings.Controls.SetPoints.Table y1Tab(table=[x0, y10; x1, y11; x2, y11])
              "Table for y[1]"
              annotation (Placement(transformation(extent={{-40,20},{-20,40}})));
            Buildings.Controls.SetPoints.Table y2Tab(table=[x0, y20; x1, y20; x2, y21])
              "Table for y[2]"
              annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
          equation
            connect(u, y1Tab.u) annotation (Line(
                points={{-120,1.11022e-15},{-58,1.11022e-15},{-58,30},{-42,30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(u, y2Tab.u) annotation (Line(
                points={{-120,1.11022e-15},{-58,1.11022e-15},{-58,-30},{-42,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(y1Tab.y, y[1]) annotation (Line(
                points={{-19,30},{26,30},{26,-7},{110,-7}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(y2Tab.y, y[2]) annotation (Line(
                points={{-19,-30},{42,-30},{42,3},{110,3}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              defaultComponentName="linPieTwo",
              Documentation(info="<HTML>
<p>
This component calcuates the output according to two piecewise linear function as
</p>
<table>
<tr>
<td>
<i>x<sub>0</sub> &le; u &le; x<sub>1</sub>:</i></td>
    <td><i>y<sub>1</sub> = y<sub>10</sub> + u (y<sub>11</sub>-y<sub>10</sub>)/(x<sub>1</sub>-x<sub>0</sub>)</i><br/>
        <i>y<sub>2</sub> = y<sub>20</sub></i></td>
</tr>
<tr>
<td><i>x<sub>1</sub> &lt; u &le; x<sub>2</sub>:</i></td>
    <td><i>y<sub>1</sub> = y<sub>11</sub></i><br/>
    <i>y<sub>2</sub> = y<sub>20</sub> + (u-x<sub>1</sub>)
       (y<sub>21</sub>-y<sub>20</sub>)/(x<sub>2</sub>-x<sub>1</sub>)</i></td>
</tr>
</table>
</HTML>",           revisions="<html>
<ul>
<li>
July 20, 2011, by Wangda Zuo:<br/>
Add comments and merge to library.
</li>
<li>
January 18, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Line(
                    points={{-68,62},{-68,-50},{62,-50}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.Filled,Arrow.Filled}),
                  Line(
                    points={{46,-50},{46,62}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    arrow={Arrow.None,Arrow.Filled}),
                  Text(
                    extent={{-52,6},{-42,-2}},
                    textColor={0,0,0},
                    textString="y[1]"),
                  Text(
                    extent={{24,6},{34,-2}},
                    textColor={128,0,255},
                    textString="y[2]",
                    lineThickness=1),
                  Text(
                    extent={{-74,-52},{-64,-60}},
                    textColor={0,0,0},
                    textString="x0"),
                  Text(
                    extent={{-18,-52},{-8,-60}},
                    textColor={0,0,0},
                    textString="x1"),
                  Text(
                    extent={{40,-52},{50,-60}},
                    textColor={0,0,0},
                    textString="x2"),
                  Text(
                    extent={{-80,-38},{-70,-46}},
                    textColor={0,0,0},
                    textString="y10"),
                  Text(
                    extent={{-80,34},{-68,26}},
                    textColor={0,0,0},
                    textString="y11"),
                  Text(
                    extent={{48,50},{60,42}},
                    textColor={128,0,255},
                    textString="y21"),
                  Text(
                    extent={{48,-32},{58,-40}},
                    textColor={128,0,255},
                    textString="y20",
                    lineThickness=1),
                  Line(
                    points={{-68,-42},{-14,30},{46,30}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=1),
                  Line(
                    points={{-68,44},{-14,44},{46,-36}},
                    color={128,0,255},
                    thickness=1,
                    smooth=Smooth.None),
                  Line(
                    points={{-14,44},{-14,-50}},
                    color={175,175,175},
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Line(
                    points={{-68,30},{-14,30}},
                    color={175,175,175},
                    pattern=LinePattern.Dash,
                    smooth=Smooth.None),
                  Line(
                    points={{-14,44},{46,44}},
                    color={175,175,175},
                    pattern=LinePattern.Dash,
                    smooth=Smooth.None),
                  Text(
                    extent={{62,-46},{72,-54}},
                    textColor={0,0,0},
                    textString="x")}));
          end LinearPiecewiseTwo;

          block TrimAndRespondContinuousTimeApproximation "Trim and respond logic"
            extends Modelica.Blocks.Interfaces.SISO;

            Buildings.Controls.Continuous.LimPID conPID(
              Td=1,
              yMax=1,
              yMin=0,
              reverseActing=false,
              Ti=120,
              k=0.1)     annotation (Placement(transformation(extent={{-20,40},{0,60}})));
            Modelica.Blocks.Sources.Constant const(k=0)
              annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          equation
            connect(const.y, conPID.u_s) annotation (Line(
                points={{-39,50},{-22,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(conPID.y, y) annotation (Line(
                points={{1,50},{76,50},{76,4.44089e-16},{110,4.44089e-16}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(u, conPID.u_m) annotation (Line(
                points={{-120,0},{-10,0},{-10,38}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              defaultComponentName="triAndRes",
              Documentation(info="<html>
<p>
   This model implements a continuous time approximation to the trim and respond
   control algorithm.
</p>
   </html>",           revisions="<html>
<ul>
<li>
December 5, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end TrimAndRespondContinuousTimeApproximation;

          model WSEControl "Control unit for WSE"
            parameter Modelica.Units.SI.TemperatureDifference dTOff=1
              "Temperature difference to switch WSE off";
            parameter Modelica.Units.SI.TemperatureDifference dTW=1
              "Temperature difference that is added to WSE on guard";
            Modelica.Blocks.Interfaces.RealInput wseCHWST(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              displayUnit="degC")
              "WSE chilled water supply temperature (water entering WSE)" annotation (
                Placement(transformation(extent={{-60,100},{-20,140}}),
                  iconTransformation(extent={{-60,100},{-20,140}})));
            Modelica.Blocks.Interfaces.RealOutput y2
              "Control signal for chiller shutoff valve"    annotation (Placement(
                  transformation(extent={{180,-50},{200,-30}}),
                                                              iconTransformation(extent={{180,-50},
                      {200,-30}})));
            Modelica.Blocks.Interfaces.RealInput TWetBul(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              displayUnit="degC") "Wet bulb temperature" annotation (Placement(
                  transformation(extent={{-60,0},{-20,40}}),    iconTransformation(extent={{-60,0},
                      {-20,40}})));
            Modelica.Blocks.Interfaces.RealInput towTApp(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              displayUnit="degC") "Cooling tower approach"
              annotation (Placement(transformation(extent={{-60,-60},{-20,-20}})));
            Modelica.Blocks.Interfaces.RealInput wseCWST(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              displayUnit="degC")
              "WSE condenser water supply temperature (water entering WSE)" annotation (
               Placement(transformation(extent={{-60,-138},{-20,-98}}),
                  iconTransformation(extent={{-60,-138},{-20,-98}})));
            Modelica.Blocks.Math.BooleanToReal booToRea2
              annotation (Placement(transformation(extent={{140,-50},{160,-30}})));
            Modelica.Blocks.Interfaces.RealOutput y1
              "Control signal for WSE shutoff valve"           annotation (Placement(
                  transformation(extent={{180,30},{200,50}}),   iconTransformation(extent={{180,30},
                      {200,50}})));
            Modelica.StateGraph.InitialStepWithSignal off(
              nOut=1,
              nIn=1) annotation (Placement(transformation(extent={{-2,78},{22,102}})));
            Modelica.StateGraph.Transition T1(
              waitTime=1200,
              condition=wseCHWST > 0.9*TWetBul + towTApp + dTW,
              enableTimer=true)
              annotation (Placement(transformation(extent={{32,72},{68,108}})));
            Modelica.StateGraph.Step  on(nIn=1, nOut=1)
              annotation (Placement(transformation(extent={{80,80},{100,100}})));
            Modelica.StateGraph.Transition  T2(
               waitTime=1200,
              condition=wseCHWST < wseCWST + dTOff,
              enableTimer=true)
              annotation (Placement(transformation(extent={{122,72},{158,108}})));
            Modelica.Blocks.Math.BooleanToReal booToRea1(realTrue=0, realFalse=1)
              annotation (Placement(transformation(extent={{140,30},{160,50}})));
            inner Modelica.StateGraph.StateGraphRoot stateGraphRoot
              "Root of the state graph"
              annotation (Placement(transformation(extent={{0,140},{20,160}})));
          equation

            connect(booToRea2.y, y2)
                                    annotation (Line(
                points={{161,-40},{190,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(off.outPort[1], T1.inPort)   annotation (Line(
                points={{22.6,90},{42.8,90}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(T1.outPort, on.inPort[1])    annotation (Line(
                points={{52.7,90},{79,90}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(on.outPort[1], T2.inPort)    annotation (Line(
                points={{100.5,90},{132.8,90}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(T2.outPort, off.inPort[1])   annotation (Line(
                points={{142.7,90},{168,90},{168,130},{-12,130},{-12,90},{-3.2,90}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(booToRea1.y, y1) annotation (Line(
                points={{161,40},{190,40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(off.active, booToRea1.u)
              annotation (Line(points={{10,76.8},{10,40},{138,40}}, color={255,0,255}));
            connect(off.active, booToRea2.u) annotation (Line(points={{10,76.8},{10,-40},{
                    138,-40}}, color={255,0,255}));
            annotation (
              defaultComponentName="wseCon",
              Icon(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-20,-160},{180,180}},
                  initialScale=0.04), graphics={
                  Rectangle(
                    extent={{-20,-160},{180,180}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{232,246},{-88,338}},
                    textColor={0,0,255},
                    textString="%name")}),
              Documentation(info="<html>
<p>
This component decides if the WSE is set to on or off.
The WSE is enabled when
</p>
<ol>
<li>The WSE has been disabled for at least 20 minutes, and</li>
<li>
<i>
  T<sub>WSE_CHWST</sub> &gt; 0.9 T<sub>WetBul</sub> + T<sub>TowApp</sub> + T<sub>WSEApp</sub>
</i>
</li>
</ol>
<p>
The WSE is disabled when
</p>
<ol>
<li>The WSE has been enabled for at least 20 minutes, and</li>
<li>
<i>
  T<sub>WSE_CHWRT</sub> &lt; 1 + T<sub>WSE_CWST</sub>
</i>
</li>
</ol>
<p>
where <i>T<sub>WSE_CHWST</sub></i> is the chilled water supply temperature for the WSE,
<i>T<sub>WetBul</sub></i> is the wet bulb temperature, <i>T<sub>TowApp</sub></i> is the cooling tower approach, <i>T<sub>WSEApp</sub></i> is the approach for the WSE, <i>T<sub>WSE_CHWRT</sub></i> is the chilled water return temperature for the WSE, and <i>T<sub>WSE_CWST</sub></i> is the condenser water return temperature for the WSE.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 6, 2016, by Michael Wetter:<br/>
Replaced <code>Modelica_StateGraph2</code> with <code>Modelica.StateGraph</code>.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/504\">issue 504</a>.
</li>
<li>
April 1, 2013, by Wangda Zuo:<br/>
Added <code>final</code> attribute to initial state declaration.
This is required for a successful model check in Dymola 2014 using the pedantic check.
</li>
<li>
September 12, 2011, by Wangda Zuo:<br/>
Deleted the first order continuous block and changed the model to use SI units.
</li>
<li>
July 20, 2011, by Wangda Zuo:<br/>
Added comments, redefined variables names, and merged to library.
</li>
<li>
January 18, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul></html>"),
              Diagram(coordinateSystem(extent={{-20,-160},{180,180}}, preserveAspectRatio=false)));
          end WSEControl;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models that are used to construct the control system in
<a href=\"modelica://Buildings.Examples.ChillerPlant\">Buildings.Examples.ChillerPlant</a>.
</p>
</html>"));
        end Controls;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Examples.ChillerPlant\">Buildings.Examples.ChillerPlant</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<h4>System Configuration</h4>
<p>This example demonstrates the implementation of a chiller plant with water-side economizer (WSE) to cool a data center.
The system schematics is as shown below.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Examples/ChillerPlant/chillerSchematics.png\" border=\"1\"/>
</p>
<p>
The system is a primary-only chiller plant with integrated WSE.
The objective was to improve the energy efficiency of the chilled water plant by optimizing the control setpoints.
The room of the data center was modeled using a mixed air volume with a heat source.
Heat conduction and air infiltration through the building envelope were neglected since the heat exchange between the room and the ambient environment was small compared to the heat released by the computers.
</p>
<p>
The control objective was to maintain the temperature of the supply air to the room, while reducing energy consumption of the chilled water plant.
The control was based on the control sequence proposed by Stein (2009).
To simplify the implementation, we only applied the controls for the differential pressure of the chilled water loop, the setpoint temperature of the chilled water leaving the chiller, and the chiller and WSE on/off control.
</p>
<h4>Enabling/Disabling the WSE</h4>
<p>
The WSE is enabled when
</p>
<ol>
<li>The WSE has been disabled for at least 20 minutes, and</li>
<li>
<i>
  T<sub>ws</sub> &gt; 0.9 T<sub>wet</sub> + &Delta;T<sub>t</sub> + &Delta;T<sub>w</sub>
</i>
</li>
</ol>
<p>
where <i>T<sub>ws</sub></i> is the temperature of chilled water leaving the cooling coil,
<i>T<sub>wet</sub></i> is the wet bulb temperature,
<i>&Delta;T<sub>t</sub></i> is the temperature difference between the water leaving the cooling tower and the air entering the cooling tower,
<i>&Delta;T<sub>w</sub></i> is the temperature difference between the chilled water leaving the WSE and the condenser water entering the WSE.
</p>
<p>
The WSE is disabled when
</p>
<ol>
<li>The WSE has been enabled for at least 20 minutes, and</li>
<li><i>
  T<sub>ws</sub> &lt; T<sub>wc</sub> + &Delta;T<sub>wse,off</sub>
</i>
</li>
</ol>
<p>
where <i>T<sub>wc</sub></i> is the temperature of condenser water leaving the cooling tower,  <i>&Delta;T<sub>wse,off</sub> = 0.6 K</i> is the offset temperature.
</p>
<h4>Enabling/Disabling the Chiller</h4>
<p>
The control strategy is as follows:
</p>
<ul>
<li>The chiller is enabled when
<i>
  T<sub>chw,ent</sub> &gt; T<sub>chi,set</sub> + &Delta;T<sub>chi,ban</sub> </i>
</li>
<li>The chiller is disabled when
<i>
  T<sub>chw,ent</sub> &le; T<sub>chi,set</sub></i>
</li>
</ul>
<p>
where <i>T<sub>chw,ent</sub></i> is the tempearture of chilled water entering the chiller, <i>T<sub>chi,set</sub></i> is the setpoint temperature of the chilled water leaving the chiller, and <i>&Delta;T<sub>chi,ban</sub></i> is the dead-band to prevent short cycling.
</p>
<h4>Setpoint Reset</h4>
<p>
The setpoint reset strategy is to first increase the different pressure, <i>&Delta;p</i>, of the chilled water loop to increase the mass flow rate.
If <i>&Delta;p</i> reaches the maximum value and further cooling is still needed, the chiller temperature setpoint, <i>T<sub>chi,set</sub></i>, is reduced.
If there is too much cooling, the <i>T<sub>chi,set</sub></i> and <i>&Delta;p</i>  will be changed in the reverse direction.
</p>
<p>
There are two implementations for the setpoint reset.
</p>
<p>
The model
<a href=\"modelica://Buildings.Examples.ChillerPlant.DataCenterDiscreteTimeControl\">
Buildings.Examples.ChillerPlant.DataCenterDiscreteTimeControl</a>
implements a discrete time trim and respond logic as follows:
</p>
<ul>
<li>A cooling request is triggered if the input signal, <i>y</i>, is larger than 0.
<i>y</i> is the difference between the actual and set temperature of the suppuly air to the data center room.</li>
<li>The request is sampled every 2 minutes. If there is a cooling request, the control signal <i>u</i> is increased by <i>0.03</i>, where <i>0 &le; u &le; 1</i>.
If there is no cooling request,  <i>u</i> is decreased by <i>0.03</i>. </li>
</ul>
<p>
The model
<a href=\"modelica://Buildings.Examples.ChillerPlant.DataCenterContinuousTimeControl\">
Buildings.Examples.ChillerPlant.DataCenterContinuousTimeControl</a> uses a PI-controller to
approximate the above trim and respond logic. This significantly reduces computing time.
</p>
<p>
For both models, the control signal <i>u</i> is converted to setpoints for <i>&Delta;p</i> and <i>T<sub>chi,set</sub></i> as follows:
</p>
<ul>
<li>
If <i>0 &le; u &le; x</i> then <i>&Delta;p = &Delta;p<sub>min</sub> + u &nbsp;(&Delta;p<sub>max</sub>-&Delta;p<sub>min</sub>)/x</i>
and <i>T = T<sub>max</sub></i></li>
<li>
If <i> x &lt; u &le; 1</i> then <i>&Delta;p = &Delta;p<sub>max</sub></i>
and
<i>T = T<sub>max</sub> - (u-x)&nbsp;(T<sub>max</sub>-T<sub>min</sub>)/(1-x)
</i></li>
</ul>
<p>
where <i>&Delta;p<sub>min</sub></i> and <i>&Delta;p<sub>max</sub></i> are minimum and maximum values for <i>&Delta;p</i>,
and <i>T<sub>min</sub></i> and <i>T<sub>max</sub></i> are the minimum and maximum values for <i>T<sub>chi,set</sub></i>.
</p>
<h4>Reference</h4>
<p>
Stein, J. (2009). Waterside Economizing in Data Centers: Design and Control Considerations. ASHRAE Transactions, 115(2), 192-200.<br/>
Taylor, S.T. (2007). Increasing Efficiency with VAV System Static Pressure Setpoint Reset. ASHRAE Journal, June, 24-32.
</p>
</html>"));
    end ChillerPlant;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples and tutorials with step-by-step instructions
for how to build system models.
</p>
<p>
The examples illustrate
the scope of the library. Smaller examples that typically only
use models from a few packages can be found in the individual packages.
For example, see
<a href=\"modelica://Buildings.Airflow.Multizone.Examples\">
Buildings.Airflow.Multizone.Examples</a> for examples of
multizone airflow and contaminant transport models, or
<a href=\"modelica://Buildings.Fluid.HeatExchangers.Examples\">
Buildings.Fluid.HeatExchangers.Examples</a> for
examples of heat exchanger models.
</p>
</html>"));
  end Examples;

  package BaseClasses "Package with base classes for the Buildings library"
    extends Modelica.Icons.BasesPackage;

    block BaseIcon "Base icon"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Text(
              extent={{-46,158},{52,110}},
              textColor={0,0,255},
              textString="%name")}),
    Documentation(
    info="<html>
<p>
Basic class that provides a label with the component name above the icon.
</p>
</html>",
    revisions="<html>
<ul>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end BaseIcon;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings\">Buildings</a>.
</p>
</html>"));
  end BaseClasses;

  package Obsolete
  "Classes that are obsolete and will be removed in later versions"
    extends Modelica.Icons.Package;

    package Controls "Package with obsolete models for controls"
      extends Modelica.Icons.VariantsPackage;

      package OBC "Package with obsolete blocks and control sequences"
        extends Modelica.Icons.VariantsPackage;

        package CDL
        "Package with obsolete blocks for control description language"

          package Continuous
          "Package with obsolete models of the Control Description Language"
            extends Modelica.Icons.Package;

            block Add "Output the sum of the two inputs"
              extends Modelica.Icons.ObsoleteModel;

              parameter Real k1=+1
                "Gain for input u1";
              parameter Real k2=+1
                "Gain for input u2";
              Buildings.Controls.OBC.CDL.Interfaces.RealInput u1
                "Connector of Real input signal 1"
                annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput u2
                "Connector of Real input signal 2"
                annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
                "Connector of Real output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=k1*u1+k2*u2;
              annotation (
                defaultComponentName="add2",
                obsolete = "This model is obsolete",
                Documentation(
                  info="<html>
<p>
Block that outputs <code>y</code> as the weighted <i>sum</i> of the
two input signals <code>u1</code> and <code>u2</code>,
</p>
<pre>
    y = k1*u1 + k2*u2;
</pre>
<p>
where <code>k1</code> and <code>k2</code> are parameters.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),      Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}),
                  graphics={
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Ellipse(
                      lineColor={0,0,127},
                      extent={{-50,-50},{50,50}},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      textColor={0,0,255}),
                    Line(
                      points={{-100,60},{-74,24},{-44,24}},
                      color={0,0,127}),
                    Line(
                      points={{-100,-60},{-74,-28},{-42,-28}},
                      color={0,0,127}),
                    Line(
                      points={{50,0},{100,0}},
                      color={0,0,127}),
                    Text(
                      extent={{-40,-22},{36,46}},
                      textString="+"),
                    Text(
                      extent={{-100,52},{5,92}},
                      textString="%k1"),
                    Text(
                      extent={{-100,-92},{5,-52}},
                      textString="%k2"),
                    Text(
                      extent={{226,60},{106,10}},
                      textColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftJustified=false,
                        significantDigits=3)))}));
            end Add;

            block AddParameter "Output the sum of an input plus a parameter"
              extends Modelica.Icons.ObsoleteModel;

              parameter Real p
                "Value to be added";
              parameter Real k
                "Gain of input";
              Buildings.Controls.OBC.CDL.Interfaces.RealInput u
                "Connector of Real input signal"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
                "Connector of Real output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=k*u+p;
              annotation (
                defaultComponentName="addPar",
                obsolete = "This model is obsolete",
                Documentation(
                  info="<html>
<p>
Block that outputs <code>y = k u + p</code>,
where <code>k</code> and <code>p</code> are
parameters and <code>u</code> is an input.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),      Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}),
                  graphics={
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      textColor={0,0,255},
                      extent={{-150,110},{150,150}},
                      textString="%name"),
                    Line(
                      points={{-54,66},{-28,30},{2,30}},
                      color={0,0,127}),
                    Line(
                      points={{-100,0},{100,0}},
                      color={0,0,127}),
                    Text(
                      extent={{-122,58},{-17,98}},
                      textString="%p",
                      textColor={0,0,0}),
                    Polygon(
                      points={{-86,-36},{-86,36},{-34,0},{-86,-36}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-196,-84},{104,-44}},
                      textColor={0,0,0},
                      textString="k=%k"),
                    Ellipse(
                      lineColor={0,0,127},
                      extent={{-12,-52},{88,48}},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-2,-22},{74,46}},
                      textString="+"),
                    Text(
                      extent={{226,60},{106,10}},
                      textColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftJustified=false,
                        significantDigits=3)))}));
            end AddParameter;

            block Feedback
              "Output difference between commanded and feedback input"
              extends Modelica.Icons.ObsoleteModel;

              Buildings.Controls.OBC.CDL.Interfaces.RealInput u1
                "Connector of Real input signal 1"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput u2
                "Connector of Real input signal 2"
                annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                    rotation=90, origin={0,-120})));
              Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
                "Connector of Real output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=u1-u2;
              annotation (
                defaultComponentName="feedback",
                Documentation(
                  info="<html>
<p>
Block that outputs <code>y = u1 - u2</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),      Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}),
                  graphics={
                    Ellipse(
                      lineColor={0,0,127},
                      fillColor={235,235,235},
                      fillPattern=FillPattern.Solid,
                      extent={{-20,-20},{20,20}}),
                    Line(
                      points={{-100,0},{-20,0}},
                      color={0,0,127}),
                    Line(
                      points={{20,0},{100,0}},
                      color={0,0,127}),
                    Line(
                      points={{0,-20},{0,-100}},
                      color={0,0,127}),
                    Text(
                      extent={{-14,-112},{74,-38}},
                      textString="-"),
                    Text(
                      textColor={0,0,255},
                      extent={{-150,48},{150,98}},
                      textString="%name"),
                    Text(
                      extent={{-100,-4},{-40,56}},
                      textString="+",
                      textColor={0,0,0}),
                    Text(
                      extent={{226,60},{106,10}},
                      textColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftJustified=false,
                        significantDigits=3)))}));
            end Feedback;
          annotation (preferredView="info",
          Documentation(info="<html>
<p>
Package that contains obsolete components that were part of the
OpenBuildingControl (OBC) package
<a href=\"modelica://Buildings.Controls.OBC.CDL.Reals\">
Buildings.Controls.OBC.CDL.Reals</a>.
</p>
</html>"));
          end Continuous;
        annotation (
        Documentation(info="<html>
<p>
Package that contains obsolete elementary input-output blocks that were part of
the Control Description Language (CDL).
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Ellipse(
                  origin={10.0,10.0},
                  fillColor={76,76,76},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{-80.0,-80.0},{-20.0,-20.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{0.0,-80.0},{60.0,-20.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{0.0,0.0},{60.0,60.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  lineColor={128,128,128},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  extent={{-80.0,0.0},{-20.0,60.0}})}));
        end CDL;
      annotation (
      Documentation(info="<html>
<p>
Package that contains obsolete components that were part of the
OpenBuildingControl (OBC) library.
</p>
</html>"));
      end OBC;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains obsolete models for controls.
</p>
</html>"));
    end Controls;
  annotation (Documentation(info="<html>
<p>
This package contains classes that are obsolete and will be removed from the
corresponding library in a future release.
</p>
</html>"));
  end Obsolete;
annotation (
preferredView="info",
version="11.0.0",
versionDate="2024-04-09",
dateModified="2024-04-09",
uses(Modelica(version="4.0.0")),
conversion(
  from(
    version={"10.0.0", "10.1.0"},
    script="modelica://Buildings/Resources/Scripts/Conversion/ConvertBuildings_from_10_to_11.0.0.mos"),
  from(
    version={"9.0.0", "9.1.0", "9.1.1", "9.1.2"},
    script="modelica://Buildings/Resources/Scripts/Conversion/ConvertBuildings_from_9_to_10.0.0.mos"),
  from(
    version={"8.0.0", "8.1.0", "8.1.1", "8.1.2", "8.1.3"},
    to="9.0.0",
    script="modelica://Buildings/Resources/Scripts/Conversion/ConvertBuildings_from_8_to_9.0.0.mos")),
preferredView="info",
Documentation(info="<html>
<p>
The <code>Buildings</code> library is a free library
for modeling building energy and control systems.
Many models are based on models from the package
<code>Modelica.Fluid</code> and use
the same ports to ensure compatibility with the Modelica Standard
Library.
</p>
<p>
The figure below shows a section of the schematic view of the model
<a href=\"modelica://Buildings.Examples.HydronicHeating\">
Buildings.Examples.HydronicHeating</a>.
In the lower part of the figure, there is a dynamic model of a boiler, a pump and a stratified energy storage tank. Based on the temperatures of the storage tank, a finite state machine switches the boiler and its pump on and off.
The heat distribution is done using a hydronic heating system with a three way valve and a pump with variable revolutions. The upper right hand corner shows a room model that is connected to a radiator whose flow is controlled by a thermostatic valve.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/UsersGuide/HydronicHeating.png\" border=\"1\"/>
</p>
<p>
The web page for this library is
<a href=\"http://simulationresearch.lbl.gov/modelica\">http://simulationresearch.lbl.gov/modelica</a>,
and the development page is
<a href=\"https://github.com/lbl-srg/modelica-buildings\">https://github.com/lbl-srg/modelica-buildings</a>.
Contributions to further advance the library are welcomed.
Contributions may not only be in the form of model development, but also
through model use, model testing,
requirements definition or providing feedback regarding the model applicability
to solve specific problems.
</p>
</html>"));
end Buildings;

package Modelica "Modelica Standard Library - Version 4.0.0"
extends Modelica.Icons.Package;

  package Blocks
  "Library of basic input/output control blocks (continuous, discrete, logical, table blocks)"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;

    package Continuous
    "Library of continuous control blocks with internal states"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

      block Integrator "Output the integral of the input signal with optional reset"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Integrator gain";
        parameter Boolean use_reset = false "= true, if reset port enabled"
          annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
        parameter Boolean use_set = false "= true, if set port enabled and used as reinitialization value when reset"
          annotation(Dialog(enable=use_reset), Evaluate=true, HideResult=true, choices(checkBox=true));

        /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
        parameter Init initType=Init.InitialState
          "Type of initialization (1: no init, 2: steady state, 3,4: initial output)" annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        extends Interfaces.SISO(y(start=y_start));
        Modelica.Blocks.Interfaces.BooleanInput reset if use_reset "Optional connector of reset signal" annotation(Placement(
          transformation(
            extent={{-20,-20},{20,20}},
            rotation=90,
            origin={60,-120})));
        Modelica.Blocks.Interfaces.RealInput set if use_reset and use_set "Optional connector of set signal" annotation(Placement(
          transformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={60,120})));
    protected
        Modelica.Blocks.Interfaces.BooleanOutput local_reset annotation(HideResult=true);
        Modelica.Blocks.Interfaces.RealOutput local_set annotation(HideResult=true);

      initial equation
        if initType == Init.SteadyState then
           der(y) = 0;
        elseif initType == Init.InitialState or
               initType == Init.InitialOutput then
          y = y_start;
        end if;
      equation
        if use_reset then
          connect(reset, local_reset);
          if use_set then
            connect(set, local_set);
          else
            local_set = y_start;
          end if;
          when local_reset then
            reinit(y, local_set);
          end when;
        else
          local_reset = false;
          local_set = 0;
        end if;
        der(y) = k*u;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as
<em>integral</em> of the input <strong>u</strong> multiplied with
the gain <em>k</em>:
</p>
<blockquote><pre>
    k
y = - u
    s
</pre></blockquote>

<p>
It might be difficult to initialize the integrator in steady state.
This is discussed in the description of package
<a href=\"modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
</p>

<p>
If the <em>reset</em> port is enabled, then the output <strong>y</strong> is reset to <em>set</em>
or to <em>y_start</em> (if the <em>set</em> port is not enabled), whenever the <em>reset</em>
port has a rising edge.
</p>
</html>"),     Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Line(
                  points={{-80.0,78.0},{-80.0,-90.0}},
                  color={192,192,192}),
                Polygon(
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
                Line(
                  points={{-90.0,-80.0},{82.0,-80.0}},
                  color={192,192,192}),
                Polygon(
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
                Text(
                  textColor={192,192,192},
                  extent={{0.0,-70.0},{60.0,-10.0}},
                  textString="I"),
                Text(
                  extent={{-150.0,-150.0},{150.0,-110.0}},
                  textString="k=%k"),
                Line(
                  points=DynamicSelect({{-80.0,-80.0},{80.0,80.0}}, if use_reset then {{-80.0,-80.0},{60.0,60.0},{60.0,-80.0},{80.0,-60.0}} else {{-80.0,-80.0},{80.0,80.0}}),
                  color={0,0,127}),
                Line(
                  visible=use_reset,
                  points={{60,-100},{60,-80}},
                  color={255,0,255},
                  pattern=LinePattern.Dot),
                Text(
                  visible=use_reset,
                  extent={{-28,-62},{94,-86}},
                  textString="reset")}));
      end Integrator;

      block Derivative "Approximated derivative block"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Gains";
        parameter SI.Time T(min=Modelica.Constants.small) = 0.01
          "Time constants (T>0 required; T=0 is ideal derivative block)";
        parameter Init initType=Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                                                                          annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real x_start=0 "Initial or guess value of state"
          annotation (Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial value of output (= state)"
          annotation(Dialog(enable=initType == Init.InitialOutput, group=
                "Initialization"));
        extends Interfaces.SISO;

        output Real x(start=x_start) "State of block";

    protected
        parameter Boolean zeroGain = abs(k) < Modelica.Constants.eps;
      initial equation
        if initType == Init.SteadyState then
          der(x) = 0;
        elseif initType == Init.InitialState then
          x = x_start;
        elseif initType == Init.InitialOutput then
          if zeroGain then
             x = u;
          else
             y = y_start;
          end if;
        end if;
      equation
        der(x) = if zeroGain then 0 else (u - x)/T;
        y = if zeroGain then 0 else (k/T)*(u - x);
        annotation (
          Documentation(info="<html>
<p>
This blocks defines the transfer function between the
input u and the output y
as <em>approximated derivative</em>:
</p>
<blockquote><pre>
        k * s
y = ------------ * u
       T * s + 1
</pre></blockquote>
<p>
If you would like to be able to change easily between different
transfer functions (FirstOrder, SecondOrder, ... ) by changing
parameters, use the general block <strong>TransferFunction</strong> instead
and model a derivative block with parameters<br>
b = {k,0}, a = {T, 1}.
</p>

<p>
If k=0, the block reduces to y=0.
</p>
</html>"),     Icon(
          coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-80.0,78.0},{-80.0,-90.0}},
            color={192,192,192}),
        Polygon(lineColor={192,192,192},
          fillColor={192,192,192},
          fillPattern=FillPattern.Solid,
          points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
        Line(points={{-90.0,-80.0},{82.0,-80.0}},
          color={192,192,192}),
        Polygon(lineColor={192,192,192},
          fillColor={192,192,192},
          fillPattern=FillPattern.Solid,
          points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
        Line(origin = {-24.667,-27.333},
          points = {{-55.333,87.333},{-19.333,-40.667},{86.667,-52.667}},
          color = {0,0,127},
          smooth = Smooth.Bezier),
        Text(textColor={192,192,192},
          extent={{-30.0,14.0},{86.0,60.0}},
          textString="DT1"),
        Text(extent={{-150.0,-150.0},{150.0,-110.0}},
          textString="k=%k")}));
      end Derivative;
      annotation (
        Documentation(info="<html>
<p>
This package contains basic <strong>continuous</strong> input/output blocks
described by differential equations.
</p>

<p>
All blocks of this package can be initialized in different
ways controlled by parameter <strong>initType</strong>. The possible
values of initType are defined in
<a href=\"modelica://Modelica.Blocks.Types.Init\">Modelica.Blocks.Types.Init</a>:
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>Name</strong></td>
      <td><strong>Description</strong></td></tr>

  <tr><td><strong>Init.NoInit</strong></td>
      <td>no initialization (start values are used as guess values with fixed=false)</td></tr>

  <tr><td><strong>Init.SteadyState</strong></td>
      <td>steady state initialization (derivatives of states are zero)</td></tr>

  <tr><td><strong>Init.InitialState</strong></td>
      <td>Initialization with initial states</td></tr>

  <tr><td><strong>Init.InitialOutput</strong></td>
      <td>Initialization with initial outputs (and steady state of the states if possible)</td></tr>
</table>

<p>
For backward compatibility reasons the default of all blocks is
<strong>Init.NoInit</strong>, with the exception of Integrator and LimIntegrator
where the default is <strong>Init.InitialState</strong> (this was the initialization
defined in version 2.2 of the Modelica standard library).
</p>

<p>
In many cases, the most useful initial condition is
<strong>Init.SteadyState</strong> because initial transients are then no longer
present. The drawback is that in combination with a non-linear
plant, non-linear algebraic equations occur that might be
difficult to solve if appropriate guess values for the
iteration variables are not provided (i.e., start values with fixed=false).
However, it is often already useful to just initialize
the linear blocks from the Continuous blocks library in SteadyState.
This is uncritical, because only linear algebraic equations occur.
If Init.NoInit is set, then the start values for the states are
interpreted as <strong>guess</strong> values and are propagated to the
states with fixed=<strong>false</strong>.
</p>

<p>
Note, initialization with Init.SteadyState is usually difficult
for a block that contains an integrator
(Integrator, LimIntegrator, PI, PID, LimPID).
This is due to the basic equation of an integrator:
</p>

<blockquote><pre>
<strong>initial equation</strong>
   <strong>der</strong>(y) = 0;   // Init.SteadyState
<strong>equation</strong>
   <strong>der</strong>(y) = k*u;
</pre></blockquote>

<p>
The steady state equation leads to the condition that the input to the
integrator is zero. If the input u is already (directly or indirectly) defined
by another initial condition, then the initialization problem is <strong>singular</strong>
(has none or infinitely many solutions). This situation occurs often
for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
since speed is both a state and a derivative, it is always defined by
Init.InitialState or Init.SteadyState initialization.
</p>

<p>
In such a case, <strong>Init.NoInit</strong> has to be selected for the integrator
and an additional initial equation has to be added to the system
to which the integrator is connected. E.g., useful initial conditions
for a 1-dim. rotational inertia controlled by a PI controller are that
<strong>angle</strong>, <strong>speed</strong>, and <strong>acceleration</strong> of the inertia are zero.
</p>

</html>"),     Icon(graphics={Line(
              origin={0.061,4.184},
              points={{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,
                  113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Continuous;

    package Interfaces
    "Library of connectors and partial models for input/output blocks"
      extends Modelica.Icons.InterfacesPackage;

      connector RealInput = input Real "'input Real' as connector" annotation (
        defaultComponentName="u",
        Icon(graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})},
          coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{0.0,50.0},{100.0,0.0},{0.0,-50.0},{0.0,50.0}}),
          Text(
            textColor={0,0,127},
            extent={{-10.0,60.0},{-10.0,85.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>"));

      connector RealOutput = output Real "'output Real' as connector" annotation (
        defaultComponentName="y",
        Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})}),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
          Text(
            textColor={0,0,127},
            extent={{30.0,60.0},{30.0,110.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>"));

      connector BooleanInput = input Boolean "'input Boolean' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              textColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));

      connector BooleanOutput = output Boolean "'output Boolean' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              textColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>"));

      connector IntegerInput = input Integer "'input Integer' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              textColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Integer.
</p>
</html>"));

      partial block SO "Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real output signal.
</p>
</html>"));

      end SO;

      partial block SISO "Single Input Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Real output signal.
</p>
</html>"));
      end SISO;

      partial block SI2SO
        "2 Single Input / 1 Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u1 "Connector of Real input signal 1" annotation (Placement(
              transformation(extent={{-140,40},{-100,80}})));
        RealInput u2 "Connector of Real input signal 2" annotation (Placement(
              transformation(extent={{-140,-80},{-100,-40}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p>
Block has two continuous Real input signals u1 and u2 and one
continuous Real output signal y.
</p>
</html>"));

      end SI2SO;

      partial block SIMO "Single Input Multiple Output continuous control block"
        extends Modelica.Blocks.Icons.Block;
        parameter Integer nout=1 "Number of outputs";
        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y[nout] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p> Block has one continuous Real input signal and a
    vector of continuous Real output signals.</p>

</html>"));
      end SIMO;

      partial block MISO "Multiple Input Single Output continuous control block"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer nin=1 "Number of inputs";
        RealInput u[nin] "Connector of Real input signals" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has a vector of continuous Real input signals and
one continuous Real output signal.
</p>
</html>"));
      end MISO;

      partial block MIMOs
        "Multiple Input Multiple Output continuous control block with same number of inputs and outputs"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer n=1 "Number of inputs (= number of outputs)";
        RealInput u[n] "Connector of Real input signals" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y[n] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has a continuous Real input and a continuous Real output signal vector
where the signal sizes of the input and output vector are identical.
</p>
</html>"));
      end MIMOs;

      partial block SignalSource "Base class for continuous signal source"
        extends SO;
        parameter Real offset=0 "Offset of output signal y";
        parameter SI.Time startTime=0 "Output y = offset for time < startTime";
        annotation (Documentation(info="<html>
<p>
Basic block for Real sources of package Blocks.Sources.
This component has one continuous Real output signal y
and two parameters (offset, startTime) to shift the
generated signal.
</p>
</html>"));
      end SignalSource;

      partial block SVcontrol "Single-Variable continuous controller"
        extends Modelica.Blocks.Icons.Block;

        RealInput u_s "Connector of setpoint input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealInput u_m "Connector of measurement input signal" annotation (Placement(
              transformation(
              origin={0,-120},
              extent={{20,-20},{-20,20}},
              rotation=270)));
        RealOutput y "Connector of actuator output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has two continuous Real input signals and one
continuous Real output signal. The block is designed
to be used as base class for a corresponding controller.
</p>
</html>"));
      end SVcontrol;

      partial block partialBooleanSI "Partial block with 1 input Boolean signal"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;

        Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Ellipse(
                extent={{-71,7},{-85,-7}},
                lineColor=DynamicSelect({235,235,235}, if u then {0,255,0} else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u then {0,255,0} else {235,235,235}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
Block has one continuous Boolean input signal
with a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSI;

      partial block PartialConversionBlock
        "Partial block defining the interface for conversion blocks"

        RealInput u "Connector of Real input signal to be converted" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y
          "Connector of Real output signal containing input signal u in another unit"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        annotation (
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Rectangle(
              lineColor={0,0,127},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-100.0},{100.0,100.0}}),
            Line(
              points={{-90.0,0.0},{30.0,0.0}},
              color={191,0,0}),
            Polygon(
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid,
              points={{90.0,0.0},{30.0,20.0},{30.0,-20.0},{90.0,0.0}}),
            Text(
              textColor={0,0,255},
              extent={{-150,110},{150,150}},
              textString="%name")}), Documentation(info="<html>
<p>
This block defines the interface of a conversion block that
converts from one unit into another one.
</p>

</html>"));

      end PartialConversionBlock;
      annotation (Documentation(info="<html>
<p>
This package contains interface definitions for
<strong>continuous</strong> input/output blocks with Real,
Integer and Boolean signals. Furthermore, it contains
partial models for continuous and discrete blocks.
</p>

</html>",     revisions="<html>
<ul>
<li><em>June 28, 2019</em>
       by Thomas Beutlich:<br>
       Removed obsolete blocks.</li>
<li><em>Oct. 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Added several new interfaces.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       RealInputSignal renamed to RealInput. RealOutputSignal renamed to
       output RealOutput. GraphBlock renamed to BlockIcon. SISOreal renamed to
       SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
       SignalGenerator renamed to SignalSource. Introduced the following
       new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
       DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
       BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Interfaces;

    package Logical
    "Library of components with Boolean input and output signals"
      extends Modelica.Icons.Package;

      block Switch "Switch between two Real signals"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        Blocks.Interfaces.RealInput u1 "Connector of first Real input signal"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Blocks.Interfaces.BooleanInput u2 "Connector of Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Blocks.Interfaces.RealInput u3 "Connector of second Real input signal"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Blocks.Interfaces.RealOutput y "Connector of Real output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = if u2 then u1 else u3;
        annotation (
          defaultComponentName="switch1",
          Documentation(info="<html>
<p>The Logical.Switch switches, depending on the
logical connector u2 (the middle connector)
between the two possible input signals
u1 (upper connector) and u3 (lower connector).</p>
<p>If u2 is <strong>true</strong>, the output signal y is set equal to
u1, else it is set equal to u3.</p>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{12,0},{100,0}},
                color={0,0,127}),
              Line(points={{-100,0},{-40,0}},
                color={255,0,255}),
              Line(points={{-100,-80},{-40,-80},{-40,-80}},
                color={0,0,127}),
              Line(points={{-40,12},{-40,-12}},
                color={255,0,255}),
              Line(points={{-100,80},{-38,80}},
                color={0,0,127}),
              Line(points=DynamicSelect({{-38,80},{6,2}}, if u2 then {{-38,80},{6,2}} else {{-38,-80},{6,2}}),
                color={0,0,127},
                thickness=1),
              Ellipse(lineColor={0,0,255},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{2,-8},{18,8}})}));
      end Switch;

      block Hysteresis "Transform Real to Boolean signal with Hysteresis"

        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        parameter Real uLow(start=0) "If y=true and u<uLow, switch to y=false";
        parameter Real uHigh(start=1) "If y=false and u>uHigh, switch to y=true";
        parameter Boolean pre_y_start=false "Value of pre(y) at initial time";

        Blocks.Interfaces.RealInput u annotation (Placement(transformation(extent={
                  {-140,-20},{-100,20}})));
        Blocks.Interfaces.BooleanOutput y annotation (Placement(transformation(
                extent={{100,-10},{120,10}})));

      initial equation
        pre(y) = pre_y_start;
      equation
        assert(uHigh > uLow,"Hysteresis limits wrong (uHigh <= uLow)");
        y = not pre(y) and u > uHigh or pre(y) and u >= uLow;
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Polygon(
                  points={{-65,89},{-73,67},{-57,67},{-65,89}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Line(points={{-65,67},{-65,-81}},
                color={192,192,192}),Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
                Polygon(
                  points={{90,-70},{68,-62},{68,-78},{90,-70}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{70,-80},{94,-100}},
                  textColor={160,160,164},
                  textString="u"),Text(
                  extent={{-65,93},{-12,75}},
                  textColor={160,160,164},
                  textString="y"),Line(
                  points={{-80,-70},{30,-70}},
                  thickness=0.5),Line(
                  points={{-50,10},{80,10}},
                  thickness=0.5),Line(
                  points={{-50,10},{-50,-70}},
                  thickness=0.5),Line(
                  points={{30,10},{30,-70}},
                  thickness=0.5),Line(
                  points={{-10,-65},{0,-70},{-10,-75}},
                  thickness=0.5),Line(
                  points={{-10,15},{-20,10},{-10,5}},
                  thickness=0.5),Line(
                  points={{-55,-20},{-50,-30},{-44,-20}},
                  thickness=0.5),Line(
                  points={{25,-30},{30,-19},{35,-30}},
                  thickness=0.5),Text(
                  extent={{-99,2},{-70,18}},
                  textColor={160,160,164},
                  textString="true"),Text(
                  extent={{-98,-87},{-66,-73}},
                  textColor={160,160,164},
                  textString="false"),Text(
                  extent={{19,-87},{44,-70}},
                  textString="uHigh"),Text(
                  extent={{-63,-88},{-38,-71}},
                  textString="uLow"),Line(points={{-69,10},{-60,10}}, color={160,
                160,164})}),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-29}}, color={192,192,192}),
              Polygon(
                points={{92,-29},{70,-21},{70,-37},{92,-29}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-79,-29},{84,-29}}, color={192,192,192}),
              Line(points={{-79,-29},{41,-29}}),
              Line(points={{-15,-21},{1,-29},{-15,-36}}),
              Line(points={{41,51},{41,-29}}),
              Line(points={{33,3},{41,22},{50,3}}),
              Line(points={{-49,51},{81,51}}),
              Line(points={{-4,59},{-19,51},{-4,43}}),
              Line(points={{-59,29},{-49,11},{-39,29}}),
              Line(points={{-49,51},{-49,-29}}),
              Text(
                extent={{-92,-49},{-9,-92}},
                textColor={192,192,192},
                textString="%uLow"),
              Text(
                extent={{2,-49},{91,-92}},
                textColor={192,192,192},
                textString="%uHigh"),
              Rectangle(extent={{-91,-49},{-8,-92}}, lineColor={192,192,192}),
              Line(points={{-49,-29},{-49,-49}}, color={192,192,192}),
              Rectangle(extent={{2,-49},{91,-92}}, lineColor={192,192,192}),
              Line(points={{41,-29},{41,-49}}, color={192,192,192})}),
          Documentation(info="<html>
<p>
This block transforms a <strong>Real</strong> input signal <strong>u</strong> into a <strong>Boolean</strong>
output signal <strong>y</strong>:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Logical/Hysteresis.png\"
     alt=\"Hysteresis.png\">
</p>

<ul>
<li> When the output was <strong>false</strong> and the input becomes
     <strong>greater</strong> than parameter <strong>uHigh</strong>, the output
     switches to <strong>true</strong>.</li>
<li> When the output was <strong>true</strong> and the input becomes
     <strong>less</strong> than parameter <strong>uLow</strong>, the output
     switches to <strong>false</strong>.</li>
</ul>
<p>
The start value of the output is defined via parameter
<strong>pre_y_start</strong> (= value of pre(y) at initial time).
The default value of this parameter is <strong>false</strong>.
</p>
</html>"));
      end Hysteresis;
      annotation (Documentation(info="<html>
<p>
This package provides blocks with Boolean input and output signals
to describe logical networks. A typical example for a logical
network built with package Logical is shown in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Logical/LogicalNetwork1.png\"
     alt=\"LogicalNetwork1.png\">
</p>

<p>
The actual value of Boolean input and/or output signals is displayed
in the respective block icon as \"circle\", where \"white\" color means
value <strong>false</strong> and \"green\" color means value <strong>true</strong>. These
values are visualized in a diagram animation.
</p>
</html>"),     Icon(graphics={Line(
              points={{-86,-22},{-50,-22},{-50,22},{48,22},{48,-22},{88,-24}},
              color={255,0,255})}));
    end Logical;

    package Math
    "Library of Real mathematical functions as input/output blocks"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

      encapsulated package UnitConversions
      "Conversion blocks to convert between SI and non-SI unit signals"
        import Modelica;
        import Modelica.Units.NonSI;
        extends Modelica.Icons.Package;

        block From_degC "Convert from degCelsius to Kelvin"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="degC"),
              y(unit="K"));
        equation
          y = Modelica.Units.Conversions.from_degC(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-20,100},{-100,20}},
                      textString="degC"),Text(
                      extent={{100,-20},{20,-100}},
                      textString="K")}), Documentation(info="<html>
<p>
This block converts the input signal from degCelsius to Kelvin and returns
the result as output signal.
</p>
</html>"));
        end From_degC;

        block From_deg "Convert from degree to radian"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="deg"),
              y(unit="rad"));
        equation
          y = Modelica.Units.Conversions.from_deg(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-20,100},{-100,20}},
                      textString="deg"),Text(
                      extent={{100,-20},{20,-100}},
                      textString="rad")}), Documentation(info="<html>
<p>
This block converts the input signal from degree to radian and returns
the result as output signal.
</p>
</html>"));
        end From_deg;
        annotation (Documentation(info="<html>
<p>
This package consists of blocks that convert an input signal
with a specific unit to an output signal in another unit
(e.g., conversion of an angle signal from \"deg\" to \"rad\").
</p>

</html>"));
      end UnitConversions;

      block Gain "Output the product of a gain value with the input signal"

        parameter Real k(start=1, unit="1")
          "Gain value multiplied with input signal";
    public
        Interfaces.RealInput u "Input signal connector" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealOutput y "Output signal connector" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

      equation
        y = k*u;
        annotation (
          Documentation(info="<html>
<p>
This block computes output <em>y</em> as
<em>product</em> of gain <em>k</em> with the
input <em>u</em>:
</p>
<blockquote><pre>
y = k * u;
</pre></blockquote>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,-140},{150,-100}},
                textString="k=%k"),
              Text(
                extent={{-150,140},{150,100}},
                textString="%name",
                textColor={0,0,255})}));
      end Gain;

      block Feedback "Output difference between commanded and feedback input"

        Interfaces.RealInput u1 "Commanded input" annotation (Placement(transformation(extent={{-100,
                  -20},{-60,20}})));
        Interfaces.RealInput u2 "Feedback input" annotation (Placement(transformation(
              origin={0,-80},
              extent={{-20,-20},{20,20}},
              rotation=90)));
        Interfaces.RealOutput y annotation (Placement(transformation(extent={{80,-10},
                  {100,10}})));

      equation
        y = u1 - u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>difference</em> of the
commanded input <strong>u1</strong> and the feedback
input <strong>u2</strong>:
</p>
<blockquote><pre>
<strong>y</strong> = <strong>u1</strong> - <strong>u2</strong>;
</pre></blockquote>
<p>
Example:
</p>
<blockquote><pre>
   parameter:   n = 2

results in the following equations:

   y = u1 - u2
</pre></blockquote>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Ellipse(
                lineColor={0,0,127},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                extent={{-20,-20},{20,20}}),
              Line(points={{-60,0},{-20,0}}, color={0,0,127}),
              Line(points={{20,0},{80,0}}, color={0,0,127}),
              Line(points={{0,-20},{0,-60}}, color={0,0,127}),
              Text(extent={{-14,-94},{82,0}}, textString="-"),
              Text(
                textColor={0,0,255},
                extent={{-150,40},{150,80}},
                textString="%name")}));
      end Feedback;

      block Add "Output the sum of the two inputs"
        extends Interfaces.SI2SO;

        parameter Real k1=+1 "Gain of input signal 1";
        parameter Real k2=+1 "Gain of input signal 2";

      equation
        y = k1*u1 + k2*u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>sum</em> of the
two input signals <strong>u1</strong> and <strong>u2</strong>:
</p>
<blockquote><pre>
<strong>y</strong> = k1*<strong>u1</strong> + k2*<strong>u2</strong>;
</pre></blockquote>
<p>
Example:
</p>
<blockquote><pre>
   parameter:   k1= +2, k2= -3

results in the following equations:

   y = 2 * u1 - 3 * u2
</pre></blockquote>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,60},{-74,24},{-44,24}}, color={0,0,127}),
              Line(points={{-100,-60},{-74,-24},{-44,-24}}, color={0,0,127}),
              Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Text(extent={{-40,40},{40,-40}}, textString="+"),
              Text(extent={{-100,52},{5,92}}, textString="%k1"),
              Text(extent={{-100,-92},{5,-52}}, textString="%k2")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={         Line(points={{50,0},{100,0}},
                color={0,0,255}),                                        Line(
                points={{50,0},{100,0}}, color={0,0,127})}));
      end Add;

      block Add3 "Output the sum of the three inputs"
        extends Modelica.Blocks.Icons.Block;

        parameter Real k1=+1 "Gain of input signal 1";
        parameter Real k2=+1 "Gain of input signal 2";
        parameter Real k3=+1 "Gain of input signal 3";
        Interfaces.RealInput u1 "Connector of Real input signal 1" annotation (
            Placement(transformation(extent={{-140,60},{-100,100}})));
        Interfaces.RealInput u2 "Connector of Real input signal 2" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealInput u3 "Connector of Real input signal 3" annotation (
            Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Interfaces.RealOutput y "Connector of Real output signal" annotation (
            Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = k1*u1 + k2*u2 + k3*u3;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>sum</em> of the
three input signals <strong>u1</strong>, <strong>u2</strong> and <strong>u3</strong>:
</p>
<blockquote><pre>
<strong>y</strong> = k1*<strong>u1</strong> + k2*<strong>u2</strong> + k3*<strong>u3</strong>;
</pre></blockquote>
<p>
Example:
</p>
<blockquote><pre>
   parameter:   k1= +2, k2= -3, k3=1;

results in the following equations:

   y = 2 * u1 - 3 * u2 + u3;
</pre></blockquote>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-100,50},{5,90}},
                textString="%k1"),
              Text(
                extent={{-100,-20},{5,20}},
                textString="%k2"),
              Text(
                extent={{-100,-50},{5,-90}},
                textString="%k3"),
              Text(
                extent={{10,40},{90,-40}},
                textString="+")}));
      end Add3;

      block BooleanToReal "Convert Boolean to Real signal"
        extends Interfaces.partialBooleanSI;
        parameter Real realTrue=1.0 "Output signal for true Boolean input";
        parameter Real realFalse=0.0 "Output signal for false Boolean input";

        Blocks.Interfaces.RealOutput y "Connector of Real output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = if u then realTrue else realFalse;
        annotation (Documentation(info="<html>
<p>
This block computes the output <strong>y</strong>
as <em>Real equivalent</em> of the Boolean input <strong>u</strong>:
</p>
<blockquote><pre>
y = <strong>if</strong> u <strong>then</strong> realTrue <strong>else</strong> realFalse;
</pre></blockquote>
<p>where <strong>u</strong> is of Boolean and <strong>y</strong> of Real type,
and <strong>realTrue</strong> and <strong>realFalse</strong> are parameters.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Text(
                extent={{-86,92},{-6,10}},
                textColor={255,0,255},
                textString="B"),
              Polygon(
                points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                    {-32,-66},{-12,-46}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Text(
                extent={{8,-4},{92,-94}},
                textString="R",
                textColor={0,0,127})}));
      end BooleanToReal;

      block Max "Pass through the largest signal"
        extends Interfaces.SI2SO;
      equation
        y = max(u1, u2);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Text(
                extent={{-90,36},{90,-36}},
                textColor={160,160,164},
                textString="max()")}), Documentation(info="<html>
<p>
This block computes the output <strong>y</strong> as <em>maximum</em>
of the two Real inputs <strong>u1</strong> and <strong>u2</strong>:
</p>
<blockquote><pre>
y = <strong>max</strong> ( u1 , u2 );
</pre></blockquote>
</html>"));
      end Max;
      annotation (Documentation(info="<html>
<p>
This package contains basic <strong>mathematical operations</strong>,
such as summation and multiplication, and basic <strong>mathematical
functions</strong>, such as <strong>sqrt</strong> and <strong>sin</strong>, as
input/output blocks. All blocks of this library can be either
connected with continuous blocks or with sampled-data blocks.
</p>
</html>",     revisions="<html>
<ul>
<li><em>August 24, 2016</em>
       by Christian Kral: added WrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New blocks added: RealToInteger, IntegerToReal, Max, Min, Edge, BooleanChange, IntegerChange.</li>
<li><em>August 7, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized (partly based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist).
</li>
</ul>
</html>"),     Icon(graphics={Line(
              points={{-80,-2},{-68.7,32.2},{-61.5,51.1},{-55.1,64.4},{-49.4,72.6},
                  {-43.8,77.1},{-38.2,77.8},{-32.6,74.6},{-26.9,67.7},{-21.3,57.4},
                  {-14.9,42.1},{-6.83,19.2},{10.1,-32.8},{17.3,-52.2},{23.7,-66.2},
                  {29.3,-75.1},{35,-80.4},{40.6,-82},{46.2,-79.6},{51.9,-73.5},{
                  57.5,-63.9},{63.9,-49.2},{72,-26.8},{80,-2}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Math;

    package Routing "Library of blocks to combine and extract signals"
      extends Modelica.Icons.Package;

      block Replicator "Signal replicator"
        extends Modelica.Blocks.Interfaces.SIMO;
      equation
        y = fill(u, nout);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,0},{-6,0}}, color={0,0,127}),
              Line(points={{100,0},{10,0}}, color={0,0,127}),
              Line(points={{0,0},{100,10}}, color={0,0,127}),
              Line(points={{0,0},{100,-10}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
This block replicates the input signal to an array of <code>nout</code> identical output signals.
</p>
</html>"));
      end Replicator;

      model RealPassThrough "Pass a Real signal through without modification"
        extends Modelica.Blocks.Interfaces.SISO;
      equation
        y = u;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Line(points={{-100,0},{100,0}},
                  color={0,0,127})}),
                          Documentation(info="<html>
<p>
Passes a Real signal through without modification.  Enables signals to be read out of one bus, have their name changed and be sent back to a bus.
</p>
</html>"));
      end RealPassThrough;
      annotation (Documentation(info="<html>
<p>
This package contains blocks to combine and extract signals.
</p>
</html>"),     Icon(graphics={
            Line(points={{-90,0},{4,0}}, color={95,95,95}),
            Line(points={{88,65},{48,65},{-8,0}}, color={95,95,95}),
            Line(points={{-8,0},{93,0}}, color={95,95,95}),
            Line(points={{87,-65},{48,-65},{-8,0}}, color={95,95,95})}));
    end Routing;

    package Sources
    "Library of signal source blocks generating Real, Integer and Boolean signals"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.SourcesPackage;

      block RealExpression "Set output signal to a time varying Real expression"

        Modelica.Blocks.Interfaces.RealOutput y=0.0 "Value of Real output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                textColor={0,0,255})}), Documentation(info="<html>
<p>
The (time varying) Real output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Real expressions in a block diagram. For example,
in the y-menu the definition \"if time &lt; 1 then 0 else 1\" can be given in order
to define that the output signal is one, if time &ge; 1 and otherwise
it is zero. Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end RealExpression;

      block BooleanExpression
        "Set output signal to a time varying Boolean expression"

        Modelica.Blocks.Interfaces.BooleanOutput y=false "Value of Boolean output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                textColor={0,0,255}),
              Polygon(
                points={{100,10},{120,0},{100,-10},{100,10}},
                lineColor=DynamicSelect({255,0,255}, if y then {0,255,0} else {255,0,255}),
                fillColor=DynamicSelect({255,255,255}, if y then {0,255,0} else {255,255,255}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
The (time varying) Boolean output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Boolean expressions in a block diagram. For example,
in the y-menu the definition \"time &gt;= 1 and time &lt;= 2\" can be given in order
to define that the output signal is <strong>true</strong> in the time interval
1 &le; time &le; 2 and otherwise it is <strong>false</strong>.
Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end BooleanExpression;

      block Constant "Generate constant signal of type Real"
        parameter Real k(start=1) "Constant output value"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png"));
        extends Interfaces.SO;

      equation
        y = k;
        annotation (
          defaultComponentName="const",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{80,0}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="k=%k")}),
          Documentation(info="<html>
<p>
The Real output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png\"
     alt=\"Constant.png\">
</p>
</html>"));
      end Constant;

      block Ramp "Generate ramp signal"
        parameter Real height=1 "Height of ramps"
          annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Ramp.png"));
        parameter SI.Time duration(min=0.0, start=2)
          "Duration of ramp (= 0.0 gives a Step)";
        extends Interfaces.SignalSource;

      equation
        y = offset + (if time < startTime then 0 else if time < (startTime +
          duration) then (time - startTime)*height/duration else height);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-70},{-40,-70},{31,38}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="duration=%duration"),
              Line(points={{31,38},{86,38}})}),
          Documentation(info="<html>
<p>
The Real output y is a ramp signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Ramp.png\"
     alt=\"Ramp.png\">
</p>

<p>
If parameter duration is set to 0.0, the limiting case of a Step signal is achieved.
</p>
</html>"));
      end Ramp;

      block Pulse "Generate pulse signal of type Real"
        parameter Real amplitude=1 "Amplitude of pulse"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Pulse.png"));
        parameter Real width(
          final min=Modelica.Constants.small,
          final max=100) = 50 "Width of pulse in % of period";
        parameter SI.Time period(final min=Modelica.Constants.small,
            start=1) "Time for one period";
        parameter Integer nperiod=-1
          "Number of periods (< 0 means infinite number of periods)";
        extends Interfaces.SignalSource;
    protected
        SI.Time T_width=period*width/100;
        SI.Time T_start "Start time of current period";
        Integer count "Period count";
      initial algorithm
        count := integer((time - startTime)/period);
        T_start := startTime + count*period;
      equation
        when integer((time - startTime)/period) > pre(count) then
          count = pre(count) + 1;
          T_start = time;
        end when;
        y = offset + (if (time < startTime or nperiod == 0 or (nperiod > 0 and
          count >= nperiod)) then 0 else if time < T_start + T_width then amplitude
           else 0);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-70},{-40,-70},{-40,44},{0,44},{0,-70},{40,-70},{40,
                    44},{79,44}}),
              Text(
                extent={{-147,-152},{153,-112}},
                textString="period=%period")}),
          Documentation(info="<html>
<p>
The Real output y is a pulse signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Pulse.png\"
     alt=\"Pulse.png\">
</p>
</html>"));
      end Pulse;
      annotation (Documentation(info="<html>
<p>
This package contains <strong>source</strong> components, i.e., blocks which
have only output signals. These blocks are used as signal generators
for Real, Integer and Boolean signals.
</p>

<p>
All Real source signals (with the exception of the Constant source)
have at least the following two parameters:
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>offset</strong></td>
      <td>Value which is added to the signal</td>
  </tr>
  <tr><td><strong>startTime</strong></td>
      <td>Start time of signal. For time &lt; startTime,
                the output y is set to offset.</td>
  </tr>
</table>

<p>
The <strong>offset</strong> parameter is especially useful in order to shift
the corresponding source, such that at initial time the system
is stationary. To determine the corresponding value of offset,
usually requires a trimming calculation.
</p>
</html>",     revisions="<html>
<ul>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Integer sources added. Step, TimeTable and BooleanStep slightly changed.</li>
<li><em>Nov. 8, 1999</em>
       by <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
       (nperiod=-1 is an infinite number of periods).</li>
<li><em>Oct. 31, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       All sources vectorized. New sources: ExpSine, Trapezoid,
       BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
       Improved documentation, especially detailed description of
       signals in diagram layer.</li>
<li><em>June 29, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Sources;

    package Tables
    "Library of blocks to interpolate in one and two-dimensional tables"
      extends Modelica.Icons.Package;

      block CombiTable1Ds
        "Table look-up in one dimension (matrix/file) with one input and n outputs"
        extends Modelica.Blocks.Interfaces.SIMO(final nout=size(columns, 1));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if table input is outside the definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Real u_min=Internal.getTable1DAbscissaUmin(tableID)
          "Minimum abscissa value defined in table";
        final parameter Real u_max=Internal.getTable1DAbscissaUmax(tableID)
          "Maximum abscissa value defined in table";
    protected
        parameter Modelica.Blocks.Types.ExternalCombiTable1D tableID=
            Modelica.Blocks.Types.ExternalCombiTable1D(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              columns,
              smoothness,
              extrapolation,
              if tableOnFile then verboseRead else false) "External table object";
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          assert(noEvent(u >= u_min), "
Extrapolation warning: The value u (="     + String(u) + ") must be greater or equal
than the minimum abscissa value u_min (="     + String(u_min) + ") defined in the table.
",     level=AssertionLevel.warning);
          assert(noEvent(u <= u_max), "
Extrapolation warning: The value u (="     + String(u) + ") must be less or equal
than the maximum abscissa value u_max (="     + String(u_max) + ") defined in the table.
",     level=AssertionLevel.warning);
        end if;

        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:nout loop
            y[i] = Internal.getTable1DValueNoDer(tableID, i, u);
          end for;
        elseif smoothness == Modelica.Blocks.Types.Smoothness.LinearSegments then
          for i in 1:nout loop
            y[i] = Internal.getTable1DValueNoDer2(tableID, i, u);
          end for;
        else
          for i in 1:nout loop
            y[i] = Internal.getTable1DValue(tableID, i, u);
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
<strong>Univariate constant</strong>, <strong>linear</strong> or <strong>cubic Hermite
spline interpolation</strong> in <strong>one</strong> dimension of a
<strong>table</strong>.
Via parameter <strong>columns</strong> it can be defined how many columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that
2 output signals are present and that the first output interpolates
via column 2 and the second output interpolates via column 4 of the
table matrix.
</p>
<p>
The grid points and function values are stored in a matrix \"table[i,j]\",
where the first column \"table[:,1]\" contains the grid points and the
other columns contain the data to be interpolated. Example:
</p>
<blockquote><pre>
table = [0,  0;
         1,  1;
         2,  4;
         4, 16]
If, e.g., the input u = 1.0, the output y =  1.0,
    e.g., the input u = 1.5, the output y =  2.5,
    e.g., the input u = 2.0, the output y =  4.0,
    e.g., the input u =-1.0, the output y = -1.0 (i.e., extrapolation).
</pre></blockquote>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<blockquote><pre>
smoothness = 1: Linear interpolation
           = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                splines such that der(y) is continuous, also if extrapolated.
           = 3: Constant segments
           = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                Hermite splines such that y preserves the monotonicity and
                der(y) is continuous, also if extrapolated.
           = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                splines such that y preserves the monotonicity and der(y)
                is continuous, also if extrapolated.
           = 6: Modified Akima interpolation: Smooth interpolation by cubic
                Hermite splines such that der(y) is continuous, also if
                extrapolated. Additionally, overshoots and edge cases of the
                original Akima interpolation method are avoided.
</pre></blockquote></li>
<li>First and second <strong>derivatives</strong> are provided, with exception of the following two smoothness options.
<ol>
<li>No derivatives are provided for interpolation by constant segments.</li>
<li>No second derivative is provided for linear interpolation.</li>
</ol></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<blockquote><pre>
extrapolation = 1: Hold the first or last value of the table,
                   if outside of the table scope.
              = 2: Extrapolate by using the derivative at the first/last table
                   points if outside of the table scope.
                   (If smoothness is LinearSegments or ConstantSegments
                   this means to extrapolate linearly through the first/last
                   two table points.).
              = 3: Periodically repeat the table data (periodical function).
              = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></blockquote></li>
<li>If the table has only <strong>one row</strong>, the table value is returned,
    independent of the value of the input signal.</li>
<li>The grid values (first column) have to be strictly increasing.</li>
</ul>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<blockquote><pre>
tableName is \"NoName\" or has only blanks,
fileName  is \"NoName\" or has only blanks.
</pre></blockquote></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<blockquote><pre>
save tables.mat tab1 tab2 tab3
</pre></blockquote>
    or Scilab by command
<blockquote><pre>
savematfile tables.mat tab1 tab2 tab3
</pre></blockquote>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.
    See the <a href=\"modelica://Modelica.Blocks.Tables\">Tables</a> package
    documentation for more details.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<blockquote><pre>
-----------------------------------------------------
#1
double tab1(5,2)   # comment line
  0   0
  1   1
  2   4
  3   9
  4  16
double tab2(5,2)   # another comment line
  0   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre></blockquote>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-60.0,40.0},{-60.0,-40.0},{60.0,-40.0},{60.0,40.0},{30.0,40.0},{30.0,-40.0},{-30.0,-40.0},{-30.0,40.0},{-60.0,40.0},{-60.0,20.0},{60.0,20.0},{60.0,0.0},{-60.0,0.0},{-60.0,-20.0},{60.0,-20.0},{60.0,-40.0},{-60.0,-40.0},{-60.0,40.0},{60.0,40.0},{60.0,-40.0}}),
          Line(points={{0.0,40.0},{0.0,-40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,20.0},{-30.0,40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,0.0},{-30.0,20.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-20.0},{-30.0,0.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-40.0},{-30.0,-20.0}})}));
      end CombiTable1Ds;

      block CombiTable1Dv
        "Table look-up in one dimension (matrix/file) with n inputs and n outputs"
        extends Modelica.Blocks.Interfaces.MIMOs(final n=size(columns, 1));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if table input is outside the definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Real u_min=Internal.getTable1DAbscissaUmin(tableID)
          "Minimum abscissa value defined in table";
        final parameter Real u_max=Internal.getTable1DAbscissaUmax(tableID)
          "Maximum abscissa value defined in table";
    protected
        parameter Modelica.Blocks.Types.ExternalCombiTable1D tableID=
            Modelica.Blocks.Types.ExternalCombiTable1D(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              columns,
              smoothness,
              extrapolation,
              if tableOnFile then verboseRead else false) "External table object";
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          for i in 1:n loop
            assert(noEvent(u[i] >= u_min), "
Extrapolation warning: The value u["     + String(i) +"] (=" + String(u[i]) + ") must be greater or equal
than the minimum abscissa value u_min (="     + String(u_min) + ") defined in the table.
",     level=AssertionLevel.warning);
            assert(noEvent(u[i] <= u_max), "
Extrapolation warning: The value u["     + String(i) +"] (=" + String(u[i]) + ") must be less or equal
than the maximum abscissa value u_max (="     + String(u_max) + ") defined in the table.
",     level=AssertionLevel.warning);
          end for;
        end if;

        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:n loop
            y[i] = Internal.getTable1DValueNoDer(tableID, i, u[i]);
          end for;
        elseif smoothness == Modelica.Blocks.Types.Smoothness.LinearSegments then
          for i in 1:n loop
            y[i] = Internal.getTable1DValueNoDer2(tableID, i, u[i]);
          end for;
        else
          for i in 1:n loop
            y[i] = Internal.getTable1DValue(tableID, i, u[i]);
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
<strong>Univariate constant</strong>, <strong>linear</strong> or <strong>cubic Hermite
spline interpolation</strong> in <strong>one</strong> dimension of a
<strong>table</strong>.
Via parameter <strong>columns</strong> it can be defined how many columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that 2 input
and 2 output signals are present and that the first output interpolates
the first input via column 2 and the second output interpolates the
second input via column 4 of the table matrix.
</p>
<p>
The grid points and function values are stored in a matrix \"table[i,j]\",
where the first column \"table[:,1]\" contains the grid points and the
other columns contain the data to be interpolated. Example:
</p>
<blockquote><pre>
table = [0,  0;
         1,  1;
         2,  4;
         4, 16]
If, e.g., the input u = 1.0, the output y =  1.0,
    e.g., the input u = 1.5, the output y =  2.5,
    e.g., the input u = 2.0, the output y =  4.0,
    e.g., the input u =-1.0, the output y = -1.0 (i.e., extrapolation).
</pre></blockquote>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<blockquote><pre>
smoothness = 1: Linear interpolation
           = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                splines such that der(y) is continuous, also if extrapolated.
           = 3: Constant segments
           = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                Hermite splines such that y preserves the monotonicity and
                der(y) is continuous, also if extrapolated.
           = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                splines such that y preserves the monotonicity and der(y)
                is continuous, also if extrapolated.
           = 6: Modified Akima interpolation: Smooth interpolation by cubic
                Hermite splines such that der(y) is continuous, also if
                extrapolated. Additionally, overshoots and edge cases of the
                original Akima interpolation method are avoided.
</pre></blockquote></li>
<li>First and second <strong>derivatives</strong> are provided, with exception of the following two smoothness options.
<ol>
<li>No derivatives are provided for interpolation by constant segments.</li>
<li>No second derivative is provided for linear interpolation.</li>
</ol></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<blockquote><pre>
extrapolation = 1: Hold the first or last value of the table,
                   if outside of the table scope.
              = 2: Extrapolate by using the derivative at the first/last table
                   points if outside of the table scope.
                   (If smoothness is LinearSegments or ConstantSegments
                   this means to extrapolate linearly through the first/last
                   two table points.).
              = 3: Periodically repeat the table data (periodical function).
              = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></blockquote></li>
<li>If the table has only <strong>one row</strong>, the table value is returned,
    independent of the value of the input signal.</li>
<li>The grid values (first column) have to be strictly increasing.</li>
</ul>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<blockquote><pre>
tableName is \"NoName\" or has only blanks,
fileName  is \"NoName\" or has only blanks.
</pre></blockquote></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<blockquote><pre>
save tables.mat tab1 tab2 tab3
</pre></blockquote>
    or Scilab by command
<blockquote><pre>
savematfile tables.mat tab1 tab2 tab3
</pre></blockquote>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.
    See the <a href=\"modelica://Modelica.Blocks.Tables\">Tables</a> package
    documentation for more details.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<blockquote><pre>
-----------------------------------------------------
#1
double tab1(5,2)   # comment line
  0   0
  1   1
  2   4
  3   9
  4  16
double tab2(5,2)   # another comment line
  0   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre></blockquote>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-60.0,40.0},{-60.0,-40.0},{60.0,-40.0},{60.0,40.0},{30.0,40.0},{30.0,-40.0},{-30.0,-40.0},{-30.0,40.0},{-60.0,40.0},{-60.0,20.0},{60.0,20.0},{60.0,0.0},{-60.0,0.0},{-60.0,-20.0},{60.0,-20.0},{60.0,-40.0},{-60.0,-40.0},{-60.0,40.0},{60.0,40.0},{60.0,-40.0}}),
          Line(points={{0.0,40.0},{0.0,-40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,20.0},{-30.0,40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,0.0},{-30.0,20.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-20.0},{-30.0,0.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-40.0},{-30.0,-20.0}})}));
      end CombiTable1Dv;

      package Internal
      "Internal external object definitions for table functions that should not be directly utilized by the user"
        extends Modelica.Icons.InternalPackage;

        pure function getTable1DValue "Interpolate 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID "External table object";
          input Integer icol "Column number";
          input Real u "Abscissa value";
          output Real y "Interpolated value";
          external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation (derivative = getDerTable1DValue);
        end getTable1DValue;

        pure function getTable1DValueNoDer
          "Interpolate 1-dim. table defined by matrix (but do not provide a derivative function)"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID "External table object";
          input Integer icol "Column number";
          input Real u "Abscissa value";
          output Real y "Interpolated value";
          external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DValueNoDer;

        pure function getTable1DValueNoDer2
          "Interpolate 1-dim. table defined by matrix (but do not provide a second derivative function)"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID "External table object";
          input Integer icol "Column number";
          input Real u "Abscissa value";
          output Real y "Interpolated value";
          external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation (derivative = getDerTable1DValueNoDer);
        end getTable1DValueNoDer2;

        pure function getDerTable1DValue
          "Derivative of interpolated 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID "External table object";
          input Integer icol "Column number";
          input Real u "Abscissa value";
          input Real der_u "Derivative of abscissa value";
          output Real der_y "Derivative of interpolated value";
          external "C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation (derivative(order=2) = getDer2Table1DValue);
        end getDerTable1DValue;

        pure function getDerTable1DValueNoDer
          "Derivative of interpolated 1-dim. table defined by matrix (but do not provide a second derivative function)"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID "External table object";
          input Integer icol "Column number";
          input Real u "Abscissa value";
          input Real der_u "Derivative of abscissa value";
          output Real der_y "Derivative of interpolated value";
          external "C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getDerTable1DValueNoDer;

        pure function getDer2Table1DValue
          "Second derivative of interpolated 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID "External table object";
          input Integer icol "Column number";
          input Real u "Abscissa value";
          input Real der_u "Derivative of abscissa value";
          input Real der2_u " Second derivative of abscissa value";
          output Real der2_y "Second derivative of interpolated value";
          external "C" der2_y = ModelicaStandardTables_CombiTable1D_getDer2Value(tableID, icol, u, der_u, der2_u)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getDer2Table1DValue;

        pure function getTable1DAbscissaUmin
          "Return minimum abscissa value of 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID "External table object";
          output Real uMin "Minimum abscissa value in table";
          external "C" uMin = ModelicaStandardTables_CombiTable1D_minimumAbscissa(tableID)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DAbscissaUmin;

        pure function getTable1DAbscissaUmax
          "Return maximum abscissa value of 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID "External table object";
          output Real uMax "Maximum abscissa value in table";
          external "C" uMax = ModelicaStandardTables_CombiTable1D_maximumAbscissa(tableID)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DAbscissaUmax;
      end Internal;
      annotation (Documentation(info="<html>
<p>This package contains blocks for one- and two-dimensional interpolation in tables.</p>
<h4>Special interest topic: Statically stored tables for real-time simulation targets</h4>
<p>Especially for use on real-time platform targets (e.g., HIL-simulators) with <strong>no file system</strong>, it is possible to statically
store tables using a function &quot;usertab&quot; in a file conventionally named &quot;usertab.c&quot;. This can be more efficient than providing the tables as Modelica parameter arrays.</p>
<p>This is achieved by providing the tables in a specific structure as C-code and compiling that C-code together with the rest of the simulation model into a binary
that can be executed on the target platform. The &quot;Resources/Data/Tables/&quot; subdirectory of the MSL installation directory contains the files
<a href=\"modelica://Modelica/Resources/Data/Tables/usertab.c\">&quot;usertab.c&quot;</a> and <a href=\"modelica://Modelica/Resources/Data/Tables/usertab.h\">&quot;usertab.h&quot;</a>
that can be used as a template for own developments. While &quot;usertab.c&quot; would be typically used unmodified, the
&quot;usertab.h&quot; needs to adapted for the own needs.</p>
<p>In order to work it is necessary that the compiler pulls in the &quot;usertab.c&quot; file. Different Modelica tools might provide different mechanisms to do so.
Please consult the respective documentation/support for your Modelica tool.</p>
<p>A possible (though slightly makeshift) approach is to pull in the required files by utilizing a &quot;dummy&quot;-function that uses the Modelica external function
interface to include the required &quot;usertab.c&quot;. An example how this can be done is given below.</p>
<blockquote><pre>
model ExampleCTable \"Example utilizing the usertab.c interface\"
  extends Modelica.Icons.Example;
  parameter Real dummy(fixed=false) \"Dummy parameter\" annotation(HideResult=true);
  Modelica.Blocks.Tables.CombiTable1Dv table(tableOnFile=true, tableName=\"TestTable_1D_a\")
    annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
  Modelica.Blocks.Sources.ContinuousClock clock
    annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
protected
  encapsulated impure function getUsertab \"External dummy function to include \\\"usertab.c\\\"\"
    input Real dummy_u[:];
    output Real dummy_y;
    external \"C\" dummy_y = mydummyfunc(dummy_u);
    annotation(IncludeDirectory=\"modelica://Modelica/Resources/Data/Tables\",
           Include = \"#include \"usertab.c\"
double mydummyfunc(double* dummy_in) {
   return 0;
}
\");
  end getUsertab;
initial equation
  dummy = getUsertab(table.y);
equation
  connect(clock.y, table.u[1]) annotation (Line(points={{-59,10},{-42,10}}, color={0,0,127}));
  annotation (experiment(StartTime=0, StopTime=5), uses(Modelica(version=\"4.0.0\")));
end ExampleCTable;
</pre></blockquote>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Rectangle(
              extent={{-76,-26},{80,-76}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-76,24},{80,-26}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-76,74},{80,24}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-28,74},{-28,-76}},
              color={95,95,95}),
            Line(
              points={{24,74},{24,-76}},
              color={95,95,95})}));
    end Tables;

    package Types
    "Library of constants, external objects and types with choices, especially to build menus"
      extends Modelica.Icons.TypesPackage;

      type Smoothness = enumeration(
          LinearSegments "Linear interpolation of table points",
          ContinuousDerivative
            "Akima spline interpolation of table points (such that the first derivative is continuous)",
          ConstantSegments
            "Piecewise constant interpolation of table points (the value from the previous abscissa point is returned)",
          MonotoneContinuousDerivative1
            "Fritsch-Butland spline interpolation (such that the monotonicity is preserved and the first derivative is continuous)",
          MonotoneContinuousDerivative2
            "Steffen spline interpolation of table points (such that the monotonicity is preserved and the first derivative is continuous)",
          ModifiedContinuousDerivative
            "Modified Akima spline interpolation of table points (such that the first derivative is continuous and shortcomings of the original Akima method are avoided)")
        "Enumeration defining the smoothness of table interpolation";

        type Extrapolation = enumeration(
          HoldLastPoint
            "Hold the first/last table point outside of the table scope",
          LastTwoPoints
            "Extrapolate by using the derivative at the first/last table points outside of the table scope",
          Periodic "Repeat the table scope periodically",
          NoExtrapolation "Extrapolation triggers an error")
        "Enumeration defining the extrapolation of table interpolation";

        type Init = enumeration(
          NoInit
            "No initialization (start values are used as guess values with fixed=false)",
          SteadyState
            "Steady state initialization (derivatives of states are zero)",
          InitialState "Initialization with initial states",
          InitialOutput
            "Initialization with initial outputs (and steady state of the states if possible)")
        "Enumeration defining initialization of a block" annotation (Evaluate=true,
        Documentation(info="<html>
  <p>The following initialization alternatives are available:</p>
  <dl>
    <dt><code><strong>NoInit</strong></code></dt>
      <dd>No initialization (start values are used as guess values with <code>fixed=false</code>)</dd>
    <dt><code><strong>SteadyState</strong></code></dt>
      <dd>Steady state initialization (derivatives of states are zero)</dd>
    <dt><code><strong>InitialState</strong></code></dt>
      <dd>Initialization with initial states</dd>
    <dt><code><strong>InitialOutput</strong></code></dt>
      <dd>Initialization with initial outputs (and steady state of the states if possible)</dd>
  </dl>
</html>"));

       type SimpleController = enumeration(
          P "P controller",
          PI "PI controller",
          PD "PD controller",
          PID "PID controller")
        "Enumeration defining P, PI, PD, or PID simple controller type" annotation (
         Evaluate=true);

      class ExternalCombiTable1D
        "External object of 1-dim. table defined by matrix"
        extends ExternalObject;

        function constructor "Initialize 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input String tableName "Table name";
          input String fileName "File name";
          input Real table[:, :];
          input Integer columns[:];
          input Modelica.Blocks.Types.Smoothness smoothness;
          input Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints;
          input Boolean verboseRead=true "= true: Print info message; = false: No info message";
          output ExternalCombiTable1D externalCombiTable1D;
        external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init2(
                fileName,
                tableName,
                table,
                size(table, 1),
                size(table, 2),
                columns,
                size(columns, 1),
                smoothness,
                extrapolation,
                verboseRead) annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end constructor;

        function destructor "Terminate 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input ExternalCombiTable1D externalCombiTable1D;
        external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D)
            annotation (IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end destructor;

      end ExternalCombiTable1D;
      annotation (Documentation(info="<html>
<p>
In this package <strong>types</strong>, <strong>constants</strong> and <strong>external objects</strong> are defined that are used
in library Modelica.Blocks. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</html>"));
    end Types;

    package Icons "Icons for Blocks"
        extends Modelica.Icons.IconsPackage;

        partial block Block "Basic graphical layout of input/output block"

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                textColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output
block (no declarations, no equations). Most blocks
of package Modelica.Blocks inherit directly or indirectly
from this block.
</p>
</html>"));

        end Block;

      partial block PartialBooleanBlock "Basic graphical layout of logical block"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                textColor={0,0,255})}), Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Boolean block (no declarations, no equations) used especially
in the Blocks.Logical library.
</p>
</html>"));
      end PartialBooleanBlock;
    end Icons;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}), Documentation(info="<html>
<p>
This library contains input/output blocks to build up block diagrams.
</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a><br></dd>
</dl>
<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>June 23, 2004</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Introduced new block connectors and adapted all blocks to the new connectors.
       Included subpackages Continuous, Discrete, Logical, Nonlinear from
       package ModelicaAdditions.Blocks.
       Included subpackage ModelicaAdditions.Table in Modelica.Blocks.Sources
       and in the new package Modelica.Blocks.Tables.
       Added new blocks to Blocks.Sources and Blocks.Logical.
       </li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New subpackage Examples, additional components.
       </li>
<li><em>June 20, 2000</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
       Michael Tiller:<br>
       Introduced a replaceable signal type into
       Blocks.Interfaces.RealInput/RealOutput:
<blockquote><pre>
replaceable type SignalType = Real
</pre></blockquote>
       in order that the type of the signal of an input/output block
       can be changed to a physical type, for example:
<blockquote><pre>
Sine sin1(outPort(redeclare type SignalType=Modelica.Units.SI.Torque))
</pre></blockquote>
      </li>
<li><em>Sept. 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renamed to Blocks. New subpackages Math, Nonlinear.
       Additional components in subpackages Interfaces, Continuous
       and Sources.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
  end Blocks;

  package StateGraph
  "Library of hierarchical state machine components to model discrete event and reactive systems"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;

  package Interfaces "Connectors and partial models"
    extends Modelica.Icons.InterfacesPackage;

    connector Step_in "Input port of a step"
      output Boolean occupied "= true, if step is active" annotation (HideResult=true);
      input Boolean set "= true, if transition fires and step is activated" annotation (HideResult=true);
      annotation (
     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{-100,100},{100,0},{-100,-100},{-100,100}},
                fillPattern=FillPattern.Solid)}),
     Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{0,50},{100,0},{0,-50},{0,50}},
                fillPattern=FillPattern.Solid), Text(
                extent={{-141,100},{100,60}},
                textString="%name")}));
    end Step_in;

    connector Step_out "Output port of a step"
      output Boolean available "= true, if step is active" annotation (HideResult=true);

      input Boolean reset "= true, if transition fires and step is deactivated"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
                                Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Rectangle(
                extent={{-100,50},{0,-50}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-100,100},{186,58}},
                textString="%name")}));
    end Step_out;

    connector Transition_in "Input port of a transition"
      input Boolean available
          "= true, if step connected to the transition input is active"
        annotation (HideResult=true);
      output Boolean reset
          "= true, if transition fires and the step connected to the transition input is deactivated"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{-100,100},{100,0},{-100,-100},{-100,100}},
                fillPattern=FillPattern.Solid)}),
                                              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{0,50},{100,0},{0,-50},{0,50}},
                fillPattern=FillPattern.Solid), Text(
                extent={{-141,100},{100,60}},
                textString="%name")}));
    end Transition_in;

    connector Transition_out "Output port of a transition"
      input Boolean occupied
          "= true, if step connected to the transition output is active"
        annotation (HideResult=true);
      output Boolean set
          "= true, if transition fires and step connected to the transition output becomes active"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Text(
                extent={{-100,100},{146,60}},
                textString="%name"), Rectangle(
                extent={{-100,50},{0,-50}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
    end Transition_out;

    connector CompositeStepStatePort_in
        "Communication port between a CompositeStep and the ordinary steps within the CompositeStep (suspend/resume are inputs)"

      input Boolean suspend
          "= true, if suspend transition of CompositeStep fires";
      input Boolean resume "= true, if resume transition of CompositeStep fires";
      Real activeStepsDummy
          "Dummy variable in order that connector fulfills restriction of connector" annotation(HideResult=true);
      flow Real activeSteps "Number of active steps in the CompositeStep";
    end CompositeStepStatePort_in;

    connector CompositeStepStatePort_out
        "Communication port between a CompositeStep and the ordinary steps within the CompositeStep (suspend/resume are outputs)"

      output Boolean suspend
          "= true, if suspend transition of CompositeStep fires";
      output Boolean resume "= true, if resume transition of CompositeStep fires";
      Real activeStepsDummy
          "Dummy variable in order that connector fulfills restriction of connector" annotation(HideResult=true);
      flow Real activeSteps "Number of active steps in the CompositeStep";
    end CompositeStepStatePort_out;

    partial block PartialStep
        "Partial step with one input and one output transition port"

      parameter Integer nIn(min=0) = 0 "Number of input connections" annotation(Dialog(connectorSizing=true), HideResult=true);
      parameter Integer nOut(min=0) = 0 "Number of output connections" annotation(Dialog(connectorSizing=true), HideResult=true);

      /* localActive is introduced since component 'Step' has Boolean variable 'active'
     and component 'StepWithSignal' has connector instance 'active' defined
     and both components inherit from PartialStep
  */
      output Boolean localActive
          "= true, if step is active, otherwise the step is not active"
        annotation (HideResult=true);
      Interfaces.Step_in inPort[nIn] "Vector of step input connectors"
        annotation (Placement(transformation(extent={{-120,10},{-100,-10}})));
      Interfaces.Step_out outPort[nOut] "Vector of step output connectors"
        annotation (Placement(transformation(extent={{100,5},{110,-5}})));
  protected
      outer Interfaces.CompositeStepState stateGraphRoot;
      model OuterStatePort
        CompositeStepStatePort_in subgraphStatePort;
        input Boolean localActive;
      equation
        subgraphStatePort.activeSteps = if localActive then 1.0 else 0.0;
      end OuterStatePort;
      OuterStatePort outerStatePort(localActive=localActive);

      Boolean newActive "Value of active in the next iteration"
        annotation (HideResult=true);
      Boolean oldActive "Value of active when CompositeStep was aborted";
    initial equation
      pre(newActive) = pre(localActive);
      pre(oldActive) = pre(localActive);
    equation
      connect(outerStatePort.subgraphStatePort, stateGraphRoot.subgraphStatePort);

      // Check that connections to the connector are correct
      for i in 1:nIn loop

      assert(cardinality(inPort[i]) <= 1,
             "Connector is connected to more than one transition (this is not allowed)");
      end for;

      for i in 1:nOut loop

      assert(cardinality(outPort[i]) <= 1,
             "Connector is connected to more than one transition (this is not allowed)");
      end for;

      // set active state
      localActive = pre(newActive);
      newActive = if outerStatePort.subgraphStatePort.resume then
                       oldActive else
                       ( Modelica.Math.BooleanVectors.anyTrue(inPort.set) or
                            localActive
                         and not Modelica.Math.BooleanVectors.anyTrue(outPort.reset))
                       and not outerStatePort.subgraphStatePort.suspend;

      // Remember state for suspend action
      when outerStatePort.subgraphStatePort.suspend then
        oldActive = localActive;
      end when;

      // Report state to input and output transitions
      for i in 1:nIn loop
        inPort[i].occupied = if i == 1 then localActive else
                                            inPort[i-1].occupied or
                                            inPort[i-1].set;
      end for;

      for i in 1:nOut loop
         outPort[i].available = if i == 1 then localActive else
                                               outPort[i-1].available and not
                                               outPort[i-1].reset;
      end for;

      // Default setting, if an inPort or an outPort is not connected
      for i in 1:nIn loop
        if cardinality(inPort[i]) == 0 then
          inPort[i].set = false;
        end if;
      end for;

      for i in 1:nOut loop
        if cardinality(outPort[i]) == 0 then
          outPort[i].reset = false;
        end if;
      end for;
    end PartialStep;

    partial block PartialTransition
        "Partial transition with input and output connections"
      input Boolean localCondition "= true, if transition may fire"
        annotation (HideResult=true);
      parameter Boolean enableTimer=false "= true, if timer is enabled"
        annotation (Evaluate=true, Dialog(group="Timer"));
      parameter SI.Time waitTime(min=0) = 0
          "Wait time before transition fires"
        annotation (Dialog(group="Timer", enable=enableTimer));
      output SI.Time t
          "Actual waiting time (transition will fire when t > waitTime)";
      output Boolean enableFire "= true, if all firing conditions are true";
      output Boolean fire "= true, if transition fires" annotation (HideResult=true);

      StateGraph.Interfaces.Transition_in inPort
          "Vector of transition input connectors"
        annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
      StateGraph.Interfaces.Transition_out outPort
          "Vector of transition output connectors"
        annotation (Placement(transformation(extent={{10,-5},{20,5}})));
  protected
      discrete SI.Time t_start
          "Time instant at which the transition would fire, if waitTime would be zero";
      Real t_dummy;
    initial equation
      pre(t_start) = time;
      pre(enableFire) = false;
    equation
      assert(cardinality(inPort) == 1,
        "Connector inPort is not connected to exactly one other connector");
      assert(cardinality(outPort) == 1,
        "Connector outPort is not connected to exactly one other connector");

      // Handling of Timer
      if enableTimer then
        when enableFire then
          t_start = time;
        end when;
        t_dummy = time - t_start;
        t = if enableFire then t_dummy else 0;
        fire = enableFire and time >= t_start + waitTime;
      else
        when false then
          t_start = pre(t_start);
        end when;
        t_dummy = 0;
        t = 0;
        fire = enableFire;
      end if;

      // Determine fire setting and report it to the connected step
      enableFire = localCondition and inPort.available and not outPort.occupied;
      inPort.reset = fire;
      outPort.set = fire;
    end PartialTransition;

    model CompositeStepState
        "Communication channel between CompositeSteps and steps in the CompositeStep"

      output Boolean suspend = false "= true, if suspend transition of CompositeStep fires";
      output Boolean resume =  false "= true, if resume transition of CompositeStep fires";
      CompositeStepStatePort_out subgraphStatePort;

    /*
    missingInnerMessage="No \"stateGraphRoot\" component is defined on highest level
of the StateGraph. A stateGraphRoot component is automatically introduced.
In order to get rid of this message, drag StateGraph.StateGraphRoot into the
top level your model.");
*/
    equation
      suspend = subgraphStatePort.suspend;
      resume  = subgraphStatePort.resume;
      subgraphStatePort.activeStepsDummy = 0;
      annotation (
        defaultComponentName="stateGraphRoot",
        defaultComponentPrefixes="inner",
        missingInnerMessage="A \"stateGraphRoot\" component was automatically introduced.");
    end CompositeStepState;
  end Interfaces;

  block InitialStepWithSignal
      "Initial step (= step that is active when simulation starts). Connector 'active' is true when the step is active"

    extends Interfaces.PartialStep;

    Modelica.Blocks.Interfaces.BooleanOutput active
      annotation (Placement(transformation(
            origin={0,-110},
            extent={{-10,-10},{10,10}},
            rotation=270)));
  initial equation
    active = true;
  equation
    active = localActive;
    annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}}), Rectangle(extent={{-80,80},{80,-80}})}),
         Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              textColor={0,0,255}),
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor=DynamicSelect({255,255,255}, if active then {0,255,0} else {255,255,255}),
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-92,-50},{94,-68}},
              textString="active"),
            Rectangle(extent={{-80,80},{80,-80}})}));
  end InitialStepWithSignal;

  block Step "Ordinary step (= step that is not active when simulation starts)"

    output Boolean active
        "= true, if step is active, otherwise the step is not active";

    extends Interfaces.PartialStep;

  initial equation
    active = false;
  equation
    active = localActive;
    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              textColor={0,0,255}), Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor=DynamicSelect({255,255,255}, if active then {0,255,0} else {255,255,255}),
              fillPattern=FillPattern.Solid)}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}})}));
  end Step;

  block Transition
      "Transition where the fire condition is set by a modification of variable condition"

    input Boolean condition=true
        "= true, if transition may fire (time varying expression)"
      annotation (Dialog(group="Fire condition"));

    extends Interfaces.PartialTransition(final localCondition=condition);

    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              extent={{-10,100},{10,-100}},
              fillColor=DynamicSelect({0,0,0}, if enableFire then {0,255,0} else {0,0,0}),
              fillPattern=FillPattern.Solid),
            Line(points={{-30,0},{-10,0}}),
            Text(
              extent={{200,110},{-200,150}},
              textString="%name",
              textColor={0,0,255}),
            Text(
              visible=enableTimer,
              extent={{20,20},{200,45}},
              textString="%waitTime"),
            Text(
              extent={{-200,-120},{200,-145}},
              textColor=DynamicSelect({0,0,0}, if condition then {0,255,0} else {0,0,0}),
              textString="%condition")}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Line(points={{-31,0},{-11,0}}),
              Rectangle(
              extent={{-10,100},{10,-100}},
              fillPattern=FillPattern.Solid)}));

  end Transition;

  model StateGraphRoot
      "Root of a StateGraph (has to be present on the highest level of a StateGraph)"

    extends StateGraph.Interfaces.CompositeStepState;
    output Integer activeSteps "Number of active steps within the stategraph";

  equation
    activeSteps = -integer(subgraphStatePort.activeSteps);
    annotation (
      defaultComponentName="stateGraphRoot",
      defaultComponentPrefixes="inner",
      Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              textColor={0,0,255}),
            Rectangle(
              extent={{-100,100},{100,-100}}),
            Text(
              extent={{-92,78},{96,34}},
              textString="root"),
            Rectangle(extent={{-82,-6},{-44,-40}}),
            Line(points={{0,10},{0,-60}}),
            Rectangle(extent={{48,-6},{86,-40}}),
            Polygon(
              points={{-12,-16},{0,-22},{-12,-28},{-12,-16}},
              fillPattern=FillPattern.Solid),
            Line(points={{-44,-22},{-12,-22}}),
            Polygon(
              points={{36,-16},{48,-22},{36,-28},{36,-16}},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-22},{36,-22}})}),
      Documentation(info="<html>
<p>
On the highest level of a StateGraph, an instance of StateGraphRoot
has to be present.
</p>
<p>
The StateGraphRoot object is needed, since all Step objects have
an \"outer\" reference to communicate with the \"nearest\" CompositeStep
(which inherits from PartialCompositeStep), especially to abort
a CompositeStep via the \"suspend\" port. Even if no \"CompositeStep\" is present,
on highest level a corresponding \"inner\" definition is needed
and is provided by the StateGraphRoot object.
</p>
</html>"));
  end StateGraphRoot;
  annotation (
    Documentation(info="<html>
<p>
Note, there is a much improved version of this library called
\"Modelica_StateGraph2\". If this library is not yet distributed with your
Modelica tool, you can download it from
<a href=\"https://github.com/modelica/Modelica_StateGraph2\">https://github.com/modelica/Modelica_StateGraph2</a>.
In the
<a href=\"modelica://Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2\">Users Guide</a>
a detailed comparison is given. It is highly recommended to use Modelica_StateGraph2 instead
of Modelica.StateGraph.
</p>

<p>
Library <strong>StateGraph</strong> is a <strong>free</strong> Modelica package providing
components to model <strong>discrete event</strong> and <strong>reactive</strong>
systems in a convenient
way. It is based on the JGrafchart method and
takes advantage of Modelica features for
the \"action\" language. JGrafchart is a further development of
Grafcet to include elements of StateCharts that are not present
in Grafcet/Sequential Function Charts. Therefore, the StateGraph
library has a similar modeling power as StateCharts but avoids
some deficiencies of StateCharts.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.StateGraph.UsersGuide\">StateGraph.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <a href=\"modelica://Modelica.StateGraph.Examples\">StateGraph.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
A typical model generated with this library is shown
in the next figure where on the left hand side a two-tank
system with a tank controller and on the right hand side the
top-level part of the tank controller as a StateGraph is shown:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/StateGraph/UsersGuide/ControlledTanks1_small.png\">

<img src=\"modelica://Modelica/Resources/Images/StateGraph/UsersGuide/ControlledTanks2_small.png\">
</p>

<p>
The unique feature of the StateGraph library with respect to JGrafcharts,
Grafcet, Sequential Function Charts, and StateCharts, is Modelica's
\"single assignment rule\" that requires that every variable is defined
by exactly one equation. This leads to a different \"action\" definition
as in these formalisms. The advantage is that the translator can either
determine a useful evaluation sequence by equation sorting or
reports an error if this is not possible, e.g., because a model
would lead to a non-determinism or to a dead-lock. As a side effect,
this leads also to simpler and more easier to understand models and
global variables are no longer needed (whereas in JGrafcharts,
Grafcet, Sequential Function Charts and StateCharts global variables
are nearly always needed).
</p>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>"),   Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={-70.0,-0.0},
          fillColor={255,255,255},
          extent={{-20.0,-20.0},{20.0,20.0}}),
        Rectangle(
          origin={70.0,-0.0},
          fillColor={255,255,255},
          extent={{-20.0,-20.0},{20.0,20.0}}),
        Line(points={{0.0,50.0},{0.0,-50.0}}),
        Polygon(
          origin={-16.6667,0.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-3.3333,10.0},{16.667,0.0},{-3.3333,-10.0}}),
        Line(origin={-35.0,0.0}, points={{15.0,0.0},{-15.0,0.0}}),
        Polygon(
          origin={33.3333,0.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-3.3333,10.0},{16.667,0.0},{-3.3333,-10.0}}),
        Line(origin={15.0,-0.0},  points={{15.0,0.0},{-15.0,-0.0}})}));
  end StateGraph;

  package Fluid
  "Library of 1-dim. thermo-fluid flow models using the Modelica.Media media description"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;
    import Cv = Modelica.Units.Conversions;

    package Vessels "Devices for storing fluid"
        extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Base classes used in the Vessels package (only of interest to build new component models)"
        extends Modelica.Icons.BasesPackage;

        connector VesselFluidPorts_b
          "Fluid connector with outlined, large icon to be used for horizontally aligned vectors of FluidPorts (vector dimensions must be added after dragging)"
          extends Interfaces.FluidPort;
          annotation (defaultComponentName="ports_b",
                      Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                initialScale=0.2), graphics={
                Text(extent={{-75,130},{75,100}}, textString="%name"),
                Rectangle(
                  extent={{-25,100},{25,-100}}),
                Ellipse(
                  extent={{-22,100},{-10,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-20,-69},{-12,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,100},{6,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{10,100},{22,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,-69},{4,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{12,-69},{20,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
               Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                initialScale=0.2), graphics={
                Rectangle(
                  extent={{-50,200},{50,-200}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-44,200},{-20,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-12,200},{12,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{20,200},{44,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-39,-118.5},{-25,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-7,-118.5},{7,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{25,-117.5},{39,114}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end VesselFluidPorts_b;
      end BaseClasses;
      annotation (Documentation(info="<html>

</html>"));
    end Vessels;

    package Interfaces
    "Interfaces for steady state and unsteady, mixed-phase, multi-substance, incompressible and compressible flow"
      extends Modelica.Icons.InterfacesPackage;

      connector FluidPort
        "Interface for quasi one-dimensional fluid flow in a piping network (incompressible or compressible, one or more phases, one or more substances)"

        replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
          "Medium model" annotation (choicesAllMatching=true);

        flow Medium.MassFlowRate m_flow
          "Mass flow rate from the connection point into the component";
        Medium.AbsolutePressure p "Thermodynamic pressure in the connection point";
        stream Medium.SpecificEnthalpy h_outflow
          "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        stream Medium.MassFraction Xi_outflow[Medium.nXi]
          "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        stream Medium.ExtraProperty C_outflow[Medium.nC]
          "Properties c_i/m close to the connection point if m_flow < 0";
      end FluidPort;

      connector FluidPort_a "Generic fluid connector at design inlet"
        extends FluidPort;
        annotation (defaultComponentName="port_a",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Ellipse(
                extent={{-40,40},{40,-40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Text(extent={{-150,110},{150,50}},
                  textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_a;

      connector FluidPort_b "Generic fluid connector at design outlet"
        extends FluidPort;
        annotation (defaultComponentName="port_b",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Ellipse(
                extent={{-40,40},{40,-40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(extent={{-150,110},{150,50}}, textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={
              Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-80,80},{80,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_b;

      connector FluidPorts_b
        "Fluid connector with outlined, large icon to be used for vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends FluidPort;
        annotation (defaultComponentName="ports_b",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{-25,100},{25,-100}}),
              Ellipse(
                extent={{-25,90},{25,40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,25},{25,-25}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,-40},{25,-90}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,-50},{15,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,15},{15,-15}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,50},{15,80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-50,200},{50,-200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,180},{50,80}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,50},{50,-50}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,-80},{50,-180}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,100},{30,160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,-100},{30,-160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPorts_b;
      annotation (Documentation(info="<html>

</html>",     revisions="<html>
<ul>
<li><em>June 9th, 2008</em>
       by Michael Sielemann: Introduced stream keyword after decision at 57th Design Meeting (Lund).</li>
<li><em>May 30, 2007</em>
       by Christoph Richter: moved everything back to its original position in Modelica.Fluid.</li>
<li><em>Apr. 20, 2007</em>
       by Christoph Richter: moved parts of the original package from Modelica.Fluid
       to the development branch of Modelica 2.2.2.</li>
<li><em>Nov. 2, 2005</em>
       by Francesco Casella: restructured after 45th Design Meeting.</li>
<li><em>Nov. 20-21, 2002</em>
       by Hilding Elmqvist, Mike Tiller, Allan Watson, John Batteh, Chuck Newman,
       Jonas Eborn: Improved at the 32nd Modelica Design Meeting.</li>
<li><em>Nov. 11, 2002</em>
       by Hilding Elmqvist, Martin Otter: improved version.</li>
<li><em>Nov. 6, 2002</em>
       by Hilding Elmqvist: first version.</li>
<li><em>Aug. 11, 2002</em>
       by Martin Otter: Improved according to discussion with Hilding
       Elmqvist and Hubertus Tummescheit.<br>
       The PortVicinity model is manually
       expanded in the base models.<br>
       The Volume used for components is renamed
       PartialComponentVolume.<br>
       A new volume model \"Fluid.Components.PortVolume\"
       introduced that has the medium properties of the port to which it is
       connected.<br>
       Fluid.Interfaces.PartialTwoPortTransport is a component
       for elementary two port transport elements, whereas PartialTwoPort
       is a component for a container component.</li>
</ul>
</html>"));
    end Interfaces;

    package Types "Common types for fluid models"
      extends Modelica.Icons.TypesPackage;

      type Dynamics = enumeration(
          DynamicFreeInitial
            "DynamicFreeInitial -- Dynamic balance, Initial guess value",
          FixedInitial "FixedInitial -- Dynamic balance, Initial value fixed",
          SteadyStateInitial
            "SteadyStateInitial -- Dynamic balance, Steady state initial with guess value",
          SteadyState "SteadyState -- Steady state balance, Initial guess value")
        "Enumeration to define definition of balance equations"
      annotation (Documentation(info="<html>
<p>
Enumeration to define the formulation of balance equations
(to be selected via choices menu):
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><th><strong>Dynamics.</strong></th><th><strong>Meaning</strong></th></tr>
<tr><td>DynamicFreeInitial</td><td>Dynamic balance, Initial guess value</td></tr>

<tr><td>FixedInitial</td><td>Dynamic balance, Initial value fixed</td></tr>

<tr><td>SteadyStateInitial</td><td>Dynamic balance, Steady state initial with guess value</td></tr>

<tr><td>SteadyState</td><td>Steady state balance, Initial guess value</td></tr>
</table>

<p>
The enumeration \"Dynamics\" is used for the mass, energy and momentum balance equations
respectively. The exact meaning for the three balance equations is stated in the following
tables:
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><td colspan=\"3\"><strong>Mass balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> <strong>if</strong> Medium.singleState <strong>then</strong><br>
         &nbsp;&nbsp;no initial condition<br>
         <strong>else</strong> p=p_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>if</strong> Medium.singleState <strong>then</strong><br>
         &nbsp;&nbsp;no initial condition<br>
         <strong>else</strong> <strong>der</strong>(p)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(m)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><td colspan=\"3\"><strong>Energy balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> T=T_start or h=h_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>der</strong>(T)=0 or <strong>der</strong>(h)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(U)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><td colspan=\"3\"><strong>Momentum balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> m_flow = m_flow_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>der</strong>(m_flow)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(m_flow)=0 </td>
    <td> no initial conditions </td></tr>
</table>

<p>
In the tables above, the equations are given for one-substance fluids. For multiple-substance
fluids and for trace substances, equivalent equations hold.
</p>

<p>
Medium.singleState is a medium property and defines whether the medium is only
described by one state (+ the mass fractions in case of a multi-substance fluid). In such
a case one initial condition less must be provided. For example, incompressible
media have Medium.singleState = <strong>true</strong>.
</p>

</html>"));

      type PortFlowDirection = enumeration(
          Entering "Fluid flow is only entering",
          Leaving "Fluid flow is only leaving",
          Bidirectional "No restrictions on fluid flow (flow reversal possible)")
        "Enumeration to define whether flow reversal is allowed" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the assumptions on the model for the
direction of fluid flow at a port (to be selected via choices menu):
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><th><strong>PortFlowDirection.</strong></th>
    <th><strong>Meaning</strong></th></tr>

<tr><td>Entering</td>
    <td>Fluid flow is only entering the port from the outside</td></tr>

<tr><td>Leaving</td>
    <td>Fluid flow is only leaving the port to the outside</td></tr>

<tr><td>Bidirectional</td>
    <td>No restrictions on fluid flow (flow reversal possible)</td></tr>
</table>

<p>
The default is \"PortFlowDirection.Bidirectional\". If you are completely sure that
the flow is only in one direction, then the other settings may
make the simulation of your model faster.
</p>

</html>"));
      annotation (preferredView="info",
                  Documentation(info="<html>

</html>"));
    end Types;

    package Utilities
    "Utility models to construct fluid components (should not be used directly)"
      extends Modelica.Icons.UtilitiesPackage;

      function checkBoundary "Check whether boundary definition is correct"
        extends Modelica.Icons.Function;
        input String mediumName;
        input String substanceNames[:] "Names of substances";
        input Boolean singleState;
        input Boolean define_p;
        input Real X_boundary[:];
        input String modelName = "??? boundary ???";
    protected
        Integer nX = size(X_boundary,1);
        String X_str;
      algorithm
        assert(not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""     + modelName + "\":
The selected medium \""     + mediumName + "\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");

        for i in 1:nX loop
          assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""
      + mediumName + "\" in model \"" + modelName + "\":
The boundary value X_boundary("   + String(i) + ") = " + String(
            X_boundary[i]) + "
is negative. It must be positive.
");     end for;

        if nX > 0 and abs(sum(X_boundary) - 1.0) > 1e-10 then
           X_str :="";
           for i in 1:nX loop
              X_str :=X_str + "   X_boundary[" + String(i) + "] = " + String(X_boundary[
              i]) + " \"" + substanceNames[i] + "\"\n";
           end for;
           Modelica.Utilities.Streams.error(
              "The boundary mass fractions in medium \"" + mediumName + "\" in model \"" + modelName + "\"\n" +
              "do not sum up to 1. Instead, sum(X_boundary) = " + String(sum(X_boundary)) + ":\n"
              + X_str);
        end if;
      end checkBoundary;

      function regStep
        "Approximation of a general step, such that the characteristic is continuous and differentiable"
        extends Modelica.Icons.Function;
        input Real x "Abscissa value";
        input Real y1 "Ordinate value for x > 0";
        input Real y2 "Ordinate value for x < 0";
        input Real x_small(min=0) = 1e-5
          "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
        output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
      algorithm
        y := smooth(1, if x >  x_small then y1 else
                       if x < -x_small then y2 else
                       if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
        annotation(Documentation(revisions="<html>
<ul>
<li><em>April 29, 2008</em>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><em>August 12, 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",       info="<html>
<p>
This function is used to approximate the equation
</p>
<blockquote><pre>
y = <strong>if</strong> x &gt; 0 <strong>then</strong> y1 <strong>else</strong> y2;
</pre></blockquote>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<blockquote><pre>
y = <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> y1 <strong>else</strong>
              <strong>if</strong> x &lt; -x_small <strong>then</strong> y2 <strong>else</strong> f(y1, y2));
</pre></blockquote>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>
</html>"));
      end regStep;

      function cubicHermite "Evaluate a cubic Hermite spline"
        extends Modelica.Icons.Function;

        input Real x "Abscissa value";
        input Real x1 "Lower abscissa value";
        input Real x2 "Upper abscissa value";
        input Real y1 "Lower ordinate value";
        input Real y2 "Upper ordinate value";
        input Real y1d "Lower gradient";
        input Real y2d "Upper gradient";
        output Real y "Interpolated ordinate value";
    protected
        Real h "Distance between x1 and x2";
        Real t "Abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
        Real h00 "Basis function 00 of cubic Hermite spline";
        Real h10 "Basis function 10 of cubic Hermite spline";
        Real h01 "Basis function 01 of cubic Hermite spline";
        Real h11 "Basis function 11 of cubic Hermite spline";
        Real aux3 "t cube";
        Real aux2 "t square";
      algorithm
        h := x2 - x1;
        if abs(h)>0 then
          // Regular case
          t := (x - x1)/h;

          aux3 :=t^3;
          aux2 :=t^2;

          h00 := 2*aux3 - 3*aux2 + 1;
          h10 := aux3 - 2*aux2 + t;
          h01 := -2*aux3 + 3*aux2;
          h11 := aux3 - aux2;
          y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
        else
          // Degenerate case, x1 and x2 are identical, return step function
          y := (y1 + y2)/2;
        end if;
        annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><em>May 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end cubicHermite;
      annotation (Documentation(info="<html>

</html>"));
    end Utilities;
  annotation (Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}}),
          Line(points={{2,42},{2,-10}}),
          Rectangle(
            extent={{-18,50},{22,42}},
            fillPattern=FillPattern.Solid)}), preferredView="info",
    Documentation(info="<html>
<p>
Library <strong>Modelica.Fluid</strong> is a <strong>free</strong> Modelica package providing components for
<strong>1-dimensional thermo-fluid flow</strong> in networks of vessels, pipes, fluid machines, valves and fittings.
A unique feature is that the component equations and the media models
as well as pressure loss and heat transfer correlations are decoupled from each other.
All components are implemented such that they can be used for
media from the Modelica.Media library. This means especially that an
incompressible or compressible medium, a single or a multiple
substance medium with one or more phases might be used.
</p>

<p>
In the next figure, several features of the library are demonstrated with
a simple heating system with a closed flow cycle. By just changing one configuration parameter in the system object the equations are changed between steady-state and dynamic simulation with fixed or steady-state initial conditions.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/HeatingSystem.png\" border=\"1\"
     alt=\"HeatingSystem.png\">
</p>

<p>
With respect to previous versions, the design
of the connectors has been changed in a non-backward compatible way,
using the recently developed concept
of stream connectors that results in much more reliable simulations
(see also <a href=\"modelica://Modelica/Resources/Documentation/Fluid/Stream-Connectors-Overview-Rationale.pdf\">Stream-Connectors-Overview-Rationale.pdf</a>).
This extension was included in Modelica 3.1.
</p>

<p>
The following parts are useful, when newly starting with this library:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide\">Modelica.Fluid.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide.ReleaseNotes\">Modelica.Fluid.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Fluid.Examples\">Modelica.Fluid.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 2002-2020, Modelica Association and contributors
</p>
</html>"));
  end Fluid;

  package Media "Library of media property models"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;
    import Cv = Modelica.Units.Conversions;

  package Interfaces "Interfaces for media models"
    extends Modelica.Icons.InterfacesPackage;

    partial package PartialMedium
      "Partial medium properties (base package of all media packages)"
      extends Modelica.Media.Interfaces.Types;
      extends Modelica.Icons.MaterialPropertiesPackage;

      // Constants to be set in Medium
      constant Modelica.Media.Interfaces.Choices.IndependentVariables
        ThermoStates "Enumeration type for independent variables";
      constant String mediumName="unusablePartialMedium" "Name of the medium";
      constant String substanceNames[:]={mediumName}
        "Names of the mixture substances. Set substanceNames={mediumName} if only one substance.";
      constant String extraPropertiesNames[:]=fill("", 0)
        "Names of the additional (extra) transported properties. Set extraPropertiesNames=fill(\"\",0) if unused";
      constant Boolean singleState
        "= true, if u and d are not a function of pressure";
      constant Boolean reducedX=true
        "= true if medium contains the equation sum(X) = 1.0; set reducedX=true if only one substance (see docu for details)";
      constant Boolean fixedX=false
        "= true if medium contains the equation X = reference_X";
      constant AbsolutePressure reference_p=101325
        "Reference pressure of Medium: default 1 atmosphere";
      constant Temperature reference_T=298.15
        "Reference temperature of Medium: default 25 deg Celsius";
      constant MassFraction reference_X[nX]=fill(1/nX, nX)
        "Default mass fractions of medium";
      constant AbsolutePressure p_default=101325
        "Default value for pressure of medium (for initialization)";
      constant Temperature T_default=Modelica.Units.Conversions.from_degC(20)
        "Default value for temperature of medium (for initialization)";
      constant SpecificEnthalpy h_default=specificEnthalpy_pTX(
              p_default,
              T_default,
              X_default)
        "Default value for specific enthalpy of medium (for initialization)";
      constant MassFraction X_default[nX]=reference_X
        "Default value for mass fractions of medium (for initialization)";
      constant ExtraProperty C_default[nC]=fill(0, nC)
        "Default value for trace substances of medium (for initialization)";

      final constant Integer nS=size(substanceNames, 1) "Number of substances";
      constant Integer nX=nS "Number of mass fractions";
      constant Integer nXi=if fixedX then 0 else if reducedX then nS - 1 else nS
        "Number of structurally independent mass fractions (see docu for details)";

      final constant Integer nC=size(extraPropertiesNames, 1)
        "Number of extra (outside of standard mass-balance) transported properties";
      constant Real C_nominal[nC](min=fill(Modelica.Constants.eps, nC)) = 1.0e-6*
        ones(nC) "Default for the nominal values for the extra properties";
      replaceable record FluidConstants =
          Modelica.Media.Interfaces.Types.Basic.FluidConstants
        "Critical, triple, molecular and other standard data of fluid";

      replaceable record ThermodynamicState
        "Minimal variable set that is available as input argument to every medium function"
        extends Modelica.Icons.Record;
      end ThermodynamicState;

      replaceable partial model BaseProperties
        "Base properties (p, d, T, h, u, R_s, MM and, if applicable, X and Xi) of a medium"
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi(start=reference_X[1:nXi])
          "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Density d "Density of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
          "Mass fractions (= (component mass)/total mass  m_i/m)";
        SpecificInternalEnergy u "Specific internal energy of medium";
        SpecificHeatCapacity R_s "Gas constant (of mixture if applicable)";
        MolarMass MM "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
          "Thermodynamic state record for optional functions";
        parameter Boolean preferredMediumStates=false
          "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean standardOrderComponents=true
          "If true, and reducedX = true, the last element of X will be computed from the other ones";
        Modelica.Units.NonSI.Temperature_degC T_degC=
            Modelica.Units.Conversions.to_degC(T)
          "Temperature of medium in [degC]";
        Modelica.Units.NonSI.Pressure_bar p_bar=
            Modelica.Units.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input SI.AbsolutePressure
          "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input SI.SpecificEnthalpy
          "Specific enthalpy as input signal connector";
        connector InputMassFraction = input SI.MassFraction
          "Mass fraction as input signal connector";

      equation
        if standardOrderComponents then
          Xi = X[1:nXi];

          if fixedX then
            X = reference_X;
          end if;
          if reducedX and not fixedX then
            X[nX] = 1 - sum(Xi);
          end if;
          for i in 1:nX loop
            assert(X[i] >= -1.e-5 and X[i] <= 1 + 1.e-5, "Mass fraction X[" +
              String(i) + "] = " + String(X[i]) + "of substance " +
              substanceNames[i] + "\nof medium " + mediumName +
              " is not in the range 0..1");
          end for;

        end if;

        assert(p >= 0.0, "Pressure (= " + String(p) + " Pa) of medium \"" +
          mediumName + "\" is negative\n(Temperature = " + String(T) + " K)");
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}), Text(
                extent={{-152,164},{152,102}},
                textString="%name",
                textColor={0,0,255})}), Documentation(info="<html>
<p>
Model <strong>BaseProperties</strong> is a model within package <strong>PartialMedium</strong>
and contains the <strong>declarations</strong> of the minimum number of
variables that every medium model is supposed to support.
A specific medium inherits from model <strong>BaseProperties</strong> and provides
the equations for the basic properties.</p>
<p>
The BaseProperties model contains the following <strong>7+nXi variables</strong>
(nXi is the number of independent mass fractions defined in package
PartialMedium):
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>Temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>Absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>Density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>Specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>Specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>Structurally independent mass fractions</td></tr>
  <tr><td>R_s</td>
      <td>J/(kg.K)</td>
      <td>Specific gas constant (of mixture if applicable)</td></tr>
  <tr><td>MM</td>
      <td>kg/mol</td>
      <td>Molar mass</td></tr>
</table>
<p>
In order to implement an actual medium model, one can extend from this
base model and add <strong>5 equations</strong> that provide relations among
these variables. Equations will also have to be added in order to
set all the variables within the ThermodynamicState record state.</p>
<p>
If standardOrderComponents=true, the full composition vector X[nX]
is determined by the equations contained in this base class, depending
on the independent mass fraction vector Xi[nXi].</p>
<p>Additional <strong>2 + nXi</strong> equations will have to be provided
when using the BaseProperties model, in order to fully specify the
thermodynamic conditions. The input connector qualifier applied to
p, h, and nXi indirectly declares the number of missing equations,
permitting advanced equation balance checking by Modelica tools.
Please note that this doesn't mean that the additional equations
should be connection equations, nor that exactly those variables
should be supplied, in order to complete the model.
For further information, see the <a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media User's guide</a>, and
<a href=\"https://specification.modelica.org/v3.4/Ch4.html#balanced-models\">Section 4.7 (Balanced Models) of the Modelica 3.4 specification</a>.</p>
</html>"));
      end BaseProperties;

      replaceable partial function setState_pTX
        "Return thermodynamic state as function of p, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_pTX;

      replaceable partial function setState_phX
        "Return thermodynamic state as function of p, h and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_phX;

      replaceable partial function setState_psX
        "Return thermodynamic state as function of p, s and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_psX;

      replaceable partial function setState_dTX
        "Return thermodynamic state as function of d, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_dTX;

      replaceable partial function setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
        extends Modelica.Icons.Function;
        input Real x "m_flow or dp";
        input ThermodynamicState state_a "Thermodynamic state if x > 0";
        input ThermodynamicState state_b "Thermodynamic state if x < 0";
        input Real x_small(min=0)
          "Smooth transition in the region -x_small < x < x_small";
        output ThermodynamicState state
          "Smooth thermodynamic state for all x (continuous and differentiable)";
        annotation (Documentation(info="<html>
<p>
This function is used to approximate the equation
</p>
<blockquote><pre>
state = <strong>if</strong> x &gt; 0 <strong>then</strong> state_a <strong>else</strong> state_b;
</pre></blockquote>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<blockquote><pre>
state := <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> state_a <strong>else</strong>
                   <strong>if</strong> x &lt; -x_small <strong>then</strong> state_b <strong>else</strong> f(state_a, state_b));
</pre></blockquote>

<p>
This is performed by applying function <strong>Media.Common.smoothStep</strong>(..)
on every element of the thermodynamic state record.
</p>

<p>
If <strong>mass fractions</strong> X[:] are approximated with this function then this can be performed
for all <strong>nX</strong> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(state.X) = 1, provided sum(state_a.X) = sum(state_b.X) = 1.
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise state.X is either state_a.X or state_b.X):
</p>

<blockquote><pre>
X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
   ...
X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre></blockquote>

<p>
or
</p>

<blockquote><pre>
X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
   ...
X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre></blockquote>

<p>
Summing all mass fractions together results in
</p>

<blockquote><pre>
sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
       = c*(1 - 1) + (1 + 1)/2
       = 1
</pre></blockquote>

</html>"));
      end setSmoothState;

      replaceable partial function dynamicViscosity "Return dynamic viscosity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DynamicViscosity eta "Dynamic viscosity";
      end dynamicViscosity;

      replaceable partial function thermalConductivity
        "Return thermal conductivity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output ThermalConductivity lambda "Thermal conductivity";
      end thermalConductivity;

      replaceable function prandtlNumber "Return the Prandtl number"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output PrandtlNumber Pr "Prandtl number";
      algorithm
        Pr := dynamicViscosity(state)*specificHeatCapacityCp(state)/
          thermalConductivity(state);
      end prandtlNumber;

      replaceable partial function pressure "Return pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output AbsolutePressure p "Pressure";
      end pressure;

      replaceable partial function temperature "Return temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Temperature T "Temperature";
      end temperature;

      replaceable partial function density "Return density"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Density d "Density";
      end density;

      replaceable partial function specificEnthalpy "Return specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnthalpy h "Specific enthalpy";
      end specificEnthalpy;

      replaceable partial function specificInternalEnergy
        "Return specific internal energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy u "Specific internal energy";
      end specificInternalEnergy;

      replaceable partial function specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEntropy s "Specific entropy";
      end specificEntropy;

      replaceable partial function specificGibbsEnergy
        "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy g "Specific Gibbs energy";
      end specificGibbsEnergy;

      replaceable partial function specificHelmholtzEnergy
        "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy f "Specific Helmholtz energy";
      end specificHelmholtzEnergy;

      replaceable partial function specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
      end specificHeatCapacityCp;

      function heatCapacity_cp = specificHeatCapacityCp
        "Alias for deprecated name";

      replaceable partial function specificHeatCapacityCv
        "Return specific heat capacity at constant volume"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificHeatCapacity cv
          "Specific heat capacity at constant volume";
      end specificHeatCapacityCv;

      function heatCapacity_cv = specificHeatCapacityCv
        "Alias for deprecated name";

      replaceable partial function isentropicExponent
        "Return isentropic exponent"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output IsentropicExponent gamma "Isentropic exponent";
      end isentropicExponent;

      replaceable partial function isentropicEnthalpy
        "Return isentropic enthalpy"
        extends Modelica.Icons.Function;
        input AbsolutePressure p_downstream "Downstream pressure";
        input ThermodynamicState refState "Reference state for entropy";
        output SpecificEnthalpy h_is "Isentropic enthalpy";
        annotation (Documentation(info="<html>
<p>
This function computes an isentropic state transformation:
</p>
<ol>
<li> A medium is in a particular state, refState.</li>
<li> The enthalpy at another state (h_is) shall be computed
     under the assumption that the state transformation from refState to h_is
     is performed with a change of specific entropy ds = 0 and the pressure of state h_is
     is p_downstream and the composition X upstream and downstream is assumed to be the same.</li>
</ol>

</html>"));
      end isentropicEnthalpy;

      replaceable partial function velocityOfSound "Return velocity of sound"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output VelocityOfSound a "Velocity of sound";
      end velocityOfSound;

      replaceable partial function isobaricExpansionCoefficient
        "Return overall the isobaric expansion coefficient beta"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output IsobaricExpansionCoefficient beta "Isobaric expansion coefficient";
        annotation (Documentation(info="<html>
<blockquote><pre>
beta is defined as  1/v * der(v,T), with v = 1/d, at constant pressure p.
</pre></blockquote>
</html>"));
      end isobaricExpansionCoefficient;

      function beta = isobaricExpansionCoefficient
        "Alias for isobaricExpansionCoefficient for user convenience";

      replaceable partial function isothermalCompressibility
        "Return overall the isothermal compressibility factor"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SI.IsothermalCompressibility kappa "Isothermal compressibility";
        annotation (Documentation(info="<html>
<blockquote><pre>

kappa is defined as - 1/v * der(v,p), with v = 1/d at constant temperature T.

</pre></blockquote>
</html>"));
      end isothermalCompressibility;

      function kappa = isothermalCompressibility
        "Alias of isothermalCompressibility for user convenience";

      // explicit derivative functions for finite element models
      replaceable partial function density_derp_h
        "Return density derivative w.r.t. pressure at const specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByPressure ddph "Density derivative w.r.t. pressure";
      end density_derp_h;

      replaceable partial function density_derh_p
        "Return density derivative w.r.t. specific enthalpy at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByEnthalpy ddhp
          "Density derivative w.r.t. specific enthalpy";
      end density_derh_p;

      replaceable partial function density_derp_T
        "Return density derivative w.r.t. pressure at const temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByPressure ddpT "Density derivative w.r.t. pressure";
      end density_derp_T;

      replaceable partial function density_derT_p
        "Return density derivative w.r.t. temperature at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByTemperature ddTp
          "Density derivative w.r.t. temperature";
      end density_derT_p;

      replaceable partial function density_derX
        "Return density derivative w.r.t. mass fraction"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Density[nX] dddX "Derivative of density w.r.t. mass fraction";
      end density_derX;

      replaceable partial function molarMass
        "Return the molar mass of the medium"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output MolarMass MM "Mixture molar mass";
      end molarMass;

      replaceable function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_pTX(
                p,
                T,
                X));
        annotation (inverse(T=temperature_phX(
                      p,
                      h,
                      X)));
      end specificEnthalpy_pTX;

      replaceable function specificEntropy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEntropy s "Specific entropy";
      algorithm
        s := specificEntropy(setState_pTX(
                p,
                T,
                X));

        annotation (inverse(T=temperature_psX(
                      p,
                      s,
                      X)));
      end specificEntropy_pTX;

      replaceable function density_pTX "Return density from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(
                p,
                T,
                X));
      end density_pTX;

      replaceable function temperature_phX
        "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_phX(
                p,
                h,
                X));
      end temperature_phX;

      replaceable function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(
                p,
                h,
                X));
      end density_phX;

      replaceable function temperature_psX
        "Return temperature from p,s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_psX(
                p,
                s,
                X));
        annotation (inverse(s=specificEntropy_pTX(
                      p,
                      T,
                      X)));
      end temperature_psX;

      replaceable function density_psX "Return density from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_psX(
                p,
                s,
                X));
      end density_psX;

      replaceable function specificEnthalpy_psX
        "Return specific enthalpy from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_psX(
                p,
                s,
                X));
      end specificEnthalpy_psX;

      type MassFlowRate = SI.MassFlowRate (
          quantity="MassFlowRate." + mediumName,
          min=-1.0e5,
          max=1.e5) "Type for mass flow rate with medium specific attributes";

      annotation (Documentation(info="<html>
<p>
<strong>PartialMedium</strong> is a package and contains all <strong>declarations</strong> for
a medium. This means that constants, models, and functions
are defined that every medium is supposed to support
(some of them are optional). A medium package
inherits from <strong>PartialMedium</strong> and provides the
equations for the medium. The details of this package
are described in
<a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.
</p>
</html>",   revisions="<html>

</html>"));
    end PartialMedium;

    partial package PartialPureSubstance
      "Base class for pure substances of one chemical substance"
      extends PartialMedium(final reducedX=true, final fixedX=true);

      replaceable function setState_pT "Return thermodynamic state from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_pTX(
                p,
                T,
                fill(0, 0));
      end setState_pT;

      replaceable function setState_ph "Return thermodynamic state from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_phX(
                p,
                h,
                fill(0, 0));
      end setState_ph;

      replaceable function setState_ps "Return thermodynamic state from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_psX(
                p,
                s,
                fill(0, 0));
      end setState_ps;

      replaceable function setState_dT "Return thermodynamic state from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_dTX(
                d,
                T,
                fill(0, 0));
      end setState_dT;

      replaceable function density_ph "Return density from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Density d "Density";
      algorithm
        d := density_phX(
                p,
                h,
                fill(0, 0));
      end density_ph;

      replaceable function temperature_ph "Return temperature from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_phX(
                p,
                h,
                fill(0, 0));
      end temperature_ph;

      replaceable function pressure_dT "Return pressure from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output AbsolutePressure p "Pressure";
      algorithm
        p := pressure(setState_dTX(
                d,
                T,
                fill(0, 0)));
      end pressure_dT;

      replaceable function specificEnthalpy_dT
        "Return specific enthalpy from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_dTX(
                d,
                T,
                fill(0, 0)));
      end specificEnthalpy_dT;

      replaceable function specificEnthalpy_ps
        "Return specific enthalpy from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy_psX(
                p,
                s,
                fill(0, 0));
      end specificEnthalpy_ps;

      replaceable function temperature_ps "Return temperature from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_psX(
                p,
                s,
                fill(0, 0));
      end temperature_ps;

      replaceable function density_ps "Return density from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Density d "Density";
      algorithm
        d := density_psX(
                p,
                s,
                fill(0, 0));
      end density_ps;

      replaceable function specificEnthalpy_pT
        "Return specific enthalpy from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy_pTX(
                p,
                T,
                fill(0, 0));
      end specificEnthalpy_pT;

      replaceable function density_pT "Return density from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(
                p,
                T,
                fill(0, 0)));
      end density_pT;

      redeclare replaceable partial model extends BaseProperties(final
          standardOrderComponents=true)
      end BaseProperties;
    end PartialPureSubstance;

    partial package PartialMixtureMedium
      "Base class for pure substances of several chemical substances"
      extends PartialMedium(redeclare replaceable record FluidConstants =
            Modelica.Media.Interfaces.Types.IdealGas.FluidConstants);

      redeclare replaceable record extends ThermodynamicState
        "Thermodynamic state variables"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
          "Mass fractions (= (component mass)/total mass  m_i/m)";
      end ThermodynamicState;

      constant FluidConstants[nS] fluidConstants "Constant data for the fluid";

      replaceable function gasConstant
        "Return the gas constant of the mixture (also for liquids)"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        output SI.SpecificHeatCapacity R_s "Mixture gas constant";
      end gasConstant;

      function moleToMassFractions "Return mass fractions X from mole fractions"
        extends Modelica.Icons.Function;
        input SI.MoleFraction moleFractions[:] "Mole fractions of mixture";
        input MolarMass[:] MMX "Molar masses of components";
        output SI.MassFraction X[size(moleFractions, 1)]
          "Mass fractions of gas mixture";
    protected
        MolarMass Mmix=moleFractions*MMX "Molar mass of mixture";
      algorithm
        for i in 1:size(moleFractions, 1) loop
          X[i] := moleFractions[i]*MMX[i]/Mmix;
        end for;
        annotation (smoothOrder=5);
      end moleToMassFractions;

      function massToMoleFractions "Return mole fractions from mass fractions X"
        extends Modelica.Icons.Function;
        input SI.MassFraction X[:] "Mass fractions of mixture";
        input SI.MolarMass[:] MMX "Molar masses of components";
        output SI.MoleFraction moleFractions[size(X, 1)]
          "Mole fractions of gas mixture";
    protected
        Real invMMX[size(X, 1)] "Inverses of molar weights";
        SI.MolarMass Mmix "Molar mass of mixture";
      algorithm
        for i in 1:size(X, 1) loop
          invMMX[i] := 1/MMX[i];
        end for;
        Mmix := 1/(X*invMMX);
        for i in 1:size(X, 1) loop
          moleFractions[i] := Mmix*X[i]/MMX[i];
        end for;
        annotation (smoothOrder=5);
      end massToMoleFractions;

    end PartialMixtureMedium;

    partial package PartialCondensingGases
      "Base class for mixtures of condensing and non-condensing gases"
      extends PartialMixtureMedium(ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pTX);

      replaceable partial function saturationPressure
        "Return saturation pressure of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature Tsat "Saturation temperature";
        output AbsolutePressure psat "Saturation pressure";
      end saturationPressure;

      replaceable partial function enthalpyOfVaporization
        "Return vaporization enthalpy of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy r0 "Vaporization enthalpy";
      end enthalpyOfVaporization;

      replaceable partial function enthalpyOfLiquid
        "Return liquid enthalpy of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Liquid enthalpy";
      end enthalpyOfLiquid;

      replaceable partial function enthalpyOfGas
        "Return enthalpy of non-condensing gas mixture"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        input MassFraction[:] X "Vector of mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfGas;

      replaceable partial function enthalpyOfCondensingGas
        "Return enthalpy of condensing gas (most often steam)"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfCondensingGas;

      replaceable partial function enthalpyOfNonCondensingGas
        "Return enthalpy of the non-condensing species"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfNonCondensingGas;
    end PartialCondensingGases;

    partial package PartialSimpleMedium
      "Medium model with linear dependency of u, h from temperature. All other quantities, especially density, are constant."

      extends Interfaces.PartialPureSubstance(final ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
          final singleState=true);

      constant SpecificHeatCapacity cp_const
        "Constant specific heat capacity at constant pressure";
      constant SpecificHeatCapacity cv_const
        "Constant specific heat capacity at constant volume";
      constant Density d_const "Constant density";
      constant DynamicViscosity eta_const "Constant dynamic viscosity";
      constant ThermalConductivity lambda_const "Constant thermal conductivity";
      constant VelocityOfSound a_const "Constant velocity of sound";
      constant Temperature T_min "Minimum temperature valid for medium model";
      constant Temperature T_max "Maximum temperature valid for medium model";
      constant Temperature T0=reference_T "Zero enthalpy temperature";
      constant MolarMass MM_const "Molar mass";

      constant FluidConstants[nS] fluidConstants "Fluid constants";

      redeclare record extends ThermodynamicState "Thermodynamic state"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
      end ThermodynamicState;

      redeclare replaceable model extends BaseProperties(T(stateSelect=if
              preferredMediumStates then StateSelect.prefer else StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else
              StateSelect.default)) "Base properties"
      equation
        assert(T >= T_min and T <= T_max, "
Temperature T (= "   + String(T) + " K) is not
in the allowed range ("   + String(T_min) + " K <= T <= " + String(T_max) + " K)
required from medium model \""   + mediumName + "\".
");

        // h = cp_const*(T-T0);
        h = specificEnthalpy_pTX(
                p,
                T,
                X);
        u = cv_const*(T - T0);
        d = d_const;
        R_s = 0;
        MM = MM_const;
        state.T = T;
        state.p = p;
        annotation (Documentation(info="<html>
<p>
This is the most simple incompressible medium model, where
specific enthalpy h and specific internal energy u are only
a function of temperature T and all other provided medium
quantities are assumed to be constant.
Note that the (small) influence of the pressure term p/d is neglected.
</p>
</html>"));
      end BaseProperties;

      redeclare function setState_pTX
        "Return thermodynamic state from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=T);
      end setState_pTX;

      redeclare function setState_phX
        "Return thermodynamic state from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=T0 + h/cp_const);
      end setState_phX;

      redeclare replaceable function setState_psX
        "Return thermodynamic state from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=Modelica.Math.exp(s/cp_const +
          Modelica.Math.log(reference_T)))
          "Here the incompressible limit is used, with cp as heat capacity";
      end setState_psX;

      redeclare function setState_dTX
        "Return thermodynamic state from d, T, and X or Xi"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        assert(false,
          "Pressure can not be computed from temperature and density for an incompressible fluid!");
      end setState_dTX;

      redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
      algorithm
        state := ThermodynamicState(p=Media.Common.smoothStep(
                x,
                state_a.p,
                state_b.p,
                x_small), T=Media.Common.smoothStep(
                x,
                state_a.T,
                state_b.T,
                x_small));
      end setSmoothState;

      redeclare function extends dynamicViscosity "Return dynamic viscosity"

      algorithm
        eta := eta_const;
      end dynamicViscosity;

      redeclare function extends thermalConductivity
        "Return thermal conductivity"

      algorithm
        lambda := lambda_const;
      end thermalConductivity;

      redeclare function extends pressure "Return pressure"

      algorithm
        p := state.p;
      end pressure;

      redeclare function extends temperature "Return temperature"

      algorithm
        T := state.T;
      end temperature;

      redeclare function extends density "Return density"

      algorithm
        d := d_const;
      end density;

      redeclare function extends specificEnthalpy "Return specific enthalpy"

      algorithm
        h := cp_const*(state.T - T0);
      end specificEnthalpy;

      redeclare function extends specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"

      algorithm
        cp := cp_const;
      end specificHeatCapacityCp;

      redeclare function extends specificHeatCapacityCv
        "Return specific heat capacity at constant volume"

      algorithm
        cv := cv_const;
      end specificHeatCapacityCv;

      redeclare function extends isentropicExponent "Return isentropic exponent"

      algorithm
        gamma := cp_const/cv_const;
      end isentropicExponent;

      redeclare function extends velocityOfSound "Return velocity of sound"

      algorithm
        a := a_const;
      end velocityOfSound;

      redeclare function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[nX] "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := cp_const*(T - T0);
        annotation (Documentation(info="<html>
<p>
This function computes the specific enthalpy of the fluid, but neglects the (small) influence of the pressure term p/d.
</p>
</html>"));
      end specificEnthalpy_pTX;

      redeclare function temperature_phX
        "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[nX] "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := T0 + h/cp_const;
      end temperature_phX;

      redeclare function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[nX] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(
                p,
                h,
                X));
      end density_phX;

      redeclare function extends specificInternalEnergy
        "Return specific internal energy"
        extends Modelica.Icons.Function;
      algorithm
        //  u := cv_const*(state.T - T0) - reference_p/d_const;
        u := cv_const*(state.T - T0);
        annotation (Documentation(info="<html>
<p>
This function computes the specific internal energy of the fluid, but neglects the (small) influence of the pressure term p/d.
</p>
</html>"));
      end specificInternalEnergy;

      redeclare function extends specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
      algorithm
        s := cv_const*Modelica.Math.log(state.T/T0);
      end specificEntropy;

      redeclare function extends specificGibbsEnergy
        "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
      algorithm
        g := specificEnthalpy(state) - state.T*specificEntropy(state);
      end specificGibbsEnergy;

      redeclare function extends specificHelmholtzEnergy
        "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
      algorithm
        f := specificInternalEnergy(state) - state.T*specificEntropy(state);
      end specificHelmholtzEnergy;

      redeclare function extends isentropicEnthalpy "Return isentropic enthalpy"
      algorithm
        h_is := cp_const*(temperature(refState) - T0);
      end isentropicEnthalpy;

      redeclare function extends isobaricExpansionCoefficient
        "Returns overall the isobaric expansion coefficient beta"
      algorithm
        beta := 0.0;
      end isobaricExpansionCoefficient;

      redeclare function extends isothermalCompressibility
        "Returns overall the isothermal compressibility factor"
      algorithm
        kappa := 0;
      end isothermalCompressibility;

      redeclare function extends density_derp_T
        "Returns the partial derivative of density with respect to pressure at constant temperature"
      algorithm
        ddpT := 0;
      end density_derp_T;

      redeclare function extends density_derT_p
        "Returns the partial derivative of density with respect to temperature at constant pressure"
      algorithm
        ddTp := 0;
      end density_derT_p;

      redeclare function extends density_derX
        "Returns the partial derivative of density with respect to mass fractions at constant pressure and temperature"
      algorithm
        dddX := fill(0, nX);
      end density_derX;

      redeclare function extends molarMass "Return the molar mass of the medium"
      algorithm
        MM := MM_const;
      end molarMass;
    end PartialSimpleMedium;

    package Choices "Types, constants to define menu choices"
      extends Modelica.Icons.Package;

      type IndependentVariables = enumeration(
          T "Temperature",
          pT "Pressure, Temperature",
          ph "Pressure, Specific Enthalpy",
          phX "Pressure, Specific Enthalpy, Mass Fraction",
          pTX "Pressure, Temperature, Mass Fractions",
          dTX "Density, Temperature, Mass Fractions")
        "Enumeration defining the independent variables of a medium";
      annotation (Documentation(info="<html>
<p>
Enumerations and data types for all types of fluids
</p>

<p>
Note: Reference enthalpy might have to be extended with enthalpy of formation.
</p>
</html>"));
    end Choices;

    package Types "Types to be used in fluid models"
      extends Modelica.Icons.Package;

      type AbsolutePressure = SI.AbsolutePressure (
          min=0,
          max=1.e8,
          nominal=1.e5,
          start=1.e5)
        "Type for absolute pressure with medium specific attributes";

      type Density = SI.Density (
          min=0,
          max=1.e5,
          nominal=1,
          start=1) "Type for density with medium specific attributes";

      type DynamicViscosity = SI.DynamicViscosity (
          min=0,
          max=1.e8,
          nominal=1.e-3,
          start=1.e-3)
        "Type for dynamic viscosity with medium specific attributes";

      type EnthalpyFlowRate = SI.EnthalpyFlowRate (
          nominal=1000.0,
          min=-1.0e8,
          max=1.e8) "Type for enthalpy flow rate with medium specific attributes";

      type MassFraction = Real (
          quantity="MassFraction",
          final unit="kg/kg",
          min=0,
          max=1,
          nominal=0.1) "Type for mass fraction with medium specific attributes";

      type MolarMass = SI.MolarMass (
          min=0.001,
          max=0.25,
          nominal=0.032) "Type for molar mass with medium specific attributes";

      type MolarVolume = SI.MolarVolume (
          min=1e-6,
          max=1.0e6,
          nominal=1.0) "Type for molar volume with medium specific attributes";

      type IsentropicExponent = SI.RatioOfSpecificHeatCapacities (
          min=1,
          max=500000,
          nominal=1.2,
          start=1.2)
        "Type for isentropic exponent with medium specific attributes";

      type SpecificEnergy = SI.SpecificEnergy (
          min=-1.0e8,
          max=1.e8,
          nominal=1.e6)
        "Type for specific energy with medium specific attributes";

      type SpecificInternalEnergy = SpecificEnergy
        "Type for specific internal energy with medium specific attributes";

      type SpecificEnthalpy = SI.SpecificEnthalpy (
          min=-1.0e10,
          max=1.e10,
          nominal=1.e6)
        "Type for specific enthalpy with medium specific attributes";

      type SpecificEntropy = SI.SpecificEntropy (
          min=-1.e7,
          max=1.e7,
          nominal=1.e3)
        "Type for specific entropy with medium specific attributes";

      type SpecificHeatCapacity = SI.SpecificHeatCapacity (
          min=0,
          max=1.e7,
          nominal=1.e3,
          start=1.e3)
        "Type for specific heat capacity with medium specific attributes";

      type Temperature = SI.Temperature (
          min=1,
          max=1.e4,
          nominal=300,
          start=288.15) "Type for temperature with medium specific attributes";

      type ThermalConductivity = SI.ThermalConductivity (
          min=0,
          max=500,
          nominal=1,
          start=1)
        "Type for thermal conductivity with medium specific attributes";

      type PrandtlNumber = SI.PrandtlNumber (
          min=1e-3,
          max=1e5,
          nominal=1.0) "Type for Prandtl number with medium specific attributes";

      type VelocityOfSound = SI.Velocity (
          min=0,
          max=1.e5,
          nominal=1000,
          start=1000)
        "Type for velocity of sound with medium specific attributes";

      type ExtraProperty = Real (min=0.0, start=1.0)
        "Type for unspecified, mass-specific property transported by flow";

      type ExtraPropertyFlowRate = Real (unit="kg/s")
        "Type for flow rate of unspecified, mass-specific property";

      type IsobaricExpansionCoefficient = Real (
          min=0,
          max=1.0e8,
          unit="1/K")
        "Type for isobaric expansion coefficient with medium specific attributes";

      type DipoleMoment = Real (
          min=0.0,
          max=2.0,
          unit="debye",
          quantity="ElectricDipoleMoment")
        "Type for dipole moment with medium specific attributes";

      type DerDensityByPressure = SI.DerDensityByPressure
        "Type for partial derivative of density with respect to pressure with medium specific attributes";

      type DerDensityByEnthalpy = SI.DerDensityByEnthalpy
        "Type for partial derivative of density with respect to enthalpy with medium specific attributes";

      type DerDensityByTemperature = SI.DerDensityByTemperature
        "Type for partial derivative of density with respect to temperature with medium specific attributes";

      package Basic
      "The most basic version of a record used in several degrees of detail"
        extends Icons.Package;

        record FluidConstants
          "Critical, triple, molecular and other standard data of fluid"
          extends Modelica.Icons.Record;
          String iupacName
            "Complete IUPAC name (or common name, if non-existent)";
          String casRegistryNumber
            "Chemical abstracts sequencing number (if it exists)";
          String chemicalFormula
            "Chemical formula, (brutto, nomenclature according to Hill";
          String structureFormula "Chemical structure formula";
          MolarMass molarMass "Molar mass";
        end FluidConstants;
      end Basic;

      package IdealGas
      "The ideal gas version of a record used in several degrees of detail"
        extends Icons.Package;

        record FluidConstants "Extended fluid constants"
          extends Modelica.Media.Interfaces.Types.Basic.FluidConstants;
          Temperature criticalTemperature "Critical temperature";
          AbsolutePressure criticalPressure "Critical pressure";
          MolarVolume criticalMolarVolume "Critical molar Volume";
          Real acentricFactor "Pitzer acentric factor";
          //   Temperature triplePointTemperature "Triple point temperature";
          //   AbsolutePressure triplePointPressure "Triple point pressure";
          Temperature meltingPoint "Melting point at 101325 Pa";
          Temperature normalBoilingPoint "Normal boiling point (at 101325 Pa)";
          DipoleMoment dipoleMoment
            "Dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
          Boolean hasIdealGasHeatCapacity=false
            "True if ideal gas heat capacity is available";
          Boolean hasCriticalData=false "True if critical data are known";
          Boolean hasDipoleMoment=false "True if a dipole moment known";
          Boolean hasFundamentalEquation=false "True if a fundamental equation";
          Boolean hasLiquidHeatCapacity=false
            "True if liquid heat capacity is available";
          Boolean hasSolidHeatCapacity=false
            "True if solid heat capacity is available";
          Boolean hasAccurateViscosityData=false
            "True if accurate data for a viscosity function is available";
          Boolean hasAccurateConductivityData=false
            "True if accurate data for thermal conductivity is available";
          Boolean hasVapourPressureCurve=false
            "True if vapour pressure data, e.g., Antoine coefficients are known";
          Boolean hasAcentricFactor=false
            "True if Pitzer acentric factor is known";
          SpecificEnthalpy HCRIT0=0.0
            "Critical specific enthalpy of the fundamental equation";
          SpecificEntropy SCRIT0=0.0
            "Critical specific entropy of the fundamental equation";
          SpecificEnthalpy deltah=0.0
            "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
          SpecificEntropy deltas=0.0
            "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";
        end FluidConstants;
      end IdealGas;
    end Types;
    annotation (Documentation(info="<html>
<p>
This package provides basic interfaces definitions of media models for different
kind of media.
</p>
</html>"));
  end Interfaces;

  package Common
    "Data structures and fundamental functions for fluid properties"
    extends Modelica.Icons.Package;

    function smoothStep
      "Approximation of a general step, such that the characteristic is continuous and differentiable"
      extends Modelica.Icons.Function;
      input Real x "Abscissa value";
      input Real y1 "Ordinate value for x > 0";
      input Real y2 "Ordinate value for x < 0";
      input Real x_small(min=0) = 1e-5
        "Approximation of step for -x_small <= x <= x_small; x_small > 0 required";
      output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
    algorithm
      y := smooth(1, if x > x_small then y1 else if x < -x_small then y2 else if
        abs(x_small) > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2 - y1)/4 + (y1
         + y2)/2 else (y1 + y2)/2);

      annotation (
        Inline=true,
        smoothOrder=1,
        Documentation(revisions="<html>
<ul>
<li><em>April 29, 2008</em>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><em>August 12, 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",   info="<html>
<p>
This function is used to approximate the equation
</p>
<blockquote><pre>
y = <strong>if</strong> x &gt; 0 <strong>then</strong> y1 <strong>else</strong> y2;
</pre></blockquote>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<blockquote><pre>
y = <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> y1 <strong>else</strong>
              <strong>if</strong> x &lt; -x_small <strong>then</strong> y2 <strong>else</strong> f(y1, y2));
</pre></blockquote>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>

<p>
If <strong>mass fractions</strong> X[:] are approximated with this function then this can be performed
for all <strong>nX</strong> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(X) = 1, provided sum(X_a) = sum(X_b) = 1
(and y1=X_a[i], y2=X_b[i]).
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise X is either X_a or X_b):
</p>

<blockquote><pre>
X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
   ...
X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre></blockquote>

<p>
or
</p>

<blockquote><pre>
X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
   ...
X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre></blockquote>

<p>
Summing all mass fractions together results in
</p>

<blockquote><pre>
sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
       = c*(1 - 1) + (1 + 1)/2
       = 1
</pre></blockquote>
</html>"));
    end smoothStep;
    annotation (Documentation(info="<html><h4>Package description</h4>
      <p>Package Modelica.Media.Common provides records and functions shared by many of the property sub-packages.
      High accuracy fluid property models share a lot of common structure, even if the actual models are different.
      Common data structures and computations shared by these property models are collected in this library.
   </p>

</html>",   revisions="<html>
      <ul>
      <li>First implemented: <em>July, 2000</em>
      by Hubertus Tummescheit
      for the ThermoFluid Library with help from Jonas Eborn and Falko Jens Wagner
      </li>
      <li>Code reorganization, enhanced documentation, additional functions: <em>December, 2002</em>
      by Hubertus Tummescheit and move to Modelica
                            properties library.</li>
      <li>Inclusion into Modelica.Media: September 2003</li>
      </ul>

      <address>Author: Hubertus Tummescheit,<br>
      Lund University<br>
      Department of Automatic Control<br>
      Box 118, 22100 Lund, Sweden<br>
      email: hubertus@control.lth.se
      </address>
</html>"));
  end Common;

    package IdealGases
    "Data and models of ideal gases (single, fixed and dynamic mixtures) from NASA source"
      extends Modelica.Icons.VariantsPackage;

      package Common "Common packages and data for the ideal gas models"
        extends Modelica.Icons.Package;

      record DataRecord
        "Coefficient data record for properties of ideal gases based on NASA source"
        extends Modelica.Icons.Record;
        String name "Name of ideal gas";
        SI.MolarMass MM "Molar mass";
        SI.SpecificEnthalpy Hf "Enthalpy of formation at 298.15K";
        SI.SpecificEnthalpy H0 "H0(298.15K) - H0(0K)";
        SI.Temperature Tlimit "Temperature limit between low and high data sets";
        Real alow[7] "Low temperature coefficients a";
        Real blow[2] "Low temperature constants b";
        Real ahigh[7] "High temperature coefficients a";
        Real bhigh[2] "High temperature constants b";
        SI.SpecificHeatCapacity R_s "Gas constant";
        annotation (Documentation(info="<html>
<p>
This data record contains the coefficients for the
ideal gas equations according to:
</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>
The equations have the following structure:
</p>
<div><img src=\"modelica://Modelica/Resources/Images/Media/IdealGases/Common/singleEquations.png\"></div>
<p>
The polynomials for h(T) and s0(T) are derived via integration from the one for cp(T)  and contain the integration constants b1, b2 that define the reference specific enthalpy and entropy. For entropy differences the reference pressure p0 is arbitrary, but not for absolute entropies. It is chosen as 1 standard atmosphere (101325 Pa).
</p>
<p>
For most gases, the region of validity is from 200 K to 6000 K.
The equations are split into two regions that are separated
by Tlimit (usually 1000 K). In both regions the gas is described
by the data above. The two branches are continuous and in most
gases also differentiable at Tlimit.
</p>
</html>"));
      end DataRecord;

        package FluidData "Critical data, dipole moments and related data"
          extends Modelica.Icons.Package;
          import Modelica.Media.Interfaces.PartialMixtureMedium;
          import Modelica.Media.IdealGases.Common.SingleGasesData;

          constant Modelica.Media.Interfaces.Types.IdealGas.FluidConstants N2(
                               chemicalFormula =        "N2",
                               iupacName =              "unknown",
                               structureFormula =       "unknown",
                               casRegistryNumber =      "7727-37-9",
                               meltingPoint =            63.15,
                               normalBoilingPoint =      77.35,
                               criticalTemperature =    126.20,
                               criticalPressure =        33.98e5,
                               criticalMolarVolume =     90.10e-6,
                               acentricFactor =           0.037,
                               dipoleMoment =             0.0,
                               molarMass =              SingleGasesData.N2.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);

          constant Modelica.Media.Interfaces.Types.IdealGas.FluidConstants H2O(
                               chemicalFormula =        "H2O",
                               iupacName =              "oxidane",
                               structureFormula =       "H2O",
                               casRegistryNumber =      "7732-18-5",
                               meltingPoint =           273.15,
                               normalBoilingPoint =     373.124,
                               criticalTemperature =    647.096,
                               criticalPressure =       220.64e5,
                               criticalMolarVolume =     55.95e-6,
                               acentricFactor =           0.344,
                               dipoleMoment =             1.8,
                               molarMass =              SingleGasesData.H2O.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);
          annotation (Documentation(info="<html>
<p>
This package contains FluidConstants data records for the following 37 gases
(see also the description in
<a href=\"modelica://Modelica.Media.IdealGases\">Modelica.Media.IdealGases</a>):
</p>
<blockquote><pre>
Argon             Methane          Methanol       Carbon Monoxide  Carbon Dioxide
Acetylene         Ethylene         Ethanol        Ethane           Propylene
Propane           1-Propanol       1-Butene       N-Butane         1-Pentene
N-Pentane         Benzene          1-Hexene       N-Hexane         1-Heptane
N-Heptane         Ethylbenzene     N-Octane       Chlorine         Fluorine
Hydrogen          Steam            Helium         Ammonia          Nitric Oxide
Nitrogen Dioxide  Nitrogen         Nitrous        Oxide            Neon Oxygen
Sulfur Dioxide    Sulfur Trioxide
</pre></blockquote>

</html>"));
        end FluidData;

        package SingleGasesData
        "Ideal gas data based on the NASA Glenn coefficients"
          extends Modelica.Icons.Package;

          constant IdealGases.Common.DataRecord Air(
            name="Air",
            MM=0.0289651159,
            Hf=-4333.833858403446,
            H0=298609.6803431054,
            Tlimit=1000,
            alow={10099.5016,-196.827561,5.00915511,-0.00576101373,1.06685993e-005,-7.94029797e-009,
                2.18523191e-012},
            blow={-176.796731,-3.921504225},
            ahigh={241521.443,-1257.8746,5.14455867,-0.000213854179,7.06522784e-008,-1.07148349e-011,
                6.57780015e-016},
            bhigh={6462.26319,-8.147411905},
            R_s=287.0512249529787);

          constant IdealGases.Common.DataRecord H2O(
            name="H2O",
            MM=0.01801528,
            Hf=-13423382.81725291,
            H0=549760.6476280135,
            Tlimit=1000,
            alow={-39479.6083,575.573102,0.931782653,0.00722271286,-7.34255737e-006,
                4.95504349e-009,-1.336933246e-012},
            blow={-33039.7431,17.24205775},
            ahigh={1034972.096,-2412.698562,4.64611078,0.002291998307,-6.836830479999999e-007,
                9.426468930000001e-011,-4.82238053e-015},
            bhigh={-13842.86509,-7.97814851},
            R_s=461.5233290850878);

          constant IdealGases.Common.DataRecord N2(
            name="N2",
            MM=0.0280134,
            Hf=0,
            H0=309498.4543111511,
            Tlimit=1000,
            alow={22103.71497,-381.846182,6.08273836,-0.00853091441,1.384646189e-005,-9.62579362e-009,
                2.519705809e-012},
            blow={710.846086,-10.76003744},
            ahigh={587712.406,-2239.249073,6.06694922,-0.00061396855,1.491806679e-007,-1.923105485e-011,
                1.061954386e-015},
            bhigh={12832.10415,-15.86640027},
            R_s=296.8033869505308);
          annotation (Documentation(info="<html>
<p>This package contains ideal gas models for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>

<blockquote><pre>
Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
Al        Be              C2H5            D2      K+       NbO     Si+
Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
AlC2      BeF             CCN             F       KF       Ni-     SiC2
AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
AlF       BeI             C3              FO      KNO3     O       SiF
AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
BH4       CH4             Cd              HOF     NH+      RbNa    U
BI        CH3OH           Cd+             HO2     NHF      RbO     UF
BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
BO2-      COCl            Co              H2O2    NO2-     S       UF5
B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre></blockquote>
</html>"));
        end SingleGasesData;
      annotation (Documentation(info="<html>
</html>"));
      end Common;
      annotation (Documentation(info="<html>
<p>This package contains data for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>Medium models for some of these gases are available in package
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a>
and some examples for mixtures are available in package <a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a>
</p>
<h4>Using and Adapting Medium Models</h4>
<p>
The data records allow computing the ideal gas specific enthalpy, specific entropy and heat capacity of the substances listed below. From them, even the Gibbs energy and equilibrium constants for reactions can be computed. Critical data that is needed for computing the viscosity and thermal conductivity is not included. In order to add mixtures or single substance medium packages that are
subtypes of
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">Interfaces.PartialMedium</a>
(i.e., can be utilized at all places where PartialMedium is defined),
a few additional steps have to be performed:
</p>
<ol>
<li>
All single gas media need to define a constant instance of record
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium.FluidConstants\">IdealGases.Common.SingleGasNasa.FluidConstants</a>.
For 37 ideal gases such records are provided in package
<a href=\"modelica://Modelica.Media.IdealGases.Common.FluidData\">IdealGases.Common.FluidData</a>.
For the other gases, such a record instance has to be provided by the user, e.g., by getting
the data from a commercial or public data base. A public source of the needed data is for example the <a href=\"http://webbook.nist.gov/chemistry/\"> NIST Chemistry WebBook</a></li>

<li>When the data is available, and a user has an instance of a
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium.FluidConstants\">FluidConstants</a> record filled with data, a medium package has to be written. Note that only the dipole moment, the acentric factor and critical data are necessary for the viscosity and thermal conductivity functions.</li>
<li><ul>
<li>For single components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a> has to be created, pointing both to a data record for cp and to a user-defined fluidConstants record.</li>
<li>For mixtures of several components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a> has to be created, building an array of data records for cp and an array of (partly) user-defined fluidConstants records.</li>
</ul></li>
</ol>
<p>Note that many properties can computed for the full set of 1241 gases listed below, but due to the missing viscosity and thermal conductivity functions, no fully Modelica.Media-compliant media can be defined.</p>
<p>
Data records for heat capacity, specific enthalpy and specific entropy exist for the following substances and ions:
</p>
<blockquote><pre>
Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
Al        Be              C2H5            D2      K+       NbO     Si+
Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
AlC2      BeF             CCN             F       KF       Ni-     SiC2
AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
AlF       BeI             C3              FO      KNO3     O       SiF
AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
BH4       CH4             Cd              HOF     NH+      RbNa    U
BI        CH3OH           Cd+             HO2     NHF      RbO     UF
BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
BO2-      COCl            Co              H2O2    NO2-     S       UF5
B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre></blockquote></html>"));
    end IdealGases;

    package Water "Medium models for water"
    extends Modelica.Icons.VariantsPackage;
    import Modelica.Media.Water.ConstantPropertyLiquidWater.simpleWaterConstants;

    package ConstantPropertyLiquidWater
      "Water: Simple liquid water medium (incompressible, constant data)"

      //   redeclare record extends FluidConstants
      //   end FluidConstants;

      constant Modelica.Media.Interfaces.Types.Basic.FluidConstants[1]
        simpleWaterConstants(
        each chemicalFormula="H2O",
        each structureFormula="H2O",
        each casRegistryNumber="7732-18-5",
        each iupacName="oxidane",
        each molarMass=0.018015268);

      extends Interfaces.PartialSimpleMedium(
        mediumName="SimpleLiquidWater",
        cp_const=4184,
        cv_const=4184,
        d_const=995.586,
        eta_const=1.e-3,
        lambda_const=0.598,
        a_const=1484,
        T_min=Cv.from_degC(-1),
        T_max=Cv.from_degC(130),
        T0=273.15,
        MM_const=0.018015268,
        fluidConstants=simpleWaterConstants);

      annotation (Documentation(info="<html>

</html>"));
    end ConstantPropertyLiquidWater;
    annotation (Documentation(info="<html>
<p>This package contains different medium models for water:</p>
<ul>
<li><strong>ConstantPropertyLiquidWater</strong><br>
    Simple liquid water medium (incompressible, constant data).</li>
<li><strong>IdealSteam</strong><br>
    Steam water medium as ideal gas from Media.IdealGases.SingleGases.H2O</li>
<li><strong>WaterIF97 derived models</strong><br>
    High precision water model according to the IAPWS/IF97 standard
    (liquid, steam, two phase region). Models with different independent
    variables are provided as well as models valid only
    for particular regions. The <strong>WaterIF97_ph</strong> model is valid
    in all regions and is the recommended one to use.</li>
</ul>
<h4>Overview of WaterIF97 derived water models</h4>
<p>
The WaterIF97 models calculate medium properties
for water in the <strong>liquid</strong>, <strong>gas</strong> and <strong>two phase</strong> regions
according to the IAPWS/IF97 standard, i.e., the accepted industrial standard
and best compromise between accuracy and computation time.
It has been part of the ThermoFluid Modelica library and been extended,
reorganized and documented to become part of the Modelica Standard library.</p>
<p>An important feature that distinguishes this implementation of the IF97 steam property standard
is that this implementation has been explicitly designed to work well in dynamic simulations. Computational
performance has been of high importance. This means that there often exist several ways to get the same result
from different functions if one of the functions is called often but can be optimized for that purpose.
</p>
<p>Three variable pairs can be the independent variables of the model:
</p>
<ol>
<li>Pressure <strong>p</strong> and specific enthalpy <strong>h</strong> are
    the most natural choice for general applications.
    This is the recommended choice for most general purpose
    applications, in particular for power plants.</li>
<li>Pressure <strong>p</strong> and temperature <strong>T</strong> are the most natural
    choice for applications where water is always in the same phase,
    both for liquid water and steam.</li>
<li>Density <strong>d</strong> and temperature <strong>T</strong> are explicit
    variables of the Helmholtz function in the near-critical
    region and can be the best choice for applications with
    super-critical or near-critical states.</li>
</ol>
<p>
The following quantities are always computed in Medium.BaseProperties:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>d</td>
      <td>kg/m^3</td>
      <td>density</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>pressure</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
</table>
<p>
In some cases additional medium properties are needed.
A component that needs these optional properties has to call
one of the following functions:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>Function call</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>Medium.dynamicViscosity(medium.state)</td>
      <td>Pa.s</td>
      <td>dynamic viscosity</td></tr>
  <tr><td>Medium.thermalConductivity(medium.state)</td>
      <td>W/(m.K)</td>
      <td>thermal conductivity</td></tr>
  <tr><td>Medium.prandtlNumber(medium.state)</td>
      <td>1</td>
      <td>Prandtl number</td></tr>
  <tr><td>Medium.specificEntropy(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific entropy</td></tr>
  <tr><td>Medium.heatCapacity_cp(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific heat capacity at constant pressure</td></tr>
  <tr><td>Medium.heatCapacity_cv(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific heat capacity at constant density</td></tr>
  <tr><td>Medium.isentropicExponent(medium.state)</td>
      <td>1</td>
      <td>isentropic exponent</td></tr>
  <tr><td>Medium.isentropicEnthalpy(pressure, medium.state)</td>
      <td>J/kg</td>
      <td>isentropic enthalpy</td></tr>
  <tr><td>Medium.velocityOfSound(medium.state)</td>
      <td>m/s</td>
      <td>velocity of sound</td></tr>
  <tr><td>Medium.isobaricExpansionCoefficient(medium.state)</td>
      <td>1/K</td>
      <td>isobaric expansion coefficient</td></tr>
  <tr><td>Medium.isothermalCompressibility(medium.state)</td>
      <td>1/Pa</td>
      <td>isothermal compressibility</td></tr>
  <tr><td>Medium.density_derp_h(medium.state)</td>
      <td>kg/(m3.Pa)</td>
      <td>derivative of density by pressure at constant enthalpy</td></tr>
  <tr><td>Medium.density_derh_p(medium.state)</td>
      <td>kg2/(m3.J)</td>
      <td>derivative of density by enthalpy at constant pressure</td></tr>
  <tr><td>Medium.density_derp_T(medium.state)</td>
      <td>kg/(m3.Pa)</td>
      <td>derivative of density by pressure at constant temperature</td></tr>
  <tr><td>Medium.density_derT_p(medium.state)</td>
      <td>kg/(m3.K)</td>
      <td>derivative of density by temperature at constant pressure</td></tr>
  <tr><td>Medium.density_derX(medium.state)</td>
      <td>kg/m3</td>
      <td>derivative of density by mass fraction</td></tr>
  <tr><td>Medium.molarMass(medium.state)</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
<p>More details are given in
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.OptionalProperties\">
Modelica.Media.UsersGuide.MediumUsage.OptionalProperties</a>.

Many additional optional functions are defined to compute properties of
saturated media, either liquid (bubble point) or vapour (dew point).
The argument to such functions is a SaturationProperties record, which can be
set starting from either the saturation pressure or the saturation temperature.
With reference to a model defining a pressure p, a temperature T, and a
SaturationProperties record sat, the following functions are provided:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>Function call</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>Medium.saturationPressure(T)</td>
      <td>Pa</td>
      <td>Saturation pressure at temperature T</td></tr>
  <tr><td>Medium.saturationTemperature(p)</td>
      <td>K</td>
      <td>Saturation temperature at pressure p</td></tr>
  <tr><td>Medium.saturationTemperature_derp(p)</td>
      <td>K/Pa</td>
      <td>Derivative of saturation temperature with respect to pressure</td></tr>
  <tr><td>Medium.bubbleEnthalpy(sat)</td>
      <td>J/kg</td>
      <td>Specific enthalpy at bubble point</td></tr>
  <tr><td>Medium.dewEnthalpy(sat)</td>
      <td>J/kg</td>
      <td>Specific enthalpy at dew point</td></tr>
  <tr><td>Medium.bubbleEntropy(sat)</td>
      <td>J/(kg.K)</td>
      <td>Specific entropy at bubble point</td></tr>
  <tr><td>Medium.dewEntropy(sat)</td>
      <td>J/(kg.K)</td>
      <td>Specific entropy at dew point</td></tr>
  <tr><td>Medium.bubbleDensity(sat)</td>
      <td>kg/m3</td>
      <td>Density at bubble point</td></tr>
  <tr><td>Medium.dewDensity(sat)</td>
      <td>kg/m3</td>
      <td>Density at dew point</td></tr>
  <tr><td>Medium.dBubbleDensity_dPressure(sat)</td>
      <td>kg/(m3.Pa)</td>
      <td>Derivative of density at bubble point with respect to pressure</td></tr>
  <tr><td>Medium.dDewDensity_dPressure(sat)</td>
      <td>kg/(m3.Pa)</td>
      <td>Derivative of density at dew point with respect to pressure</td></tr>
  <tr><td>Medium.dBubbleEnthalpy_dPressure(sat)</td>
      <td>J/(kg.Pa)</td>
      <td>Derivative of specific enthalpy at bubble point with respect to pressure</td></tr>
  <tr><td>Medium.dDewEnthalpy_dPressure(sat)</td>
      <td>J/(kg.Pa)</td>
      <td>Derivative of specific enthalpy at dew point with respect to pressure</td></tr>
  <tr><td>Medium.surfaceTension(sat)</td>
      <td>N/m</td>
      <td>Surface tension between liquid and vapour phase</td></tr>
</table>
<p>Details on usage and some examples are given in:
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.TwoPhase\">
Modelica.Media.UsersGuide.MediumUsage.TwoPhase</a>.
</p>
<p>Many further properties can be computed. Using the well-known Bridgman's Tables,
all first partial derivatives of the standard thermodynamic variables can be computed easily.
</p>
<p>
The documentation of the IAPWS/IF97 steam properties can be freely
distributed with computer implementations and are included here
(in directory Modelica/Resources/Documentation/Media/Water/IF97documentation):
</p>
<ul>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/IF97.pdf\">IF97.pdf</a> The standards document for the main part of the IF97.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/Back3.pdf\">Back3.pdf</a> The backwards equations for region 3.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/crits.pdf\">crits.pdf</a> The critical point data.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/meltsub.pdf\">meltsub.pdf</a> The melting- and sublimation line formulation (not implemented)</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/surf.pdf\">surf.pdf</a> The surface tension standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/thcond.pdf\">thcond.pdf</a> The thermal conductivity standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/visc.pdf\">visc.pdf</a> The viscosity standard definition</li>
</ul>
</html>"));
    end Water;
  annotation (preferredView="info",Documentation(info="<html>
<p>
This library contains <a href=\"modelica://Modelica.Media.Interfaces\">interface</a>
definitions for media and the following <strong>property</strong> models for
single and multiple substance fluids with one and multiple phases:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.IdealGases\">Ideal gases:</a><br>
     1241 high precision gas models based on the
     NASA Glenn coefficients, plus ideal gas mixture models based
     on the same data.</li>
<li> <a href=\"modelica://Modelica.Media.Water\">Water models:</a><br>
     ConstantPropertyLiquidWater, WaterIF97 (high precision
     water model according to the IAPWS/IF97 standard)</li>
<li> <a href=\"modelica://Modelica.Media.Air\">Air models:</a><br>
     SimpleAir, DryAirNasa, ReferenceAir, MoistAir, ReferenceMoistAir.</li>
<li> <a href=\"modelica://Modelica.Media.Incompressible\">
     Incompressible media:</a><br>
     TableBased incompressible fluid models (properties are defined by tables rho(T),
     HeatCapacity_cp(T), etc.)</li>
<li> <a href=\"modelica://Modelica.Media.CompressibleLiquids\">
     Compressible liquids:</a><br>
     Simple liquid models with linear compressibility</li>
<li> <a href=\"modelica://Modelica.Media.R134a\">Refrigerant Tetrafluoroethane (R134a)</a>.</li>
</ul>
<p>
The following parts are useful, when newly starting with this library:</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Modelica.Media.UsersGuide.MediumUsage</a>
     describes how to use a medium model in a component model.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition\">
     Modelica.Media.UsersGuide.MediumDefinition</a>
     describes how a new fluid medium model has to be implemented.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.ReleaseNotes\">Modelica.Media.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Media.Examples\">Modelica.Media.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>February 01, 2017</em> by Thomas Beutlich:<br>
    Fixed data errors of the NASA Glenn coefficients in some ideal gases (CH2, CH3, CH3OOH, C2CL2, C2CL4, C2CL6, C2HCL, C2HCL3, CH2CO_ketene, O_CH_2O, HO_CO_2OH, CH2BrminusCOOH, C2H3CL, CH2CLminusCOOH, HO2, HO2minus, OD, ODminus), see <a href=\"https://github.com/modelica/ModelicaStandardLibrary/issues/1922\">#1922</a></li>
<li><em>May 16, 2013</em> by Stefan Wischhusen (XRG Simulation):<br>
    Added new media models Air.ReferenceMoistAir, Air.ReferenceAir, R134a.</li>
<li><em>May 25, 2011</em> by Francesco Casella:<br>Added min/max attributes to Water, TableBased, MixtureGasNasa, SimpleAir and MoistAir local types.</li>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br>Added individual settings for polynomial fittings of properties.</li>
</ul>
</html>"),
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package Thermal
  "Library of thermal system components to model heat transfer and simple thermo-fluid pipe flow"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;

    package HeatTransfer
    "Library of 1-dimensional heat transfer with lumped elements"
      extends Modelica.Icons.Package;

      package Components "Lumped thermal components"
        extends Modelica.Icons.Package;

        model HeatCapacitor "Lumped thermal element storing heat"
          parameter SI.HeatCapacity C
            "Heat capacity of element (= cp*m)";
          SI.Temperature T(start=293.15, displayUnit="degC")
            "Temperature of element";
          SI.TemperatureSlope der_T(start=0)
            "Time derivative of temperature (= der(T))";
          Interfaces.HeatPort_a port annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90)));
        equation
          T = port.T;
          der_T = der(T);
          C*der(T) = port.Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,110},{150,70}},
                  textString="%name",
                  textColor={0,0,255}),
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-69,7},{71,-24}},
                  textString="%C")}),
            Documentation(info="<html>
<p>
This is a generic model for the heat capacity of a material.
No specific geometry is assumed beyond a total volume with
uniform temperature for the entire volume.
Furthermore, it is assumed that the heat capacity
is constant (independent of temperature).
</p>
<p>
The temperature T [Kelvin] of this component is a <strong>state</strong>.
A default of T = 25 degree Celsius (= Modelica.Units.Conversions.from_degC(25))
is used as start value for initialization.
This usually means that at start of integration the temperature of this
component is 25 degrees Celsius. You may, of course, define a different
temperature as start value for initialization. Alternatively, it is possible
to set parameter <strong>steadyStateStart</strong> to <strong>true</strong>. In this case
the additional equation '<strong>der</strong>(T) = 0' is used during
initialization, i.e., the temperature T is computed in such a way that
the component starts in <strong>steady state</strong>. This is useful in cases,
where one would like to start simulation in a suitable operating
point without being forced to integrate for a long time to arrive
at this point.
</p>
<p>
Note, that parameter <strong>steadyStateStart</strong> is not available in
the parameter menu of the simulation window, because its value
is utilized during translation to generate quite different
equations depending on its setting. Therefore, the value of this
parameter can only be changed before translating the model.
</p>
<p>
This component may be used for complicated geometries where
the heat capacity C is determined my measurements. If the component
consists mainly of one type of material, the <strong>mass m</strong> of the
component may be measured or calculated and multiplied with the
<strong>specific heat capacity cp</strong> of the component material to
compute C:
</p>
<blockquote><pre>
C = cp*m.
Typical values for cp at 20 degC in J/(kg.K):
   aluminium   896
   concrete    840
   copper      383
   iron        452
   silver      235
   steel       420 ... 500 (V2A)
   wood       2500
</pre></blockquote>
</html>"));
        end HeatCapacitor;

        model ThermalConductor
          "Lumped thermal element transporting heat without storing it"
          extends Interfaces.Element1D;
          parameter SI.ThermalConductance G
            "Constant thermal conductance of material";

        equation
          Q_flow = G*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-90,70},{90,-70}},
                  pattern=LinePattern.None,
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-90,70},{-90,-70}},
                  thickness=0.5),
                Line(
                  points={{90,70},{90,-70}},
                  thickness=0.5),
                Text(
                  extent={{-150,120},{150,80}},
                  textString="%name",
                  textColor={0,0,255}),
                Text(
                  extent={{-150,-80},{150,-110}},
                  textString="G=%G")}),
            Documentation(info="<html>
<p>
This is a model for transport of heat without storing it; see also:
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ThermalResistor\">ThermalResistor</a>.
It may be used for complicated geometries where
the thermal conductance G (= inverse of thermal resistance)
is determined by measurements and is assumed to be constant
over the range of operations. If the component consists mainly of
one type of material and a regular geometry, it may be calculated,
e.g., with one of the following equations:
</p>
<ul>
<li><p>
    Conductance for a <strong>box</strong> geometry under the assumption
    that heat flows along the box length:</p>
    <blockquote><pre>
G = k*A/L
k: Thermal conductivity (material constant)
A: Area of box
L: Length of box
    </pre></blockquote>
    </li>
<li><p>
    Conductance for a <strong>cylindrical</strong> geometry under the assumption
    that heat flows from the inside to the outside radius
    of the cylinder:</p>
    <blockquote><pre>
G = 2*pi*k*L/log(r_out/r_in)
pi   : Modelica.Constants.pi
k    : Thermal conductivity (material constant)
L    : Length of cylinder
log  : Modelica.Math.log;
r_out: Outer radius of cylinder
r_in : Inner radius of cylinder
    </pre></blockquote>
    </li>
</ul>
<blockquote><pre>
Typical values for k at 20 degC in W/(m.K):
  aluminium   220
  concrete      1
  copper      384
  iron         74
  silver      407
  steel        45 .. 15 (V2A)
  wood         0.1 ... 0.2
</pre></blockquote>
</html>"));
        end ThermalConductor;

        model Convection
          "Lumped thermal element for heat convection (Q_flow = Gc*dT)"
          SI.HeatFlowRate Q_flow "Heat flow rate from solid -> fluid";
          SI.TemperatureDifference dT "= solid.T - fluid.T";
          Modelica.Blocks.Interfaces.RealInput Gc(unit="W/K")
            "Signal representing the convective thermal conductance in [W/K]"
            annotation (Placement(transformation(
                origin={0,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Interfaces.HeatPort_a solid annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b fluid annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          Q_flow = Gc*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-62,80},{98,-80}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{-150,-90},{150,-130}},
                  textString="%name",
                  textColor={0,0,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0}),
                Text(
                  extent={{22,124},{92,98}},
                  textString="Gc")}),
            Documentation(info="<html>
<p>
This is a model of linear heat convection, e.g., the heat transfer between a plate and the surrounding air; see also:
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor\">ConvectiveResistor</a>.
It may be used for complicated solid geometries and fluid flow over the solid by determining the
convective thermal conductance Gc by measurements. The basic constitutive equation for convection is
</p>
<blockquote><pre>
Q_flow = Gc*(solid.T - fluid.T);
Q_flow: Heat flow rate from connector 'solid' (e.g., a plate)
   to connector 'fluid' (e.g., the surrounding air)
</pre></blockquote>
<p>
Gc = G.signal[1] is an input signal to the component, since Gc is
nearly never constant in practice. For example, Gc may be a function
of the speed of a cooling fan. For simple situations,
Gc may be <em>calculated</em> according to
</p>
<blockquote><pre>
Gc = A*h
A: Convection area (e.g., perimeter*length of a box)
h: Heat transfer coefficient
</pre></blockquote>
<p>
where the heat transfer coefficient h is calculated
from properties of the fluid flowing over the solid. Examples:
</p>
<p>
<strong>Machines cooled by air</strong> (empirical, very rough approximation according
to [<a href=\"modelica://Modelica.Thermal.HeatTransfer.UsersGuide.References\">Fischer2017</a>, p. 452]:
</p>
<blockquote><pre>
h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
  = 12         [W/(m2.K)] (free convection)
where
  v: Air velocity in [m/s]
</pre></blockquote>
<p><strong>Laminar</strong> flow with constant velocity of a fluid along a
<strong>flat plate</strong> where the heat flow rate from the plate
to the fluid (= solid.Q_flow) is kept constant
(according to [<a href=\"modelica://Modelica.Thermal.HeatTransfer.UsersGuide.References\">Holman2010</a>, p.265]):
</p>
<blockquote><pre>
h  = Nu*k/x;
Nu = 0.453*Re^(1/2)*Pr^(1/3);
where
   h  : Heat transfer coefficient
   Nu : = h*x/k       (Nusselt number)
   Re : = v*x*rho/mu  (Reynolds number)
   Pr : = cp*mu/k     (Prandtl number)
   v  : Absolute velocity of fluid
   x  : distance from leading edge of flat plate
   rho: density of fluid (material constant
   mu : dynamic viscosity of fluid (material constant)
   cp : specific heat capacity of fluid (material constant)
   k  : thermal conductivity of fluid (material constant)
and the equation for h holds, provided
   Re &lt; 5e5 and 0.6 &lt; Pr &lt; 50
</pre></blockquote>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255})}));
        end Convection;
        annotation (Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Rectangle(
            origin = {12,40},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Backward,
            extent = {{-100,-100},{-70,18}}),
          Line(
            origin = {12,40},
            points = {{-44,16},{-44,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,16},{-4,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,18},{30,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,18},{66,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,-100},{76,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,-100},{56,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,-100},{40,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,-100},{20,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,-100},{6,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,-100},{-14,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-44,-100},{-34,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-44,-100},{-54,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-70,-60},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-70},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-50},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-30},{66,-20}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-10},{66,-20}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{-70,-20},{66,-20}},
            color = {191,0,0})}), Documentation(
              info="<html>

</html>"));
      end Components;

      package Sensors "Thermal sensors"
        extends Modelica.Icons.SensorsPackage;

        model TemperatureSensor "Absolute temperature sensor in Kelvin"

          Modelica.Blocks.Interfaces.RealOutput T(unit="K")
            "Absolute temperature as output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{120,10}})));
          Interfaces.HeatPort_a port annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
        equation
          T = port.T;
          port.Q_flow = 0;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{100,0}},color={0,0,127}),
                Line(points={{-90,0},{-12,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},
                      {12,80},{12,40},{-12,40}},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}),
                Line(points={{-40,20},{-12,20}}),
                Line(points={{-40,60},{-12,60}}),
                Text(
                  extent={{-150,140},{150,100}},
                  textString="%name",
                  textColor={0,0,255}),
                Text(
                  extent={{20,60},{80,0}},
                  textColor={64,64,64},
                  textString="K")}),
            Documentation(info="<html>
<p>
This is an ideal absolute temperature sensor which returns
the temperature of the connected port in Kelvin as an output
signal.  The sensor itself has no thermal interaction with
whatever it is connected to.  Furthermore, no
thermocouple-like lags are associated with this
sensor model.
</p>
</html>"));
        end TemperatureSensor;

        model HeatFlowSensor "Heat flow rate sensor"
          extends Modelica.Icons.RoundSensor;
          Modelica.Blocks.Interfaces.RealOutput Q_flow(unit="W")
            "Heat flow from port_a to port_b as output signal" annotation (Placement(
                transformation(
                origin={0,-110},
                extent={{-10,-10},{10,10}},
                rotation=270), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-110})));
          Interfaces.HeatPort_a port_a annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b port_b annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          port_a.T = port_b.T;
          port_a.Q_flow + port_b.Q_flow = 0;
          Q_flow = port_a.Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(points={{-70,0},{-90,0}}, color={191,0,0}),
                Line(points={{70,0},{90,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-100}},color={0,0,127}),
                Text(
                  extent={{-150,120},{150,80}},
                  textString="%name",
                  textColor={0,0,255}),
                Text(
                  extent={{-30,-10},{30,-70}},
                  textColor={64,64,64},
                  textString="W")}),
            Documentation(info="<html>
<p>
This model is capable of monitoring the heat flow rate flowing through
this component. The sensed value of heat flow rate is the amount that
passes through this sensor while keeping the temperature drop across the
sensor zero.  This is an ideal model so it does not absorb any energy
and it has no direct effect on the thermal response of a system it is included in.
The output signal is positive, if the heat flows from port_a to port_b.
</p>
</html>"));
        end HeatFlowSensor;
        annotation (Documentation(info="<html>

</html>"));
      end Sensors;

      package Sources "Thermal sources"
        extends Modelica.Icons.SourcesPackage;

        model PrescribedHeatFlow "Prescribed heat flow boundary condition"
          parameter SI.Temperature T_ref=293.15
            "Reference temperature";
          parameter SI.LinearTemperatureCoefficient alpha=0
            "Temperature coefficient of heat flow rate";
          Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
                annotation (Placement(transformation(
                origin={-100,0},
                extent={{20,-20},{-20,20}},
                rotation=180)));
          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
        equation
          port.Q_flow = -Q_flow*(1 + alpha*(port.T - T_ref));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(
                  points={{-60,-20},{40,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-60,20},{40,20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{40,0},{40,40},{70,20},{40,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{40,-40},{40,0},{70,-20},{40,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{70,40},{90,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,100},{150,60}},
                  textString="%name",
                  textColor={0,0,255})}),
            Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
If parameter alpha is &lt;&gt; 0, the heat flow is multiplied by (1 + alpha*(port.T - T_ref))
in order to simulate temperature dependent losses (which are given with respect to reference temperature T_ref).
</p>
</html>"));
        end PrescribedHeatFlow;
      end Sources;

      package Interfaces "Connectors and partial models"
        extends Modelica.Icons.InterfacesPackage;

        partial connector HeatPort "Thermal port for 1-dim. heat transfer"
          SI.Temperature T "Port temperature";
          flow SI.HeatFlowRate Q_flow
            "Heat flow rate (positive if flowing from outside into the component)";
          annotation (Documentation(info="<html>

</html>"));
        end HeatPort;

        connector HeatPort_a
          "Thermal port for 1-dim. heat transfer (filled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_a",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<blockquote><pre>
T       Temperature in [Kelvin].
Q_flow  Heat flow rate in [Watt].
</pre></blockquote>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-120,120},{100,60}},
                  textColor={191,0,0},
                  textString="%name")}));
        end HeatPort_a;

        connector HeatPort_b
          "Thermal port for 1-dim. heat transfer (unfilled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_b",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<blockquote><pre>
T       Temperature in [Kelvin].
Q_flow  Heat flow rate in [Watt].
</pre></blockquote>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-100,120},{120,60}},
                  textColor={191,0,0},
                  textString="%name")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end HeatPort_b;

        partial model Element1D
          "Partial heat transfer element with two HeatPort connectors that does not store energy"

          SI.HeatFlowRate Q_flow
            "Heat flow rate from port_a -> port_b";
          SI.TemperatureDifference dT "port_a.T - port_b.T";
      public
          HeatPort_a port_a annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          HeatPort_b port_b annotation (Placement(transformation(extent={{90,-10},{
                    110,10}})));
        equation
          dT = port_a.T - port_b.T;
          port_a.Q_flow = Q_flow;
          port_b.Q_flow = -Q_flow;
          annotation (Documentation(info="<html>
<p>
This partial model contains the basic connectors and variables to
allow heat transfer models to be created that <strong>do not store energy</strong>,
This model defines and includes equations for the temperature
drop across the element, <strong>dT</strong>, and the heat flow rate
through the element from port_a to port_b, <strong>Q_flow</strong>.
</p>
<p>
By extending this model, it is possible to write simple
constitutive equations for many types of heat transfer components.
</p>
</html>"));
        end Element1D;
        annotation (Documentation(info="<html>

</html>"));
      end Interfaces;
      annotation (
         Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Polygon(
            origin = {13.758,27.517},
            lineColor = {128,128,128},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,-49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},{-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}}),
        Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{-57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},{-75,-15},{-75,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {160,160,164},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},{29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{51,-13},{46,-7},{39,-5},{39,-6}}),
          Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},{46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{18,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-9,-23},{-9,-10},{18,-17},{-9,-23}}),
          Line(
            origin = {13.758,27.517},
            points = {{-41,-17},{-9,-17}},
            color = {191,0,0},
            thickness = 0.5),
          Line(
            origin = {13.758,27.517},
            points = {{-17,-40},{15,-40}},
            color = {191,0,0},
            thickness = 0.5),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-17,-46},{-17,-34},{-40,-40},{-17,-46}})}),
                                Documentation(info="<html>
<p>
This package contains components to model <strong>1-dimensional heat transfer</strong>
with lumped elements.</p>
</html>",     revisions="<html>
<ul>
<li><em>July 15, 2002</em>
       by Michael Tiller, <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Nikolaus Sch&uuml;rmann:<br>
       Implemented.
</li>
<li><em>June 13, 2005</em>
       by <a href=\"https://www.haumer.at/\">Anton Haumer</a><br>
       Refined placing of connectors (cosmetic).<br>
       Refined all Examples; removed Examples.FrequencyInverter, introducing Examples.Motor<br>
       Introduced temperature dependent correction (1 + alpha*(T - T_ref)) in Fixed/PrescribedHeatFlow<br>
</li>
  <li> v1.1.1 2007/11/13 Anton Haumer<br>
       components moved to sub-packages</li>
  <li> v1.2.0 2009/08/26 Anton Haumer<br>
       added component ThermalCollector</li>

</ul>
</html>"));
    end HeatTransfer;
    annotation (
     Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Line(
      origin={-47.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={-50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={2.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={0.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={52.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}})}),
      Documentation(info="<html>
<p>
This package contains libraries to model heat transfer
and fluid heat flow.
</p>
</html>"));
  end Thermal;

  package Math
  "Library of mathematical functions (e.g., sin, cos) and of functions operating on vectors and matrices"
    extends Modelica.Icons.Package;

    package BooleanVectors "Library of functions operating on Boolean vectors"
     extends Modelica.Icons.Package;

    function allTrue
        "Returns true, if all elements of the Boolean input vector are true ('and')"
      extends Modelica.Icons.Function;
      input Boolean b[:] "Boolean vector";
      output Boolean result "= true, if all elements of b are true";
    algorithm
      result := size(b,1) > 0;
      for i in 1:size(b,1) loop
         result := result and b[i];
      end for;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>allTrue</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
Returns <strong>true</strong> if all elements of the Boolean input vector b are <strong>true</strong>.
Otherwise the function returns <strong>false</strong>. If b is an empty vector,
i.e., size(b,1)=0, the function returns <strong>false</strong> (as opposed to <a href=\"modelica://Modelica.Math.BooleanVectors.andTrue\">andTrue</a> returning <strong>true</strong>).
</p>

<h4>Example</h4>
<blockquote><pre>
  Boolean b1[3] = {true, true, true};
  Boolean b2[3] = {false, true, false};
  Boolean r1, r2;
<strong>algorithm</strong>
  r1 = allTrue(b1);  // r1 = true
  r2 = allTrue(b2);  // r2 = false
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.andTrue\">andTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.anyTrue\">anyTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.countTrue\">countTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.index\">index</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>

</html>"));
    end allTrue;

    function anyTrue
        "Returns true, if at least one element of the Boolean input vector is true ('or')"

      extends Modelica.Icons.Function;
      input Boolean b[:] "Boolean vector";
      output Boolean result "= true, if at least one element of b is true";
    algorithm
      result := false;
      for i in 1:size(b,1) loop
         result := result or b[i];
      end for;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>anyTrue</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
Returns <strong>true</strong> if at least one element of the input Boolean vector b is <strong>true</strong>.
Otherwise the function returns <strong>false</strong>. If b is an empty vector,
i.e., size(b,1)=0, the function returns <strong>false</strong>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Boolean b1[3] = {false, false, false};
  Boolean b2[3] = {false, true, false};
  Boolean r1, r2;
<strong>algorithm</strong>
  r1 = anyTrue(b1);  // r1 = false
  r2 = anyTrue(b2);  // r2 = true
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.allTrue\">allTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.andTrue\">andTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.countTrue\">countTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.index\">index</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>
</html>"));
    end anyTrue;
      annotation (Documentation(info="<html>
<p>
This library provides functions operating on vectors that have
a Boolean vector as input argument.
</p>
</html>"),     Icon(graphics={Rectangle(
              extent={{-16,62},{14,14}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-16,-18},{14,-66}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}));
    end BooleanVectors;

  package Matrices "Library of functions operating on matrices"
    extends Modelica.Icons.Package;

    function leastSquares
      "Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix A";
      input Real b[size(A, 1)] "Vector b";
      input Real rcond=100*Modelica.Constants.eps
        "Reciprocal condition number to estimate the rank of A";
      output Real x[size(A, 2)]
        "Vector x such that min|A*x-b|^2 if size(A,1) >= size(A,2) or min|x|^2 and A*x=b, if size(A,1) < size(A,2)";
      output Integer rank "Rank of A";
  protected
      Integer info;
      Real xx[max(size(A, 1), size(A, 2))];
    algorithm
      if min(size(A)) > 0 then
        (xx,info,rank) := LAPACK.dgelsy_vec(
              A,
              b,
              rcond);
        x := xx[1:size(A, 2)];
        assert(info == 0,
          "Solving an overdetermined or underdetermined linear system\n" +
          "of equations with function \"Matrices.leastSquares\" failed.");
      else
        x := fill(0.0, size(A, 2));
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<strong>leastSquares</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns a solution of equation A*x = b in a least
square sense (A may be rank deficient):
</p>
<blockquote><pre>
minimize | A*x - b |
</pre></blockquote>

<p>
Several different cases can be distinguished (note, <strong>rank</strong> is an
output argument of this function):
</p>

<p>
<strong>size(A,1) = size(A,2)</strong>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     A is <strong>regular</strong> and the returned solution x fulfills the equation
     A*x = b uniquely.</li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     A is <strong>singular</strong> and no unique solution for equation A*x = b exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, x is selected such that |A*x - b| is as small as
           possible (but A*x - b is not zero).</li>
     </ul></li>
</ul>

<p>
<strong>size(A,1) &gt; size(A,2):</strong>
</p>

<p>
The equation A*x = b has no unique solution. The solution x is selected such that
|A*x - b| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*x - b|. From these infinite number of solutions, the one with the
minimum norm |x| is selected. This gives a unique solution that minimizes both
|A*x - b| and |x|.
</p>

<p>
<strong>size(A,1) &lt; size(A,2):</strong>
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*x = b.
     From this infinite number, the unique solution is selected that minimizes |x|.
     </li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     There is either no solution of equation A*x = b, or there are again an infinite
     number of solutions. The unique solution x is returned that minimizes
      both |A*x - b| and |x|.</li>
</ul>

<p>
Note, the solution is computed with the LAPACK function \"dgelsy\",
i.e., QR or LQ factorization of A with column pivoting.
</p>

<h4>Algorithmic details</h4>

<p>
The function first computes a QR factorization with column pivoting:
</p>

<blockquote><pre>
A * P = Q * [ R11 R12 ]
            [  0  R22 ]
</pre></blockquote>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <strong>rank</strong>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<blockquote><pre>
A * P = Q * [ T11 0 ] * Z
            [  0  0 ]
</pre></blockquote>

<p>
The minimum-norm solution is then
</p>

<blockquote><pre>
x = P * Z' [ inv(T11)*Q1'*b ]
           [        0       ]
</pre></blockquote>

<p>
where Q1 consists of the first \"rank\" columns of Q.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">Matrices.leastSquares2</a>
(same as leastSquares, but with a right hand side matrix),<br>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
(for square, regular matrices A)
</p>

</html>"));
    end leastSquares;

    package LAPACK
    "Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)"
      extends Modelica.Icons.FunctionsPackage;

      pure function dgelsy_vec
        "Compute the minimum-norm solution to a real linear least squares problem with rank deficient A"

        extends Modelica.Icons.Function;
        input Real A[:, :];
        input Real b[size(A, 1)];
        input Real rcond=0.0 "Reciprocal condition number to estimate rank";
        output Real x[max(size(A, 1), size(A, 2))]=cat(
                  1,
                  b,
                  zeros(max(nrow, ncol) - nrow))
          "solution is in first size(A,2) rows";
        output Integer info;
        output Integer rank "Effective rank of A";
    protected
        Integer nrow=size(A, 1);
        Integer ncol=size(A, 2);
        Integer nrhs=1;
        Integer nx=max(nrow, ncol);
        Integer lwork=max(min(nrow, ncol) + 3*ncol + 1, 2*min(nrow, ncol) + 1);
        Real work[max(min(size(A, 1), size(A, 2)) + 3*size(A, 2) + 1, 2*min(size(A, 1),
          size(A, 2)) + 1)];
        Real Awork[size(A, 1), size(A, 2)]=A;
        Integer jpvt[size(A, 2)]=zeros(ncol);

      external"FORTRAN 77" dgelsy(
                nrow,
                ncol,
                nrhs,
                Awork,
                nrow,
                x,
                nx,
                jpvt,
                rcond,
                rank,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGELSY computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z' [ inv(T11)*Q1'*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    This routine is basically identical to the original xGELSX except
    three differences:
      o The call to the subroutine xGEQPF has been substituted by
        the call to the subroutine xGEQP3. This subroutine is a Blas-3
        version of the QR factorization with column pivoting.
      o Matrix B (the right hand side) is updated with Blas-3.
      o The permutation of matrix B (the right hand side) is faster and
        more simple.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of AP, otherwise column i is a free column.
            On exit, if JPVT(i) = k, then the i-th column of AP
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number < 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            The unblocked strategy requires that:
               LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
            where MN = min( M, N ).
            The block algorithm requires that:
               LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
            where NB is an upper bound on the blocksize returned
            by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,
            and DORMRZ.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: If INFO = -i, the i-th argument had an illegal value.
"));
      end dgelsy_vec;

      pure function dhseqr
        "Compute eigenvalues of a matrix H using lapack routine DHSEQR for Hessenberg form matrix"
        extends Modelica.Icons.Function;

        input Real H[:, size(H, 1)] "Matrix H with Hessenberg form";
        input Boolean eigenValuesOnly=true
          "= true, if only eigenvalues are computed, otherwise compute the Schur form too";
        input String compz="N" "Specifies the computation of the Schur vectors";
        input Real Z[:, :]=H "Matrix Z";
        output Real alphaReal[size(H, 1)]
          "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
        output Real alphaImag[size(H, 1)]
          "Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
        output Integer info;
        output Real Ho[:, :]=H
          "Schur decomposition (if eigenValuesOnly==false, unspecified else)";
        output Real Zo[:, :]=Z;
        output Real work[3*max(1, size(H, 1))];

    protected
        Integer n=size(H, 1);
        String job=if eigenValuesOnly then "E" else "S";
        Integer ilo=1;
        Integer ihi=n;
        Integer ldh=max(n, 1);
        Integer lwork=3*max(1, size(H, 1))
          "Dimension of the dwork array used in dhseqr";

      external"FORTRAN 77" dhseqr(
                job,
                compz,
                n,
                ilo,
                ihi,
                Ho,
                ldh,
                alphaReal,
                alphaImag,
                Zo,
                ldh,
                work,
                lwork,
                info) annotation (Library={"lapack"});
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DHSEQR computes the eigenvalues of a Hessenberg matrix H
    and, optionally, the matrices T and Z from the Schur decomposition
    H = Z T Z**T, where T is an upper quasi-triangular matrix (the
    Schur form), and Z is the orthogonal matrix of Schur vectors.

    Optionally Z may be postmultiplied into an input orthogonal
    matrix Q so that this routine can give the Schur factorization
    of a matrix A which has been reduced to the Hessenberg form H
    by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

    Arguments
    =========

    JOB   (input) CHARACTER*1
          = 'E':  compute eigenvalues only;
          = 'S':  compute eigenvalues and the Schur form T.

    COMPZ (input) CHARACTER*1
          = 'N':  no Schur vectors are computed;
          = 'I':  Z is initialized to the unit matrix and the matrix Z
                  of Schur vectors of H is returned;
          = 'V':  Z must contain an orthogonal matrix Q on entry, and
                  the product Q*Z is returned.

    N     (input) INTEGER
          The order of the matrix H.  N >= 0.

    ILO   (input) INTEGER
    IHI   (input) INTEGER
          It is assumed that H is already upper triangular in rows
          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
          set by a previous call to DGEBAL, and then passed to DGEHRD
          when the matrix output by DGEBAL is reduced to Hessenberg
          form. Otherwise ILO and IHI should be set to 1 and N
          respectively.  If N>0, then 1<=ILO<=IHI<=N.
          If N = 0, then ILO = 1 and IHI = 0.

    H     (input/output) DOUBLE PRECISION array, dimension (LDH,N)
          On entry, the upper Hessenberg matrix H.
          On exit, if INFO = 0 and JOB = 'S', then H contains the
          upper quasi-triangular matrix T from the Schur decomposition
          (the Schur form); 2-by-2 diagonal blocks (corresponding to
          complex conjugate pairs of eigenvalues) are returned in
          standard form, with H(i,i) = H(i+1,i+1) and
          H(i+1,i)*H(i,i+1)<0. If INFO = 0 and JOB = 'E', the
          contents of H are unspecified on exit.  (The output value of
          H when INFO>0 is given under the description of INFO
          below.)

          Unlike earlier versions of DHSEQR, this subroutine may
          explicitly H(i,j) = 0 for i>j and j = 1, 2, ... ILO-1
          or j = IHI+1, IHI+2, ... N.

    LDH   (input) INTEGER
          The leading dimension of the array H. LDH >= max(1,N).

    WR    (output) DOUBLE PRECISION array, dimension (N)
    WI    (output) DOUBLE PRECISION array, dimension (N)
          The real and imaginary parts, respectively, of the computed
          eigenvalues. If two eigenvalues are computed as a complex
          conjugate pair, they are stored in consecutive elements of
          WR and WI, say the i-th and (i+1)th, with WI(i) > 0 and
          WI(i+1) < 0. If JOB = 'S', the eigenvalues are stored in
          the same order as on the diagonal of the Schur form returned
          in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
          diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
          WI(i+1) = -WI(i).

    Z     (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
          If COMPZ = 'N', Z is not referenced.
          If COMPZ = 'I', on entry Z need not be set and on exit,
          if INFO = 0, Z contains the orthogonal matrix Z of the Schur
          vectors of H.  If COMPZ = 'V', on entry Z must contain an
          N-by-N matrix Q, which is assumed to be equal to the unit
          matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
          if INFO = 0, Z contains Q*Z.
          Normally Q is the orthogonal matrix generated by DORGHR
          after the call to DGEHRD which formed the Hessenberg matrix
          H. (The output value of Z when INFO>0 is given under
          the description of INFO below.)

    LDZ   (input) INTEGER
          The leading dimension of the array Z.  if COMPZ = 'I' or
          COMPZ = 'V', then LDZ>=MAX(1,N).  Otherwise, LDZ>=1.

    WORK  (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
          On exit, if INFO = 0, WORK(1) returns an estimate of
          the optimal value for LWORK.

    LWORK (input) INTEGER
          The dimension of the array WORK.  LWORK >= max(1,N)
          is sufficient and delivers very good and sometimes
          optimal performance.  However, LWORK as large as 11*N
          may be required for optimal performance.  A workspace
          query is recommended to determine the optimal workspace
          size.

          If LWORK = -1, then DHSEQR does a workspace query.
          In this case, DHSEQR checks the input parameters and
          estimates the optimal workspace size for the given
          values of N, ILO and IHI.  The estimate is returned
          in WORK(1).  No error message related to LWORK is
          issued by XERBLA.  Neither H nor Z are accessed.

    INFO  (output) INTEGER
          = 0: successful exit
          < 0: if INFO = -i, the i-th argument had an illegal
               value
          > 0: if INFO = i, DHSEQR failed to compute all of
               the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
               and WI contain those eigenvalues which have been
               successfully computed.  (Failures are rare.)

               If INFO > 0 and JOB = 'E', then on exit, the
               remaining unconverged eigenvalues are the eigen-
               values of the upper Hessenberg matrix rows and
               columns ILO through INFO of the final, output
               value of H.

               If INFO > 0 and JOB   = 'S', then on exit

          (*)  (initial value of H)*U  = U*(final value of H)

               where U is an orthogonal matrix.  The final
               value of H is upper Hessenberg and quasi-triangular
               in rows and columns INFO+1 through IHI.

               If INFO > 0 and COMPZ = 'V', then on exit

                 (final value of Z)  =  (initial value of Z)*U

               where U is the orthogonal matrix in (*) (regard-
               less of the value of JOB.)

               If INFO > 0 and COMPZ = 'I', then on exit
                     (final value of Z)  = U
               where U is the orthogonal matrix in (*) (regard-
               less of the value of JOB.)

               If INFO > 0 and COMPZ = 'N', then Z is not
               accessed.
"));
      end dhseqr;
      annotation (Documentation(info="<html>
<p>
This package contains external Modelica functions as interface to the
LAPACK library
(<a href=\"http://www.netlib.org/lapack\">http://www.netlib.org/lapack</a>)
that provides FORTRAN subroutines to solve linear algebra
tasks. Usually, these functions are not directly called, but only via
the much more convenient interface of
<a href=\"modelica://Modelica.Math.Matrices\">Modelica.Math.Matrices</a>.
The documentation of the LAPACK functions is a copy of the original
FORTRAN code. The details of LAPACK are described in:
</p>

<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <a href=\"http://www.netlib.org/lapack/lug/lapack_lug.html\">Lapack Users' Guide</a>.
     Third Edition, SIAM, 1999.</dd>
</dl>

<p>
See also <a href=\"http://en.wikipedia.org/wiki/Lapack\">http://en.wikipedia.org/wiki/Lapack</a>.
</p>

<p>
This package contains a direct interface to the LAPACK subroutines
</p>

</html>"));
    end LAPACK;

    package Utilities
    "Utility functions that should not be directly utilized by the user"
      extends Modelica.Icons.UtilitiesPackage;

      function eigenvaluesHessenberg
        "Compute eigenvalues of an upper Hessenberg form matrix"
        extends Modelica.Icons.Function;

        import Modelica.Math.Matrices.LAPACK;
        input Real H[:, size(H, 1)] "Hessenberg matrix H";

        output Real ev[size(H, 1), 2] "Eigenvalues";
        output Integer info=0;
    protected
        Real alphaReal[size(H, 1)]
          "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
        Real alphaImag[size(H, 1)]
          "Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
      algorithm
        if size(H, 1) > 0 then
          (alphaReal,alphaImag,info) := LAPACK.dhseqr(H);
        else
          alphaReal := fill(0, size(H, 1));
          alphaImag := fill(0, size(H, 1));
        end if;
        ev := [alphaReal, alphaImag];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
        ev = Matrices.Utilities.<strong>eigenvaluesHessenberg</strong>(H);
(ev, info) = Matrices.Utilities.<strong>eigenvaluesHessenberg</strong>(H);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the eigenvalues of a Hessenberg form matrix. Transformation to Hessenberg form is the first step in eigenvalue computation for arbitrary matrices with QR decomposition.
This step can be skipped if the matrix has already Hessenberg form.
</p>

<p>
The function uses the LAPACK-routine dhseqr. Output <code>info</code> is 0 for a successful call of this
function.<br>
See <a href=\"modelica://Modelica.Math.Matrices.LAPACK.dhseqr\">Matrices.LAPACK.dhseqr</a> for details
</p>

<h4>Example</h4>
<blockquote><pre>
Real A[3,3] = [1,2,3;
               9,8,7;
               0,1,0];

Real ev[3,2];

ev := Matrices.Utilities.eigenvaluesHessenberg(A);

// ev  = [10.7538,    0.0;
          -0.8769,    1.0444;
          -0.8769,   -1.0444]
// = {10.7538,  -0.8769 +- i*1.0444}
</pre></blockquote>
<br>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.eigenValues\">Matrices.eigenValues</a>,
<a href=\"modelica://Modelica.Math.Matrices.hessenberg\">Matrices.hessenberg</a>
</p>
</html>",   revisions="<html>
<ul>
<li><em>2010/04/30 </em>
       by Marcus Baur, DLR-RM</li>
</ul>
</html>"));
      end eigenvaluesHessenberg;
      annotation (Documentation(info="<html>
<p>
This package contains utility functions that are utilized by higher level matrix functions.
These functions are usually not useful for an end-user.
</p>
</html>"));
    end Utilities;
    annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
This library provides functions operating on matrices. Below, the
functions are ordered according to categories and a typical
call of the respective function is shown.
Most functions are solely an interface to the external
<a href=\"modelica://Modelica.Math.Matrices.LAPACK\">LAPACK</a> library.
</p>

<p>
Note: A' is a short hand notation of transpose(A):
</p>

<p><strong>Basic Information</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.toString\">toString</a>(A)
     - returns the string representation of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.isEqual\">isEqual</a>(M1, M2)
     - returns true if matrices M1 and M2 have the same size and the same elements.</li>
</ul>

<p><strong>Linear Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.solve\">solve</a>(A,b)
     - returns solution x of the linear equation A*x=b (where b is a vector,
       and A is a square matrix that must be regular).</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.solve2\">solve2</a>(A,B)
     - returns solution X of the linear equation A*X=B (where B is a matrix,
       and A is a square matrix that must be regular)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares\">leastSquares</a>(A,b)
     - returns solution x of the linear equation A*x=b in a least squares sense
       (where b is a vector and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">leastSquares2</a>(A,B)
     - returns solution X of the linear equation A*X=B in a least squares sense
       (where B is a matrix and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.equalityLeastSquares\">equalityLeastSquares</a>(A,a,B,b)
     - returns solution x of a linear equality constrained least squares problem:
       min|A*x-a|^2 subject to B*x=b</li>

<li> (LU,p,info) = <a href=\"modelica://Modelica.Math.Matrices.LU\">LU</a>(A)
     - returns the LU decomposition with row pivoting of a rectangular matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve\">LU_solve</a>(LU,p,b)
     - returns solution x of the linear equation L*U*x[p]=b with a b
       vector and an LU decomposition from \"LU(..)\".</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve2\">LU_solve2</a>(LU,p,B)
     - returns solution X of the linear equation L*U*X[p,:]=B with a B
       matrix and an LU decomposition from \"LU(..)\".</li>
</ul>

<p><strong>Matrix Factorizations</strong></p>
<ul>
<li> (eval,evec) = <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">eigenValues</a>(A)
     - returns eigen values \"eval\" and eigen vectors \"evec\" for a real,
       nonsymmetric matrix A in a Real representation.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">eigenValueMatrix</a>(eval)
     - returns real valued block diagonal matrix of the eigenvalues \"eval\" of matrix A.</li>

<li> (sigma,U,VT) = <a href=\"modelica://Modelica.Math.Matrices.singularValues\">singularValues</a>(A)
     - returns singular values \"sigma\" and left and right singular vectors U and VT
       of a rectangular matrix A.</li>

<li> (Q,R,p) = <a href=\"modelica://Modelica.Math.Matrices.QR\">QR</a>(A)
     - returns the QR decomposition with column pivoting of a rectangular matrix A
       such that Q*R = A[:,p].</li>

<li> (H,U) = <a href=\"modelica://Modelica.Math.Matrices.hessenberg\">hessenberg</a>(A)
     - returns the upper Hessenberg form H and the orthogonal transformation matrix U
       of a square matrix A such that H = U'*A*U.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.realSchur\">realSchur</a>(A)
     - returns the real Schur form of a square matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.cholesky\">cholesky</a>(A)
     - returns the cholesky factor H of a real symmetric positive definite matrix A so that A = H'*H.</li>

<li> (D,Aimproved) = <a href=\"modelica://Modelica.Math.Matrices.balance\">balance</a>(A)
     - returns an improved form Aimproved of a square matrix A that has a smaller condition as A,
       with Aimproved = inv(diagonal(D))*A*diagonal(D).</li>
</ul>

<p><strong>Matrix Properties</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.trace\">trace</a>(A)
     - returns the trace of square matrix A, i.e., the sum of the diagonal elements.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.det\">det</a>(A)
     - returns the determinant of square matrix A (using LU decomposition; try to avoid det(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.inv\">inv</a>(A)
     - returns the inverse of square matrix A (try to avoid, use instead \"solve2(..) with B=identity(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rank\">rank</a>(A)
     - returns the rank of square matrix A (computed with singular value decomposition)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.conditionNumber\">conditionNumber</a>(A)
     - returns the condition number norm(A)*norm(inv(A)) of a square matrix A in the range 1..&infin;.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rcond\">rcond</a>(A)
     - returns the reciprocal condition number 1/conditionNumber(A) of a square matrix A in the range 0..1.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.norm\">norm</a>(A)
     - returns the 1-, 2-, or infinity-norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.frobeniusNorm\">frobeniusNorm</a>(A)
     - returns the Frobenius norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.nullSpace\">nullSpace</a>(A)
     - returns the null space of matrix A.</li>
</ul>

<p><strong>Matrix Exponentials</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.exp\">exp</a>(A)
     - returns the exponential e^A of a matrix A by adaptive Taylor series
       expansion with scaling and balancing</li>

<li> (phi, gamma) = <a href=\"modelica://Modelica.Math.Matrices.integralExp\">integralExp</a>(A,B)
     - returns the exponential phi=e^A and the integral gamma=integral(exp(A*t)*dt)*B as needed
       for a discretized system with zero order hold.</li>

<li> (phi, gamma, gamma1) = <a href=\"modelica://Modelica.Math.Matrices.integralExpT\">integralExpT</a>(A,B)
     - returns the exponential phi=e^A, the integral gamma=integral(exp(A*t)*dt)*B,
       and the time-weighted integral gamma1 = integral((T-t)*exp(A*t)*dt)*B as needed
       for a discretized system with first order hold.</li>
</ul>

<p><strong>Matrix Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.continuousLyapunov\">continuousLyapunov</a>(A,C)
     - returns solution X of the continuous-time Lyapunov equation X*A + A'*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousSylvester\">continuousSylvester</a>(A,B,C)
     - returns solution X of the continuous-time Sylvester equation A*X + X*B = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousRiccati\">continuousRiccati</a>(A,B,R,Q)
     - returns solution X of the continuous-time algebraic Riccati equation
       A'*X + X*A - X*B*inv(R)*B'*X + Q = 0</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteLyapunov\">discreteLyapunov</a>(A,C)
     - returns solution X of the discrete-time Lyapunov equation A'*X*A + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteSylvester\">discreteSylvester</a>(A,B,C)
     - returns solution X of the discrete-time Sylvester equation A*X*B + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteRiccati\">discreteRiccati</a>(A,B,R,Q)
     - returns solution X of the discrete-time algebraic Riccati equation
       A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0</li>
</ul>

<p><strong>Matrix Manipulation</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.sort\">sort</a>(M)
     - returns the sorted rows or columns of matrix M in ascending or descending order.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipLeftRight\">flipLeftRight</a>(M)
     - returns matrix M so that the columns of M are flipped in left/right direction.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipUpDown\">flipUpDown</a>(M)
     - returns matrix M so that the rows of M are flipped in up/down direction.</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Vectors\">Vectors</a>

</html>"),   Icon(graphics={
          Rectangle(
            extent={{-60,66},{-30,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,66},{58,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,-18},{-30,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,-18},{58,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid)}));
  end Matrices;

        package Polynomials
    "Library of functions operating on polynomials (including polynomial fitting)"
          extends Modelica.Icons.FunctionsPackage;

          function evaluate "Evaluate polynomial at a given abscissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of polynomial at u";
          algorithm
            y := p[1];
            for j in 2:size(p, 1) loop
              y := p[j] + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=evaluate_der);
          end evaluate;

          function evaluate_der
            "Evaluate derivative of polynomial at a given abscissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy "Value of derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              dy := p[j]*(n - j) + u*dy;
            end for;
            dy := dy*du;
          end evaluate_der;

          encapsulated function roots
            "Compute zeros of a polynomial where the highest coefficient is assumed as not to be zero"
            import Modelica.Math.Matrices;
            import Modelica;
            extends Modelica.Icons.Function;
            input Real p[:]
              "Vector with polynomial coefficients p[1]*x^n + p[2]*x^(n-1) + p[n]*x +p[n-1]";
            output Real roots[max(0, size(p, 1) - 1), 2]=fill(
                      0,
                      max(0, size(p, 1) - 1),
                      2)
              "roots[:,1] and roots[:,2] are the real and imaginary parts of the roots of polynomial p";
        protected
            Integer np=size(p, 1);
            Integer n=size(p, 1) - 1;
            Real A[max(size(p, 1) - 1, 0), max(size(p, 1) - 1, 0)] "Companion matrix";
            Real ev[max(size(p, 1) - 1, 0), 2] "Eigenvalues";
          algorithm
            if n > 0 then
              assert(abs(p[1]) > 0,
                "Computing the roots of a polynomial with function \"Modelica.Math.Polynomials.roots\"\n"
                 +
                "failed because the first element of the coefficient vector is zero, but should not be.");

              // companion matrix
              A[1, :] := -p[2:np]/p[1];
              A[2:n, :] := [identity(n - 1), zeros(n - 1)];

              // roots are the eigenvalues of the companion matrix
              roots := Matrices.Utilities.eigenvaluesHessenberg(A);
            end if;
            annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
r = Polynomials.<strong>roots</strong>(p);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the roots of a polynomial P of x
</p>
<blockquote><pre>
P = p[1]*x^n + p[2]*x^(n-1) + ... + p[n-1]*x + p[n+1];
</pre></blockquote>
<p>
with the coefficient vector <strong>p</strong>. It is assumed that the first element of <strong>p</strong> is not zero, i.e., that the polynomial is of order size(p,1)-1.
</p>
<p>
To compute the roots, the eigenvalues of the corresponding companion matrix <strong>C</strong>
</p>
<blockquote><pre>
       |-p[2]/p[1]  -p[3]/p[1]  ...  -p[n-2]/p[1]  -p[n-1]/p[1]  -p[n]/p[1] |
       |    1            0                0               0           0     |
       |    0            1      ...       0               0           0     |
<strong>C</strong> =    |    .            .      ...       .               .           .     |
       |    .            .      ...       .               .           .     |
       |    0            0      ...       0               1           0     |
</pre></blockquote>
<p>
are calculated. These are the roots of the polynomial.<br>
Since the companion matrix has already Hessenberg form, the transformation to Hessenberg form has not to be performed.
Function <a href=\"modelica://Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg\">eigenvaluesHessenberg</a><br>
provides efficient eigenvalue computation for those matrices.
</p>
<h4>Example</h4>
<blockquote><pre>
r = <strong>roots</strong>({1,2,3});
// r = [-1.0,  1.41421356237309;
//      -1.0, -1.41421356237309]
// which corresponds to the roots: -1.0 +/- j*1.41421356237309
</pre></blockquote>
</html>"));
          end roots;
          annotation (Documentation(info="<html>
<p>
This package contains functions to operate on polynomials,
in particular to determine the derivative and the integral
of a polynomial and to use a polynomial to fit a given set
of data points.
</p>

<p>
Copyright &copy; 2004-2020, Modelica Association and contributors
</p>
</html>",         revisions="<html>
<ul>
<li><em>Oct. 22, 2004</em> by Martin Otter (DLR):<br>
       Renamed functions to not have abbreviations.<br>
       Based fitting on LAPACK<br>
       New function to return the polynomial of an indefinite integral</li>
<li><em>Sept. 3, 2004</em> by Jonas Eborn (Scynamics):<br>
       polyderval, polyintval added</li>
<li><em>March 1, 2004</em> by Martin Otter (DLR):<br>
       first version implemented</li>
</ul>
</html>"));
        end Polynomials;

  package Icons "Icons for Math"
    extends Modelica.Icons.IconsPackage;

    partial function AxisLeft
      "Basic icon for mathematical function with y-axis on left side"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
            Polygon(
              points={{-80,90},{-88,68},{-72,68},{-80,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              textColor={0,0,255})}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis on the left side.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisLeft;

    partial function AxisCenter
      "Basic icon for mathematical function with y-axis in the center"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-80},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              textColor={0,0,255})}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis in the middle.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisCenter;
  end Icons;

  function sin "Sine"
    extends Modelica.Math.Icons.AxisLeft;
    input Modelica.Units.SI.Angle u "Independent variable";
    output Real y "Dependent variable y=sin(u)";

  external "builtin" y = sin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
                {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},
                {-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},
                {29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{
                57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}),
          Text(
            extent={{12,84},{84,36}},
            textColor={192,192,192},
            textString="sin")}),
      Documentation(info="<html>
<p>
This function returns y = sin(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/sin.png\">
</p>
</html>"));
  end sin;

  function cos "Cosine"
    extends Modelica.Math.Icons.AxisLeft;
    input Modelica.Units.SI.Angle u "Independent variable";
    output Real y "Dependent variable y=cos(u)";

  external "builtin" y = cos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
                {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
                {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},
                {24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
                73.4},{75.2,78.6},{80,80}}),
          Text(
            extent={{-36,82},{36,34}},
            textColor={192,192,192},
            textString="cos")}),
      Documentation(info="<html>
<p>
This function returns y = cos(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cos.png\">
</p>
</html>"));
  end cos;

  function tan "Tangent (u shall not be -pi/2, pi/2, 3*pi/2, ...)"
    extends Modelica.Math.Icons.AxisCenter;
    input Modelica.Units.SI.Angle u "Independent variable";
    output Real y "Dependent variable y=tan(u)";

  external "builtin" y = tan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
                {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
                {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
                47.4},{76,56.1},{77.6,63.8},{80,80}}),
          Text(
            extent={{-90,72},{-18,24}},
            textColor={192,192,192},
            textString="tan")}),
      Documentation(info="<html>
<p>
This function returns y = tan(u), with -&infin; &lt; u &lt; &infin;
(if u is a multiple of (2n-1)*pi/2, y = tan(u) is +/- infinity).
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tan.png\">
</p>
</html>"));
  end tan;

  function asin "Inverse sine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u "Independent variable";
    output Modelica.Units.SI.Angle y "Dependent variable y=asin(u)";

  external "builtin" y = asin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
                -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
                52.7},{75.2,62.2},{77.6,67.5},{80,80}}),
          Text(
            extent={{-88,78},{-16,30}},
            textColor={192,192,192},
            textString="asin")}),
      Documentation(info="<html>
<p>
This function returns y = asin(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asin.png\">
</p>
</html>"));
  end asin;

  function acos "Inverse cosine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u "Independent variable";
    output Modelica.Units.SI.Angle y "Dependent variable y=acos(u)";

  external "builtin" y = acos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80},{68,-80}}, color={192,192,192}),
          Polygon(
            points={{90,-80},{68,-72},{68,-88},{90,-80}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,
                49.8},{-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},
                {75.2,-62.2},{77.6,-67.5},{80,-80}}),
          Text(
            extent={{-86,-14},{-14,-62}},
            textColor={192,192,192},
            textString="acos")}),
      Documentation(info="<html>
<p>
This function returns y = acos(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/acos.png\">
</p>
</html>"));
  end acos;

  function atan "Inverse tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u "Independent variable";
    output Modelica.Units.SI.Angle y "Dependent variable y=atan(u)";

  external "builtin" y = atan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},
                {-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},
                {9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,
                73.6},{69.5,78.6},{80,80}}),
          Text(
            extent={{-86,68},{-14,20}},
            textColor={192,192,192},
            textString="atan")}),
      Documentation(info="<html>
<p>
This function returns y = atan(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/atan.png\">
</p>
</html>"));
  end atan;

  function tanh "Hyperbolic tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u "Independent variable";
    output Real y "Dependent variable y=tanh(u)";

  external "builtin" y = tanh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-47.8,-78.7},{-35.8,-75.7},{-27.7,-70.6},{-22.1,
                -64.2},{-17.3,-55.9},{-12.5,-44.3},{-7.64,-29.2},{-1.21,-4.82},{
                6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},
                {45.4,78.4},{72,79.9},{80,80}}),
          Text(
            extent={{-88,72},{-16,24}},
            textColor={192,192,192},
            textString="tanh")}),
      Documentation(info="<html>
<p>
This function returns y = tanh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tanh.png\">
</p>
</html>"));
  end tanh;

  function exp "Exponential, base e"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u "Independent variable";
    output Real y "Dependent variable y=exp(u)";

  external "builtin" y = exp(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80.3976},{68,-80.3976}}, color={192,192,192}),
          Polygon(
            points={{90,-80.3976},{68,-72.3976},{68,-88.3976},{90,-80.3976}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},
                {34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{
                67.1,18.6},{72,38.2},{76,57.6},{80,80}}),
          Text(
            extent={{-86,50},{-14,2}},
            textColor={192,192,192},
            textString="exp")}),
      Documentation(info="<html>
<p>
This function returns y = exp(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/exp.png\">
</p>
</html>"));
  end exp;

  function log "Natural (base e) logarithm (u shall be > 0)"
    extends Modelica.Math.Icons.AxisLeft;
    input Real u "Independent variable";
    output Real y "Dependent variable y=ln(u)";

  external "builtin" y = log(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
          Text(
            extent={{-6,-24},{66,-72}},
            textColor={192,192,192},
            textString="log")}),
      Documentation(info="<html>
<p>
This function returns y = log(10) (the natural logarithm of u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log.png\">
</p>
</html>"));
  end log;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
            {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
              {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
              -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
              -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
              {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
              0,0,0}, smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This package contains <strong>basic mathematical functions</strong> (such as sin(..)),
as well as functions operating on
<a href=\"modelica://Modelica.Math.Vectors\">vectors</a>,
<a href=\"modelica://Modelica.Math.Matrices\">matrices</a>,
<a href=\"modelica://Modelica.Math.Nonlinear\">nonlinear functions</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors\">Boolean vectors</a>.
</p>

<h4>Main Authors</h4>
<p><a href=\"http://www.robotic.dlr.de/Martin.Otter/\"><strong>Martin Otter</strong></a>
and <strong>Marcus Baur</strong><br>
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e.V. (DLR)<br>
Institut f&uuml;r Systemdynamik und Regelungstechnik (DLR-SR)<br>
Forschungszentrum Oberpfaffenhofen<br>
D-82234 Wessling<br>
Germany<br>
email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a>
</p>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>June 22, 2019</em>
       by Thomas Beutlich: Functions tempInterpol1/tempInterpol2 moved to ObsoleteModelica4</li>
<li><em>August 24, 2016</em>
       by Christian Kral: added wrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Function tempInterpol2 added.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Icons for icon and diagram level introduced.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>
</html>"));
  end Math;

  package Utilities
  "Library of utility functions dedicated to scripting (operating on files, streams, strings, system)"
    extends Modelica.Icons.UtilitiesPackage;

    package Streams "Read from files and write to files"
      extends Modelica.Icons.FunctionsPackage;

      impure function print "Print string to terminal or file"
        extends Modelica.Icons.Function;
        input String string="" "String to be printed";
        input String fileName=""
          "File where to print (empty string is the terminal)"
                     annotation(Dialog(saveSelector(filter="Text files (*.txt)",
                            caption="Text file to store the output of print(..)")));
      external "C" ModelicaInternal_print(string, fileName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>print</strong>(string);
Streams.<strong>print</strong>(string,fileName);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>print</strong>(..) opens automatically the given file, if
it is not yet open. If the file does not exist, it is created.
If the file does exist, the given string is appended to the file.
If this is not desired, call \"Files.remove(fileName)\" before calling print
(\"remove(..)\" is silent, if the file does not exist).
The Modelica environment may close the file whenever appropriate.
This can be enforced by calling <strong>Streams.close</strong>(fileName).
After every call of \"print(..)\" a \"new line\" is printed automatically.
</p>
<h4>Example</h4>
<blockquote><pre>
Streams.print(\"x = \" + String(x));
Streams.print(\"y = \" + String(y));
Streams.print(\"x = \" + String(y), \"mytestfile.txt\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.error\">Streams.error</a>,
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end print;

      impure function readLine "Read a line of text from a file and return it in a string"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be read"
                            annotation(Dialog(loadSelector(filter="Text files (*.txt)",
                            caption="Open text file for reading")));
        input Integer lineNumber(min=1) "Number of line to read";
        output String string "Line of text";
        output Boolean endOfFile
          "If true, end-of-file was reached when trying to read line";
       external "C" string = ModelicaInternal_readLine(fileName,lineNumber,endOfFile) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(string, endOfFile) = Streams.<strong>readLine</strong>(fileName, lineNumber)
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>readLine</strong>(..) opens the given file, reads enough of the
content to get the requested line, and returns the line as a string.
Lines are separated by LF or CR-LF; the returned string does not
contain the line separator. The file might remain open after
the call.
</p>
<p>
If lineNumber > countLines(fileName), an empty string is returned
and endOfFile=true. Otherwise endOfFile=false.
</p>
</html>"));
      end readLine;

      pure function error "Print error message and cancel all actions - in case of an unrecoverable error"
        extends Modelica.Icons.Function;
        input String string "String to be printed to error message window";
        external "C" ModelicaError(string) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaUtilities.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>error</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
In case of an unrecoverable error (i.e., if the solver is unable to recover from the error),
print the string \"string\" as error message and cancel all actions.
This function is semantically equivalent with the built-in function <strong>assert</strong> if called with the (default) <strong>AssertionLevel.error</strong>.
Line breaks are characterized by \"\\n\" in the string.
</p>
<h4>Example</h4>
<blockquote><pre>
Streams.error(\"x (= \" + String(x) + \")\\nhas to be in the range 0 .. 1\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.print\">Streams.print</a>,
<a href=\"modelica://ModelicaReference.Operators.'assert()'\">ModelicaReference.Operators.'assert()'</a>
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end error;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Streams</strong> contains functions to input and output strings
to a message window or on files, as well as reading matrices from file
and writing matrices to file. Note that a string is interpreted
and displayed as html text (e.g., with print(..) or error(..))
if it is enclosed with the Modelica html quotation, e.g.,
</p>
<blockquote><p>
string = \"&lt;html&gt; first line &lt;br&gt; second line &lt;/html&gt;\".
</p></blockquote>
<p>
It is a quality of implementation, whether (a) all tags of html are supported
or only a subset, (b) how html tags are interpreted if the output device
does not allow to display formatted text.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string)<br>
          <a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string,fileName)</td>
      <td> Print string \"string\" or vector of strings to message window or on
           file \"fileName\".</td>
  </tr>
  <tr><td>stringVector =
         <a href=\"modelica://Modelica.Utilities.Streams.readFile\">readFile</a>(fileName)</td>
      <td> Read complete text file and return it as a vector of strings.</td>
  </tr>
  <tr><td>(string, endOfFile) =
         <a href=\"modelica://Modelica.Utilities.Streams.readLine\">readLine</a>(fileName, lineNumber)</td>
      <td>Returns from the file the content of line lineNumber.</td>
  </tr>
  <tr><td>lines =
         <a href=\"modelica://Modelica.Utilities.Streams.countLines\">countLines</a>(fileName)</td>
      <td>Returns the number of lines in a file.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.error\">error</a>(string)</td>
      <td> Print error message \"string\" to message window
           and cancel all actions</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.close\">close</a>(fileName)</td>
      <td> Close file if it is still open. Ignore call if
           file is already closed or does not exist. </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>(fileName, matrixName)</td>
      <td> Read dimensions of a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readRealMatrix\">readRealMatrix</a>(fileName, matrixName, nrow, ncol)</td>
      <td> Read a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.writeRealMatrix\">writeRealMatrix</a>(fileName, matrixName, matrix, append, format)</td>
      <td> Write Real matrix to a MATLAB MAT file. </td></tr>
</table>
<p>
Use functions <strong>scanXXX</strong> from package
<a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
to parse a string.
</p>
<p>
If Real, Integer or Boolean values shall be printed
or used in an error message, they have to be first converted
to strings with the builtin operator
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>(...).
Example:
</p>
<blockquote><pre>
<strong>if</strong> x &lt; 0 <strong>or</strong> x &gt; 1 <strong>then</strong>
   Streams.error(\"x (= \" + String(x) + \") has to be in the range 0 .. 1\");
<strong>end if</strong>;
</pre></blockquote>
</html>"));
    end Streams;

    package Strings "Operations on strings"
      extends Modelica.Icons.FunctionsPackage;

      pure function length "Return length of string"
        extends Modelica.Icons.Function;
        input String string;
        output Integer result "Number of characters of string";
      external "C" result = ModelicaStrings_length(string) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>length</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of characters of \"string\".
</p>
</html>"));
      end length;

      pure function substring "Return a substring defined by start and end index"
        extends Modelica.Icons.Function;
        input String string "String from which a substring is inquired";
        input Integer startIndex(min=1)
          "Character position of substring begin (index=1 is first character in string)";
        input Integer endIndex(min=1) "Character position of substring end";
        output String result
          "String containing substring string[startIndex:endIndex]";
      external "C" result = ModelicaStrings_substring(string,startIndex,endIndex) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<strong>substring</strong>(string, startIndex, endIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns
the substring from position startIndex
up to and including position endIndex of \"string\" .
</p>
<p>
If index, startIndex, or endIndex are not correct, e.g.,
if endIndex &gt; length(string), an assert is triggered.
</p>
<h4>Example</h4>
<blockquote><pre>
string1 := \"This is line 111\";
string2 := Strings.substring(string1,9,12); // string2 = \"line\"
</pre></blockquote>
</html>"));
      end substring;

      pure function compare "Compare two strings lexicographically"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true "= false, if case of letters is ignored";
        output Modelica.Utilities.Types.Compare result "Result of comparison";
      external "C" result = ModelicaStrings_compare(string1, string2, caseSensitive) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Strings.<strong>compare</strong>(string1, string2);
result = Strings.<strong>compare</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compares two strings. If the optional argument caseSensitive=false,
upper case letters are treated as if they would be lower case letters.
The result of the comparison is returned as:
</p>
<blockquote><pre>
result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
       = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
       = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
</pre></blockquote>
<p>
Comparison is with regards to lexicographical order,
e.g., \"a\" &lt; \"b\";
</p>
</html>"));
      end compare;

      function isEqual "Determine whether two strings are identical"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the comparison";
        output Boolean identical "True, if string1 is identical to string2";
      algorithm
        identical :=compare(string1, string2, caseSensitive) == Types.Compare.Equal;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEqual</strong>(string1, string2);
Strings.<strong>isEqual</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compare whether two strings are identical,
optionally ignoring case.
</p>
</html>"));
      end isEqual;

      function isEmpty
        "Return true if a string is empty (has only white space characters)"
        extends Modelica.Icons.Function;
        input String string;
        output Boolean result "True, if string is empty";
    protected
        Integer nextIndex;
        Integer len;
      algorithm
        nextIndex := Strings.Advanced.skipWhiteSpace(string);
        len := Strings.length(string);
        if len < 1 or nextIndex > len then
          result := true;
        else
          result := false;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEmpty</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns true if the string has no characters or if the string consists
only of white space characters. Otherwise, false is returned.
</p>

<h4>Example</h4>
<blockquote><pre>
isEmpty(\"\");       // returns true
isEmpty(\"   \");    // returns true
isEmpty(\"  abc\");  // returns false
isEmpty(\"a\");      // returns false
</pre></blockquote>
</html>"));
      end isEmpty;

      function find "Find first occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=1)=1 "Start search at index startIndex";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
         output Integer index
          "Index of the beginning of the first occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lengthSearchString = length(searchString);
        Integer len = lengthSearchString-1;
        Integer i = startIndex;
        Integer i_max = length(string) - lengthSearchString + 1;
      algorithm
        index := 0;
        while i <= i_max loop
           if isEqual(substring(string,i,i+len),
                      searchString, caseSensitive) then
              index := i;
              i := i_max + 1;
           else
              i := i+1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>find</strong>(string, searchString);
index = Strings.<strong>find</strong>(string, searchString, startIndex=1,
                     caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
and return the corresponding index.
Start search at index \"startIndex\" (default = 1).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end find;

      function findLast "Find last occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=0)=0
          "Start search at index startIndex. If startIndex = 0, start at length(string)";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
        output Integer index
          "Index of the beginning of the last occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lenString = length(string);
        Integer lenSearchString = length(searchString);
        Integer iMax=lenString - lenSearchString + 1;
        Integer i;
      algorithm
        i := if startIndex == 0 or startIndex > iMax then iMax else startIndex;
        index := 0;
        while i >= 1 loop
           if isEqual(substring(string,i,i+lenSearchString-1),
                      searchString, caseSensitive) then
              index := i;
              i := 0;
           else
              i := i-1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>findLast</strong>(string, searchString);
index = Strings.<strong>findLast</strong>(string, searchString,
                         startIndex=length(string), caseSensitive=true,
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
when searching from the last character of \"string\"
backwards, and return the corresponding index.
Start search at index \"startIndex\" (default = 0;
if startIndex = 0, search starts at length(string)).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end findLast;

      package Advanced "Advanced scanning functions"
        extends Modelica.Icons.FunctionsPackage;

        pure function scanReal "Scan a signed real number"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1 "Index where scanning starts";
          input Boolean unsigned=false
            "= true, if number shall not start with '+' or '-'";
          output Integer nextIndex
            "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output Real number "Value of Real number";
          external "C" ModelicaStrings_scanReal(string, startIndex, unsigned, nextIndex, number) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, realNumber) = <strong>scanReal</strong>(string, startIndex=1, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a number
of type Real with an optional sign according to the Modelica grammar:
</p>
<blockquote><pre>
real     ::= [sign] unsigned [fraction] [exponent]
sign     ::= '+' | '-'
unsigned ::= digit [unsigned]
fraction ::= '.' [unsigned]
exponent ::= ('e' | 'E') [sign] unsigned
digit    ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
</pre></blockquote>
<p>
If successful, the function returns nextIndex = index of character
directly after the found real number, as well as the value
in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is zero.
</p>
<p>
If the optional argument \"unsigned\" is <strong>true</strong>, the number
shall not start with '+' or '-'. The default of \"unsigned\" is <strong>false</strong>.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end scanReal;

        pure function skipWhiteSpace "Scan white space"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1;
          output Integer nextIndex;
          external "C" nextIndex = ModelicaStrings_skipWhiteSpace(string, startIndex) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
nextIndex = <strong>skipWhiteSpace</strong>(string, startIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\" and
skips white space. The function returns nextIndex = index of character
of the first non white space character.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end skipWhiteSpace;
        annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings.Advanced</strong> contains basic scanning
functions. These functions should be <strong>not called</strong> directly, because
it is much simpler to utilize the higher level functions \"Strings.scanXXX\".
The functions of the \"Strings.Advanced\" library provide
the basic interface in order to implement the higher level
functions in package \"Strings\".
</p>
<p>
Library \"Advanced\" provides the following functions:
</p>
<blockquote><pre>
(nextIndex, realNumber)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>        (string, startIndex, unsigned=false);
(nextIndex, integerNumber) = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>     (string, startIndex, unsigned=false);
(nextIndex, string2)       = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>      (string, startIndex);
(nextIndex, identifier)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>  (string, startIndex);
 nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipWhiteSpace\">skipWhiteSpace</a>  (string, startIndex);
 nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a>(string, startIndex);
</pre></blockquote>
<p>
All functions perform the following actions:
</p>
<ol>
<li> Scanning starts at character position \"startIndex\" of
     \"string\" (startIndex has a default of 1).</li>
<li> First, white space is skipped, such as blanks (\" \"), tabs (\"\\t\"), or newline (\"\\n\")</li>
<li> Afterwards, the required token is scanned.</li>
<li> If successful, on return nextIndex = index of character
     directly after the found token and the token value is returned
     as second output argument.<br>
     If not successful, on return nextIndex = startIndex.
     </li>
</ol>
<p>
The following additional rules apply for the scanning:
</p>
<ul>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>:<br>
     Scans a full number including one optional leading \"+\" or \"-\" (if unsigned=false)
     according to the Modelica grammar. For example, \"+1.23e-5\", \"0.123\" are
     Real numbers, but \".1\" is not.
     Note, an Integer number, such as \"123\" is also treated as a Real number.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>:<br>
     Scans an Integer number including one optional leading \"+\"
     or \"-\" (if unsigned=false) according to the Modelica (and C/C++) grammar.
     For example, \"+123\", \"20\" are Integer numbers.
     Note, a Real number, such as \"123.4\" is not an Integer and
     scanInteger returns nextIndex = startIndex.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>:<br>
     Scans a String according to the Modelica (and C/C++) grammar, e.g.,
     \"This is a \"string\"\" is a valid string token.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>:<br>
     Scans a Modelica identifier, i.e., the identifier starts either
     with a letter, followed by letters, digits or \"_\".
     For example, \"w_rel\", \"T12\".<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a><br>
     Skips white space and Modelica (C/C++) line comments iteratively.
     A line comment starts with \"//\" and ends either with an
     end-of-line (\"\\n\") or the end of the \"string\".</li>
</ul>
</html>"));
      end Advanced;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings</strong> contains functions to manipulate strings.
</p>
<p>
In the table below an example
call to every function is given using the <strong>default</strong> options.
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><th><strong><em>Function</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td>len = <a href=\"modelica://Modelica.Utilities.Strings.length\">length</a>(string)</td>
      <td>Returns length of string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.substring\">substring</a>(string1,startIndex,endIndex)
       </td>
      <td>Returns a substring defined by start and end index</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n)<br>
 result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n,string)</td>
      <td>Repeat a blank or a string n times.</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.compare\">compare</a>(string1, string2)</td>
      <td>Compares two substrings with regards to alphabetical order</td></tr>
  <tr><td>identical =
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">isEqual</a>(string1,string2)</td>
      <td>Determine whether two strings are identical</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.count\">count</a>(string,searchString)</td>
      <td>Count the number of occurrences of a string</td></tr>
  <tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.find\">find</a>(string,searchString)</td>
      <td>Find first occurrence of a string in another string</td></tr>
<tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.findLast\">findLast</a>(string,searchString)</td>
      <td>Find last occurrence of a string in another string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.replace\">replace</a>(string,searchString,replaceString)</td>
      <td>Replace one or all occurrences of a string</td></tr>
  <tr><td>stringVector2 = <a href=\"modelica://Modelica.Utilities.Strings.sort\">sort</a>(stringVector1)</td>
      <td>Sort vector of strings in alphabetic order</td></tr>
  <tr><td>hash = <a href=\"modelica://Modelica.Utilities.Strings.hashString\">hashString</a>(string)</td>
      <td>Create a hash value of a string</td></tr>
  <tr><td>(token, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanToken\">scanToken</a>(string,startIndex)</td>
      <td>Scan for a token (Real/Integer/Boolean/String/Identifier/Delimiter/NoToken)</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanReal\">scanReal</a>(string,startIndex)</td>
      <td>Scan for a Real constant</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanInteger\">scanInteger</a>(string,startIndex)</td>
      <td>Scan for an Integer constant</td></tr>
  <tr><td>(boolean, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanBoolean\">scanBoolean</a>(string,startIndex)</td>
      <td>Scan for a Boolean constant</td></tr>
  <tr><td>(string2, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanString\">scanString</a>(string,startIndex)</td>
      <td>Scan for a String constant</td></tr>
  <tr><td>(identifier, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanIdentifier\">scanIdentifier</a>(string,startIndex)</td>
      <td>Scan for an identifier</td></tr>
  <tr><td>(delimiter, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanDelimiter\">scanDelimiter</a>(string,startIndex)</td>
      <td>Scan for delimiters</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.scanNoToken\">scanNoToken</a>(string,startIndex)</td>
      <td>Check that remaining part of string consists solely of<br>
          white space or line comments (\"// ...\\n\").</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.syntaxError\">syntaxError</a>(string,index,message)</td>
      <td> Print a \"syntax error message\" as well as a string and the<br>
           index at which scanning detected an error</td></tr>
</table>
<p>
The functions \"compare\", \"isEqual\", \"count\", \"find\", \"findLast\", \"replace\", \"sort\"
have the optional
input argument <strong>caseSensitive</strong> with default <strong>true</strong>.
If <strong>false</strong>, the operation is carried out without taking
into account whether a character is upper or lower case.
</p>
</html>"));
    end Strings;

    package Types "Type definitions used in package Modelica.Utilities"
      extends Modelica.Icons.TypesPackage;

      type Compare = enumeration(
          Less "String 1 is lexicographically less than string 2",
          Equal "String 1 is identical to string 2",
          Greater "String 1 is lexicographically greater than string 2")
        "Enumeration defining comparison of two strings";
      annotation (Documentation(info="<html>
<p>
This package contains type definitions used in Modelica.Utilities.
</p>

</html>"));
    end Types;
      annotation (
  Documentation(info="<html>
<p>
This package contains Modelica <strong>functions</strong> that are
especially suited for <strong>scripting</strong>. The functions might
be used to work with strings, read data from file, write data
to file or copy, move and remove files.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.UsersGuide\">Modelica.Utilities.User's Guide</a>
     discusses the most important aspects of this library.</li>
<li> <a href=\"modelica://Modelica.Utilities.Examples\">Modelica.Utilities.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
The following main sublibraries are available:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.Files\">Files</a>
     provides functions to operate on files and directories, e.g.,
     to copy, move, remove files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>
     provides functions to read from files and write to files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
     provides functions to operate on strings. E.g.
     substring, find, replace, sort, scanToken.</li>
<li> <a href=\"modelica://Modelica.Utilities.System\">System</a>
     provides functions to interact with the environment.
     E.g., get or set the working directory or environment
     variables and to send a command to the default shell.</li>
</ul>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>"));
  end Utilities;

  package Constants
  "Library of mathematical constants and constants of nature (e.g., pi, eps, R, sigma)"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;
    import Modelica.Units.NonSI;

    final constant Real pi=2*Modelica.Math.asin(1.0);

    final constant Real eps=ModelicaServices.Machine.eps
      "Biggest number such that 1.0 + eps = 1.0";

    final constant Real small=ModelicaServices.Machine.small
      "Smallest number such that small and -small are representable on the machine";

    final constant Real inf=ModelicaServices.Machine.inf
      "Biggest Real number such that inf and -inf are representable on the machine";

    final constant SI.Velocity c=299792458 "Speed of light in vacuum";

    final constant Real h(final unit="J.s") = 6.62607015e-34
      "Planck constant";

    final constant Real k(final unit="J/K") = 1.380649e-23
      "Boltzmann constant";

    final constant Real R(final unit="J/(mol.K)") = k*N_A
      "Molar gas constant";

    final constant Real sigma(final unit="W/(m2.K4)") = 2*pi^5*k^4/(15*h^3*c^2)
      "Stefan-Boltzmann constant ";

    final constant Real N_A(final unit="1/mol") = 6.02214076e23
      "Avogadro constant";

    final constant NonSI.Temperature_degC T_zero=-273.15
      "Absolute zero temperature";
    annotation (
      Documentation(info="<html>
<p>
This package provides often needed constants from mathematics, machine
dependent constants and constants from nature. The latter constants
(name, value, description) are from the following source (based on the second source):
</p>
<dl>
<dt>Michael Stock, Richard Davis, Estefan&iacute;a de Mirand&eacute;s and Martin J T Milton:</dt>
<dd><strong>The revision of the SI-the result of three decades of progress in metrology</strong> in Metrologia, Volume 56, Number 2.
<a href= \"https://iopscience.iop.org/article/10.1088/1681-7575/ab0013/pdf\">https://iopscience.iop.org/article/10.1088/1681-7575/ab0013/pdf</a>, 2019.
</dd>
</dl>
<dl>
<dt>D B Newell, F Cabiati, J Fischer, K Fujii, S G Karshenboim, H S Margolis , E de Mirand&eacute;s, P J Mohr, F Nez, K Pachucki, T J Quinn, B N Taylor, M Wang, B M Wood and Z Zhang:</dt>
<dd><strong>The CODATA 2017 values of h, e, k, and NA for the revision of the SI</strong> in Metrologia, Volume 55, Number 1.
<a href= \"https://iopscience.iop.org/article/10.1088/1681-7575/aa950a/pdf\">https://iopscience.iop.org/article/10.1088/1681-7575/aa950a/pdf</a>, 2017.
</dd>
</dl>
<p>BIPM is Bureau International des Poids et Mesures (they publish the SI-standard).</p>
<p>CODATA is the Committee on Data for Science and Technology.</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 We&szlig;ling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
</dl>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>Dec 4, 2019</em>
       by Thomas Beutlich:<br>
       Constant G updated according to 2018 CODATA value.</li>
<li><em>Mar 25, 2019</em>
       by Hans Olsson:<br>
       Constants updated according to 2017 CODATA values and new SI-standard.</li>
<li><em>Nov 4, 2015</em>
       by Thomas Beutlich:<br>
       Constants updated according to 2014 CODATA values.</li>
<li><em>Nov 8, 2004</em>
       by Christian Schweiger:<br>
       Constants updated according to 2002 CODATA values.</li>
<li><em>Dec 9, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants updated according to 1998 CODATA values. Using names, values
       and description text from this source. Included magnetic and
       electric constant.</li>
<li><em>Sep 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants eps, inf, small introduced.</li>
<li><em>Nov 15, 1997</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>
</html>"),
      Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Polygon(
          origin={-9.2597,25.6673},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={-19.9923,-8.3993},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={23.753,-11.5422},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
          smooth=Smooth.Bezier)}));
  end Constants;

  package Icons "Library of icons"
    extends Icons.Package;

    partial package ExamplesPackage
    "Icon for packages containing runnable examples"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(
              origin={8.0,14.0},
              lineColor={78,138,73},
              fillColor={78,138,73},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}), Documentation(info="<html>
<p>This icon indicates a package that contains executable examples.</p>
</html>"));
    end ExamplesPackage;

    partial model Example "Icon for runnable examples"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(lineColor = {75,138,73},
                    fillColor={255,255,255},
                    fillPattern = FillPattern.Solid,
                    extent = {{-100,-100},{100,100}}),
            Polygon(lineColor = {0,0,255},
                    fillColor = {75,138,73},
                    pattern = LinePattern.None,
                    fillPattern = FillPattern.Solid,
                    points = {{-36,60},{64,0},{-36,-60},{-36,60}})}), Documentation(info="<html>
<p>This icon indicates an example. The play button suggests that the example can be executed.</p>
</html>"));
    end Example;

    partial package Package "Icon for standard packages"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0)}), Documentation(info="<html>
<p>Standard package icon.</p>
</html>"));
    end Package;

    partial package BasesPackage "Icon for packages containing base classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              extent={{-30.0,-30.0},{30.0,30.0}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains base models and classes, respectively.</p>
</html>"));
    end BasesPackage;

    partial package VariantsPackage "Icon for package containing variants"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                {100,100}}), graphics={
            Ellipse(
              origin={10.0,10.0},
              fillColor={76,76,76},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-80.0,-80.0},{-20.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,-80.0},{60.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,0.0},{60.0,60.0}}),
            Ellipse(
              origin={10.0,10.0},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-80.0,0.0},{-20.0,60.0}})}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains several variants of one component.</p>
</html>"));
    end VariantsPackage;

    partial package InterfacesPackage "Icon for packages containing interfaces"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={20.0,0.0},
              lineColor={64,64,64},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-10.0,70.0},{10.0,70.0},{40.0,20.0},{80.0,20.0},{80.0,-20.0},{40.0,-20.0},{10.0,-70.0},{-10.0,-70.0}}),
            Polygon(fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-100.0,20.0},{-60.0,20.0},{-30.0,70.0},{-10.0,70.0},{-10.0,-70.0},{-30.0,-70.0},{-60.0,-20.0},{-100.0,-20.0}})}),
                                Documentation(info="<html>
<p>This icon indicates packages containing interfaces.</p>
</html>"));
    end InterfacesPackage;

    partial package SourcesPackage "Icon for packages containing sources"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={23.3333,0.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
            Rectangle(
              fillColor = {128,128,128},
              pattern = LinePattern.None,
              fillPattern = FillPattern.Solid,
              extent = {{-70,-4.5},{0,4.5}})}),
                                Documentation(info="<html>
<p>This icon indicates a package which contains sources.</p>
</html>"));
    end SourcesPackage;

    partial package SensorsPackage "Icon for packages containing sensors"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(origin={0.0,-30.0},
              fillColor={255,255,255},
              extent={{-90.0,-90.0},{90.0,90.0}},
              startAngle=20.0,
              endAngle=160.0),
            Ellipse(origin={0.0,-30.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-20.0,-20.0},{20.0,20.0}}),
            Line(origin={0.0,-30.0},
              points={{0.0,60.0},{0.0,90.0}}),
            Ellipse(origin={-0.0,-30.0},
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-10.0,-10.0},{10.0,10.0}}),
            Polygon(
              origin={-0.0,-30.0},
              rotation=-35.0,
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-7.0,0.0},{-3.0,85.0},{0.0,90.0},{3.0,85.0},{7.0,0.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a package containing sensors.</p>
</html>"));
    end SensorsPackage;

    partial package UtilitiesPackage "Icon for utility packages"
      extends Modelica.Icons.Package;
       annotation (Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}),
      Documentation(info="<html>
<p>This icon indicates a package containing utility classes.</p>
</html>"));
    end UtilitiesPackage;

    partial package TypesPackage
    "Icon for packages containing type definitions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-12.167,-23},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},
                  {14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,
                  -30},{4.167,20},{12.167,65}},
              smooth=Smooth.Bezier), Polygon(
              origin={2.7403,1.6673},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,
                10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,
                4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
              smooth=Smooth.Bezier)}));
    end TypesPackage;

    partial package FunctionsPackage "Icon for packages containing functions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
              Text(
                textColor={128,128,128},
                extent={{-90,-90},{90,90}},
                textString="f")}));
    end FunctionsPackage;

    partial package IconsPackage "Icon for packages containing icons"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}));
    end IconsPackage;

    partial package InternalPackage
    "Icon for an internal package (indicating that the package should not be directly utilized by user)"
    annotation (
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
              100}}), graphics={
          Rectangle(
            lineColor={215,215,215},
            fillColor={255,255,255},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25),
          Rectangle(
            lineColor={215,215,215},
            extent={{-100,-100},{100,100}},
            radius=25),
          Ellipse(
            extent={{-80,80},{80,-80}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid),
          Ellipse(
            extent={{-55,55},{55,-55}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,14},{60,-14}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid,
            rotation=45)}),
      Documentation(info="<html>

<p>
This icon shall be used for a package that contains internal classes not to be
directly utilized by a user.
</p>
</html>"));
    end InternalPackage;

    partial package MaterialPropertiesPackage
    "Icon for package containing property classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              lineColor={102,102,102},
              fillColor={204,204,204},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Sphere,
              extent={{-60.0,-60.0},{60.0,60.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a package that contains properties</p>
</html>"));
    end MaterialPropertiesPackage;

    partial class MaterialProperty "Icon for property classes"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}), graphics={
            Ellipse(lineColor={102,102,102},
              fillColor={204,204,204},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Sphere,
              extent={{-100.0,-100.0},{100.0,100.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a property class.</p>
</html>"));
    end MaterialProperty;

    partial class RoundSensor "Icon representing a round measurement device"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              fillColor={245,245,245},
              fillPattern=FillPattern.Solid,
              extent={{-70.0,-70.0},{70.0,70.0}}),
            Line(points={{0.0,70.0},{0.0,40.0}}),
            Line(points={{22.9,32.8},{40.2,57.3}}),
            Line(points={{-22.9,32.8},{-40.2,57.3}}),
            Line(points={{37.6,13.7},{65.8,23.9}}),
            Line(points={{-37.6,13.7},{-65.8,23.9}}),
            Ellipse(
              lineColor={64,64,64},
              fillColor={255,255,255},
              extent={{-12.0,-12.0},{12.0,12.0}}),
            Polygon(
              rotation=-17.5,
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-5.0,0.0},{-2.0,60.0},{0.0,65.0},{2.0,60.0},{5.0,0.0}}),
            Ellipse(
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-7.0,-7.0},{7.0,7.0}})}),
        Documentation(info="<html>
<p>
This icon is designed for a <strong>rotational sensor</strong> model.
</p>
</html>"));
    end RoundSensor;

    partial class RectangularSensor
      "Icon representing a linear measurement device"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              fillColor={245,245,245},
              fillPattern=FillPattern.Solid,
              extent={{-70.0,-60.0},{70.0,20.0}}),
            Polygon(
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-40,-40},{-50,-16},{-30,-16},{-40,-40}}),
            Line(points={{-40,0},{-40,-16}}),
            Line(points={{-70,0},{-40,0}}),
            Line(points={{-50.0,-40.0},{-50.0,-60.0}}),
            Line(points={{-30.0,-40.0},{-30.0,-60.0}}),
            Line(points={{-10.0,-40.0},{-10.0,-60.0}}),
            Line(points={{10.0,-40.0},{10.0,-60.0}}),
            Line(points={{30.0,-40.0},{30.0,-60.0}}),
            Line(points={{50.0,-40.0},{50.0,-60.0}})}),
        Documentation(info="<html>
<p>
This icon is designed for a <strong>translational sensor</strong> model.
</p></html>"));
    end RectangularSensor;

    partial function Function "Icon for functions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Text(
              textColor={0,0,255},
              extent={{-150,105},{150,145}},
              textString="%name"),
            Ellipse(
              lineColor = {108,88,49},
              fillColor = {255,215,136},
              fillPattern = FillPattern.Solid,
              extent = {{-100,-100},{100,100}}),
            Text(
              textColor={108,88,49},
              extent={{-90.0,-90.0},{90.0,90.0}},
              textString="f")}),
    Documentation(info="<html>
<p>This icon indicates Modelica functions.</p>
</html>"));
    end Function;

    partial record Record "Icon for records"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Text(
              textColor={0,0,255},
              extent={{-150,60},{150,100}},
              textString="%name"),
            Rectangle(
              origin={0.0,-25.0},
              lineColor={64,64,64},
              fillColor={255,215,136},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-75.0},{100.0,75.0}},
              radius=25.0),
            Line(
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-50.0},
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-25.0},
              points={{0.0,75.0},{0.0,-75.0}},
              color={64,64,64})}), Documentation(info="<html>
<p>
This icon is indicates a record.
</p>
</html>"));
    end Record;

    expandable connector SignalBus "Icon for signal bus"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}, initialScale=0.2), graphics={
              Rectangle(
                lineColor={255,204,51},
                lineThickness=0.5,
                extent={{-20.0,-2.0},{20.0,2.0}}),
              Polygon(
                fillColor={255,215,136},
                fillPattern=FillPattern.Solid,
                points={{-80.0,50.0},{80.0,50.0},{100.0,30.0},{80.0,-40.0},{60.0,-50.0},{-60.0,-50.0},{-80.0,-40.0},{-100.0,30.0}},
                smooth=Smooth.Bezier),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-65.0,15.0},{-55.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-5.0,15.0},{5.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{55.0,15.0},{65.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-35.0,-25.0},{-25.0,-15.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{25.0,-25.0},{35.0,-15.0}})}),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            initialScale=0.2), graphics={
            Polygon(
              points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,-20},{-50,15}},
              fillColor={255,204,51},
              fillPattern=FillPattern.Solid,
              smooth=Smooth.Bezier),
            Ellipse(
              extent={{-32.5,7.5},{-27.5,12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-2.5,12.5},{2.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{27.5,12.5},{32.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-17.5,-7.5},{-12.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{12.5,-7.5},{17.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,70},{150,40}},
              textString="%name")}),
        Documentation(info="<html>
This icon is designed for a <strong>signal bus</strong> connector.
</html>"));
    end SignalBus;

    partial class ObsoleteModel
      "Icon for classes that are obsolete and will be removed in later versions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-102,102},{102,-102}},
              lineColor={255,0,0},
              pattern=LinePattern.Dash,
              lineThickness=0.5)}), Documentation(info="<html>
<p>
This partial class is intended to provide a <u>default icon
for an obsolete model</u> that will be removed from the
corresponding library in a future release.
</p>
</html>"));
    end ObsoleteModel;
    annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}), Documentation(info="<html>
<p>This package contains definitions for the graphical layout of components which may be used in different libraries. The icons can be utilized by inheriting them in the desired class using &quot;extends&quot; or by directly copying the &quot;icon&quot; layer.</p>

<h4>Main Authors</h4>

<dl>
<dt><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a></dt>
    <dd>Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)</dd>
    <dd>Oberpfaffenhofen</dd>
    <dd>Postfach 1116</dd>
    <dd>D-82230 Wessling</dd>
    <dd>email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
<dt>Christian Kral</dt>

    <dd>  <a href=\"https://christiankral.net/\">Electric Machines, Drives and Systems</a><br>
</dd>
    <dd>1060 Vienna, Austria</dd>
    <dd>email: <a href=\"mailto:dr.christian.kral@gmail.com\">dr.christian.kral@gmail.com</a></dd>
<dt>Johan Andreasson</dt>
    <dd><a href=\"https://www.modelon.com/\">Modelon AB</a></dd>
    <dd>Ideon Science Park</dd>
    <dd>22370 Lund, Sweden</dd>
    <dd>email: <a href=\"mailto:johan.andreasson@modelon.se\">johan.andreasson@modelon.se</a></dd>
</dl>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>"));
  end Icons;

  package Units "Library of type and unit definitions"
    extends Modelica.Icons.Package;

    package SI "Library of SI unit definitions"
      extends Modelica.Icons.Package;

      type Angle = Real (
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg");

      type Length = Real (final quantity="Length", final unit="m");

      type Height = Length(min=0);

      type Area = Real (final quantity="Area", final unit="m2");

      type Volume = Real (final quantity="Volume", final unit="m3");

      type Time = Real (final quantity="Time", final unit="s");

      type Velocity = Real (final quantity="Velocity", final unit="m/s");

      type Frequency = Real (final quantity="Frequency", final unit="Hz");

      type Mass = Real (
          quantity="Mass",
          final unit="kg",
          min=0);

      type Density = Real (
          final quantity="Density",
          final unit="kg/m3",
          displayUnit="g/cm3",
          min=0.0);

      type Pressure = Real (
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="bar");

      type AbsolutePressure = Pressure (min=0.0, nominal = 1e5);

      type PressureDifference = Pressure;

      type DynamicViscosity = Real (
          final quantity="DynamicViscosity",
          final unit="Pa.s",
          min=0);

      type Energy = Real (final quantity="Energy", final unit="J");

      type Power = Real (final quantity="Power", final unit="W");

      type EnthalpyFlowRate = Real (final quantity="EnthalpyFlowRate", final unit=
              "W");

      type Efficiency = Real (
          final quantity="Efficiency",
          final unit="1",
          min=0);

      type MassFlowRate = Real (quantity="MassFlowRate", final unit="kg/s");

      type VolumeFlowRate = Real (final quantity="VolumeFlowRate", final unit=
              "m3/s");

      type ThermodynamicTemperature = Real (
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min = 0.0,
          start = 288.15,
          nominal = 300,
          displayUnit="degC")
        "Absolute temperature (use type TemperatureDifference for relative temperatures)" annotation(absoluteValue=true);

      type Temperature = ThermodynamicTemperature;

      type TemperatureDifference = Real (
          final quantity="ThermodynamicTemperature",
          final unit="K") annotation(absoluteValue=false);

      type TemperatureSlope = Real (final quantity="TemperatureSlope",
          final unit="K/s");

      type LinearTemperatureCoefficient = Real(final quantity = "LinearTemperatureCoefficient", final unit="1/K");

      type Compressibility = Real (final quantity="Compressibility", final unit=
              "1/Pa");

      type IsothermalCompressibility = Compressibility;

      type HeatFlowRate = Real (final quantity="Power", final unit="W");

      type HeatFlux = Real (final quantity="HeatFlux", final unit="W/m2");

      type ThermalConductivity = Real (final quantity="ThermalConductivity", final unit=
                 "W/(m.K)");

      type ThermalConductance = Real (final quantity="ThermalConductance", final unit=
                 "W/K");

      type HeatCapacity = Real (final quantity="HeatCapacity", final unit="J/K");

      type SpecificHeatCapacity = Real (final quantity="SpecificHeatCapacity",
            final unit="J/(kg.K)");

      type RatioOfSpecificHeatCapacities = Real (final quantity=
              "RatioOfSpecificHeatCapacities", final unit="1");

      type SpecificEntropy = Real (final quantity="SpecificEntropy",
                                   final unit="J/(kg.K)");

      type SpecificEnergy = Real (final quantity="SpecificEnergy",
                                  final unit="J/kg");

      type SpecificInternalEnergy = SpecificEnergy;

      type SpecificEnthalpy = SpecificEnergy;

      type DerDensityByEnthalpy = Real (final unit="kg.s2/m5");

      type DerDensityByPressure = Real (final unit="s2/m2");

      type DerDensityByTemperature = Real (final unit="kg/(m3.K)");

      type Emissivity = Real (final quantity="Emissivity", final unit="1");

      type MolarMass = Real (final quantity="MolarMass", final unit="kg/mol", min=0);

      type MolarVolume = Real (final quantity="MolarVolume", final unit="m3/mol", min=0);

      type MassFraction = Real (final quantity="MassFraction", final unit="1",
                                min=0, max=1);

      type MoleFraction = Real (final quantity="MoleFraction", final unit="1",
                                min = 0, max = 1);

      type PrandtlNumber = Real (final quantity="PrandtlNumber", final unit="1");
      annotation (Icon(graphics={Text(
              extent={{-80,80},{80,-78}},
              textColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.None,
              fontName="serif",
              textString="SI",
              textStyle={TextStyle.Italic})}),
                                       Documentation(info="<html>
<p>This package provides predefined types based on the international standard
on units.
</p>
<p>
For an introduction to the conventions used in this package, have a look at:
<a href=\"modelica://Modelica.Units.UsersGuide.Conventions\">Conventions</a>.
</p>
</html>"));
    end SI;

    package NonSI "Type definitions of non SI and other units"
      extends Modelica.Icons.Package;

      type Temperature_degC = Real (final quantity="ThermodynamicTemperature",
            final unit="degC")
        "Absolute temperature in degree Celsius (for relative temperature use Modelica.Units.SI.TemperatureDifference)" annotation(absoluteValue=true);

      type Angle_deg = Real (final quantity="Angle", final unit="deg")
        "Angle in degree";

      type Pressure_bar = Real (final quantity="Pressure", final unit="bar")
        "Absolute pressure in bar";
      annotation (Documentation(info="<html>
<p>
This package provides predefined types, such as <strong>Angle_deg</strong> (angle in
degree), <strong>AngularVelocity_rpm</strong> (angular velocity in revolutions per
minute) or <strong>Temperature_degF</strong> (temperature in degree Fahrenheit),
which are in common use but are not part of the international standard on
units according to ISO 31-1992 \"General principles concerning quantities,
units and symbols\" and ISO 1000-1992 \"SI units and recommendations for
the use of their multiples and of certain other units\".</p>
<p>If possible, the types in this package should not be used. Use instead
types of package <code>Modelica.Units.SI</code>. For more information on units, see also
the book of Francois Cardarelli <strong>Scientific Unit Conversion - A
Practical Guide to Metrication</strong> (Springer 1997).</p>
</html>"), Icon(coordinateSystem(extent={{-100,-100},{100,100}}), graphics={Ellipse(
              extent={{-10,10},{10,-10}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid), Ellipse(
              extent={{-60,10},{-40,-10}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid), Ellipse(
              extent={{40,10},{60,-10}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid)}));
    end NonSI;

    package Conversions
    "Conversion functions to/from non SI units and type definitions of non SI units"
      extends Modelica.Icons.Package;

      function to_degC "Convert from kelvin to degree Celsius"
        extends Modelica.Units.Icons.Conversion;
        input SI.Temperature Kelvin "Value in kelvin";
        output Modelica.Units.NonSI.Temperature_degC Celsius "Value in degree Celsius";
      algorithm
        Celsius := Kelvin + Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                textString="K"), Text(
                extent={{100,-20},{20,-100}},
                textString="degC")}));
      end to_degC;

      function from_degC "Convert from degree Celsius to kelvin"
        extends Modelica.Units.Icons.Conversion;
        input Modelica.Units.NonSI.Temperature_degC Celsius "Value in degree Celsius";
        output SI.Temperature Kelvin "Value in kelvin";
      algorithm
        Kelvin := Celsius - Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                textString="degC"), Text(
                extent={{100,-20},{20,-100}},
                textString="K")}));
      end from_degC;

      function from_deg "Convert from degree to radian"
        extends Modelica.Units.Icons.Conversion;
        input Modelica.Units.NonSI.Angle_deg degree "Value in degree";
        output SI.Angle radian "Value in radian";
      algorithm
        radian := (Modelica.Constants.pi/180.0)*degree;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{4,100},{-102,46}},
                textString="deg"), Text(
                extent={{100,-32},{-18,-100}},
                textString="rad")}));
      end from_deg;

      function to_bar "Convert from Pascal to bar"
        extends Modelica.Units.Icons.Conversion;
        input SI.Pressure Pa "Value in Pascal";
        output Modelica.Units.NonSI.Pressure_bar bar "Value in bar";
      algorithm
        bar := Pa/1e5;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-12,100},{-100,56}},
                textString="Pa"), Text(
                extent={{98,-52},{-4,-100}},
                textString="bar")}));
      end to_bar;
      annotation (Documentation(info="<html>
<p>This package provides conversion functions from the non SI Units
defined in package <code>Modelica.Units.NonSI</code> to the
corresponding SI Units defined in package <code>Modelica.Units.SI</code> and vice
versa. It is recommended to use these functions in the following
way (note, that all functions have one Real input and one Real output
argument):</p>
<blockquote><pre>
<strong>import</strong> Modelica.Units.SI;
<strong>import</strong> Modelica.Units.Conversions.{from_degC, from_deg, from_rpm};
   ...
<strong>parameter</strong> SI.Temperature     T   = from_degC(25);   // convert 25 degree Celsius to kelvin
<strong>parameter</strong> SI.Angle           phi = from_deg(180);   // convert 180 degree to radian
<strong>parameter</strong> SI.AngularVelocity w   = from_rpm(3600);  // convert 3600 revolutions per minutes
                                                   // to radian per seconds
</pre></blockquote>

</html>"),     Icon(graphics={
            Polygon(
              points={{80,0},{20,20},{20,-20},{80,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,0},{20,0}}, color={191,0,0})}));
    end Conversions;

    package Icons "Icons for Units"
      extends Modelica.Icons.IconsPackage;

      partial function Conversion "Base icon for conversion functions"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={191,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0}),
              Polygon(
                points={{90,0},{30,20},{30,-20},{90,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-115,155},{115,105}},
                textString="%name",
                textColor={0,0,255})}));
      end Conversion;
    end Icons;
    annotation (Icon(graphics={
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-80,-40},{-80,-40},{-55,50},{-52.5,62.5},{-65,60},{-65,65},{-35,77.5},{-32.5,60},{-50,0},{-50,0},{-30,15},{-20,27.5},{-32.5,27.5},{-32.5,27.5},{-32.5,32.5},{-32.5,32.5},{2.5,32.5},{2.5,32.5},{2.5,27.5},{2.5,27.5},{-7.5,27.5},{-30,7.5},{-30,7.5},{-25,-25},{-17.5,-28.75},{-10,-25},{-5,-26.25},{-5,-32.5},{-16.25,-41.25},{-31.25,-43.75},{-40,-33.75},{-45,-5},{-45,-5},{-52.5,-10},{-52.5,-10},{-60,-40},{-60,-40}},
          smooth = Smooth.Bezier),
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{87.5,30},{62.5,30},{62.5,30},{55,33.75},{36.25,35},{16.25,25},{7.5,6.25},{11.25,-7.5},{22.5,-12.5},{22.5,-12.5},{6.25,-22.5},{6.25,-35},{16.25,-38.75},{16.25,-38.75},{21.25,-41.25},{21.25,-41.25},{45,-48.75},{47.5,-61.25},{32.5,-70},{12.5,-65},{7.5,-51.25},{21.25,-41.25},{21.25,-41.25},{16.25,-38.75},{16.25,-38.75},{6.25,-41.25},{-6.25,-50},{-3.75,-68.75},{30,-76.25},{65,-62.5},{63.75,-35},{27.5,-26.25},{22.5,-20},{27.5,-15},{27.5,-15},{30,-7.5},{30,-7.5},{27.5,-2.5},{28.75,11.25},{36.25,27.5},{47.5,30},{53.75,22.5},{51.25,8.75},{45,-6.25},{35,-11.25},{30,-7.5},{30,-7.5},{27.5,-15},{27.5,-15},{43.75,-16.25},{65,-6.25},{72.5,10},{70,20},{70,20},{80,20}},
          smooth = Smooth.Bezier)}), Documentation(info="<html>
<p>This package provides predefined types, such as <em>Mass</em>,
<em>Angle</em>, <em>Time</em>, based on the international standard
on units, e.g.,
</p>

<blockquote><pre>
<strong>type</strong> Angle = Real(<strong>final</strong> quantity = \"Angle\",
                  <strong>final</strong> unit     = \"rad\",
                  displayUnit   = \"deg\");
</pre></blockquote>

<p>
Some of the types are derived SI units that are utilized in package Modelica
(such as ComplexCurrent, which is a complex number where both the real and imaginary
part have the SI unit Ampere).
</p>

<p>
Furthermore, conversion functions from non SI-units to SI-units and vice versa
are provided in subpackage
<a href=\"modelica://Modelica.Units.Conversions\">Conversions</a>.
</p>

<p>
For an introduction how units are used in the Modelica Standard Library
with package Units, have a look at:
<a href=\"modelica://Modelica.Units.UsersGuide.HowToUseUnits\">How to use Units</a>.
</p>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br>Added molar units for energy and enthalpy.</li>
<li><em>Jan. 27, 2010</em> by Christian Kral:<br>Added complex units.</li>
<li><em>Dec. 14, 2005</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Add User&#39;s Guide and removed &quot;min&quot; values for Resistance and Conductance.</li>
<li><em>October 21, 2002</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Christian Schweiger:<br>Added new package <strong>Conversions</strong>. Corrected typo <em>Wavelenght</em>.</li>
<li><em>June 6, 2000</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Introduced the following new types<br>type Temperature = ThermodynamicTemperature;<br>types DerDensityByEnthalpy, DerDensityByPressure, DerDensityByTemperature, DerEnthalpyByPressure, DerEnergyByDensity, DerEnergyByPressure<br>Attribute &quot;final&quot; removed from min and max values in order that these values can still be changed to narrow the allowed range of values.<br>Quantity=&quot;Stress&quot; removed from type &quot;Stress&quot;, in order that a type &quot;Stress&quot; can be connected to a type &quot;Pressure&quot;.</li>
<li><em>Oct. 27, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>New types due to electrical library: Transconductance, InversePotential, Damping.</li>
<li><em>Sept. 18, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Renamed from SIunit to SIunits. Subpackages expanded, i.e., the SIunits package, does no longer contain subpackages.</li>
<li><em>Aug 12, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Type &quot;Pressure&quot; renamed to &quot;AbsolutePressure&quot; and introduced a new type &quot;Pressure&quot; which does not contain a minimum of zero in order to allow convenient handling of relative pressure. Redefined BulkModulus as an alias to AbsolutePressure instead of Stress, since needed in hydraulics.</li>
<li><em>June 29, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Bug-fix: Double definition of &quot;Compressibility&quot; removed and appropriate &quot;extends Heat&quot; clause introduced in package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
<li><em>April 8, 1998</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Astrid Jaschinski:<br>Complete ISO 31 chapters realized.</li>
<li><em>Nov. 15, 1997</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Hubertus Tummescheit:<br>Some chapters realized.</li>
</ul>
</html>"));
  end Units;
annotation (
preferredView="info",
version="4.0.0",
versionDate="2020-06-04",
dateModified = "2020-06-04 11:00:00Z",
revisionId="6626538a2 2020-06-04 19:56:34 +0200",
uses(Complex(version="4.0.0"), ModelicaServices(version="4.0.0")),
conversion(
 from(version={"3.0", "3.0.1", "3.1", "3.2", "3.2.1", "3.2.2", "3.2.3"}, script="modelica://Modelica/Resources/Scripts/Conversion/ConvertModelica_from_3.2.3_to_4.0.0.mos")),
Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
  Polygon(
    origin={-6.9888,20.048},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    points={{-93.0112,10.3188},{-93.0112,10.3188},{-73.011,24.6},{-63.011,31.221},{-51.219,36.777},{-39.842,38.629},{-31.376,36.248},{-25.819,29.369},{-24.232,22.49},{-23.703,17.463},{-15.501,25.135},{-6.24,32.015},{3.02,36.777},{15.191,39.423},{27.097,37.306},{32.653,29.633},{35.035,20.108},{43.501,28.046},{54.085,35.19},{65.991,39.952},{77.897,39.688},{87.422,33.338},{91.126,21.696},{90.068,9.525},{86.099,-1.058},{79.749,-10.054},{71.283,-21.431},{62.816,-33.337},{60.964,-32.808},{70.489,-16.14},{77.368,-2.381},{81.072,10.054},{79.749,19.05},{72.605,24.342},{61.758,23.019},{49.587,14.817},{39.003,4.763},{29.214,-6.085},{21.012,-16.669},{13.339,-26.458},{5.401,-36.777},{-1.213,-46.037},{-6.24,-53.446},{-8.092,-52.387},{-0.684,-40.746},{5.401,-30.692},{12.81,-17.198},{19.424,-3.969},{23.658,7.938},{22.335,18.785},{16.514,23.283},{8.047,23.019},{-1.478,19.05},{-11.267,11.113},{-19.734,2.381},{-29.259,-8.202},{-38.519,-19.579},{-48.044,-31.221},{-56.511,-43.392},{-64.449,-55.298},{-72.386,-66.939},{-77.678,-74.612},{-79.53,-74.083},{-71.857,-61.383},{-62.861,-46.037},{-52.278,-28.046},{-44.869,-15.346},{-38.784,-2.117},{-35.344,8.731},{-36.403,19.844},{-42.488,23.813},{-52.013,22.49},{-60.744,16.933},{-68.947,10.054},{-76.884,2.646},{-93.0112,-12.1707},{-93.0112,-12.1707}},
    smooth=Smooth.Bezier),
  Ellipse(
    origin={40.8208,-37.7602},
    fillColor={161,0,4},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    extent={{-17.8562,-17.8563},{17.8563,17.8562}})}),
Documentation(info="<html>
<p>
<img src=\"modelica://Modelica/Resources/Images/Logos/Modelica_Libraries.svg\" width=\"250\">
</p>

<p>
The package <strong>Modelica&reg;</strong> is a <strong>standardized</strong> and <strong>free</strong> package
that is developed by the \"<strong>Modelica Association Project - Libraries</strong>\".</p>
<p>
Its development is coordinated with the Modelica&reg; language from the
Modelica Association, see <a href=\"https://www.Modelica.org\">https://www.Modelica.org</a>.
It is also called <strong>Modelica Standard Library</strong>.
It provides model components in many domains that are based on
standardized interface definitions. Some typical examples are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/UsersGuide/ModelicaLibraries.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.UsersGuide.Overview\">Overview</a>
  provides an overview of the Modelica Standard Library
  inside the <a href=\"modelica://Modelica.UsersGuide\">User's Guide</a>.</li>
<li><a href=\"modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
 summarizes the changes of new versions of this package.</li>
<li> <a href=\"modelica://Modelica.UsersGuide.Contact\">Contact</a>
  lists the contributors of the Modelica Standard Library.</li>
<li> The <strong>Examples</strong> packages in the various libraries, demonstrate
  how to use the components of the corresponding sublibrary.</li>
</ul>

<p>
This version of the Modelica Standard Library consists of
</p>
<ul>
<li><strong>1417</strong> component models and blocks,</li>
<li><strong>512</strong> example models, and</li>
<li><strong>1219</strong> functions</li>
</ul>
<p>
that are directly usable (= number of public, non-partial, non-internal and non-obsolete classes). It is fully compliant
to <a href=\"https://modelica.org/documents/ModelicaSpec34.pdf\">Modelica Specification version 3.4</a>
and it has been tested with Modelica tools from different vendors.
</p>

<p>
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 1998-2020, Modelica Association and <a href=\"modelica://Modelica.UsersGuide.Contact\">contributors</a>.
</p>

<p>
<em>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the 3-Clause BSD license. For license conditions (including the disclaimer of warranty) visit <a href=\"https://modelica.org/licenses/modelica-3-clause-bsd\">https://modelica.org/licenses/modelica-3-clause-bsd</a>.</em>
</p>

<p>
<strong>Modelica&reg;</strong> is a registered trademark of the Modelica Association.
</p>
</html>"));
end Modelica;

package ChillerPlant "Models for the case study"

  package ClosedLoopBase "Closed loop models utilizing the base controller"

    model OneDeviceWithWSE
      "Simple chiller plant with a water-side economizer and one of each: chiller, cooling tower cell, condenser, and chiller water pump."
      extends ChillerPlant.BaseClasses.DataCenter(
        mCW_flow_nominal = 2*roo.QRoo_flow/(4200*6),
        chi(
          allowFlowReversal1=false,
          m1_flow_nominal=mCW_flow_nominal/2,
          m2_flow_nominal=mCHW_flow_nominal,
          dp1_nominal=42000 + 1444/2,
          dp2_nominal=19000,
          per=Buildings.Fluid.Chillers.Data.ElectricEIR.ElectricEIRChiller_York_YT_563kW_10_61COP_Vanes()),
        pumCHW(m_flow_nominal=mCHW_flow_nominal, dp_nominal=1000 + 12000 + 15000 +
              3500 + 24000),
        cooCoi(m1_flow_nominal=mCHW_flow_nominal),
        val1(m_flow_nominal=mCHW_flow_nominal,
          dpValve_nominal=200,
          dpFixed_nominal=800),
        TCHWEntChi(m_flow_nominal=mCHW_flow_nominal),
        valByp(m_flow_nominal=mCHW_flow_nominal,
          dpValve_nominal=200,
          use_inputFilter=false,
          dpFixed_nominal=3300),
        val6(m_flow_nominal=mCHW_flow_nominal,
          dpValve_nominal=200,
          dpFixed_nominal=3300),
        cooTow(m_flow_nominal=1.1*mCW_flow_nominal, dp_nominal=15000 + 2887 - 400),
        expVesCHW(p=100000),
        val3(dpValve_nominal=200, dpFixed_nominal=800),
        roo(QRoo_flow=500000,
            nPorts=2),
        mFanFlo(k=mAir_flow_nominal),
        wse(dp1_nominal=42000 + 1444/2),
        weaData(filNam=
              "D:/3Dexperience/Buildings11.0/Buildings-v11.0.0/Buildings 11.0.0/Resources/weatherdata/CHN_Guangdong.Shenzhen.594930_SWERA.mos"));
      extends ChillerPlant.BaseClasses.EnergyMonitoring;
      extends Modelica.Icons.Example;

      Modelica.Units.SI.Power PWSEWatPum;

      Modelica.Units.SI.Power PCooTowWatPum;

      parameter Real dTChi(
        final unit="K",
        final quantity="TemperatureDifference",
        displayUnit="degC")=2.2
        "Deadband to avoid chiller short-cycling"
        annotation(Dialog(group="Design parameters"));

      BaseClasses.Controls.WaterSideEconomizerOnOff waterSideEconomizerOnOff(
          cooTowAppDes=cooTowAppDes) "Water-side economizer enable/disable"
        annotation (Placement(transformation(extent={{-160,80},{-120,120}})));
      BaseClasses.Controls.ChillerOnOff chillerOnOff(
        dTChi = dTChi)
        annotation (Placement(transformation(extent={{-160,0},{-120,40}})));
      BaseClasses.Controls.ChilledWaterReset chilledWaterReset(linPieTwo(y10=0.1))
        "Chilled water reset controller"
        annotation (Placement(transformation(extent={{-160,-60},{-120,-20}})));
      BaseClasses.Controls.PlantOnOffWithAnalogueTrimAndRespond plantOnOff(
          TZonSupSet=TZonSupSet, triAndRes1(conPID(
            k=0.1,
            Ti=120,
            strict=true)))       "Plant enable/disable status"
        annotation (Placement(transformation(extent={{-220,-140},{-180,-100}})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TCWLeaTow(redeclare package
        Medium =
            MediumW, m_flow_nominal=mCW_flow_nominal)
        "Temperature of condenser water leaving the cooling tower"      annotation (
         Placement(transformation(
            extent={{10,-10},{-10,10}},
            origin={300,227},
            rotation=90)));
      Buildings.Fluid.Movers.FlowControlled_m_flow pumCW(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCW_flow_nominal/2,
        dp(start=33000 + 1444),
        use_inputFilter=false,
        energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
        dpMax=60000)
        "Condenser water pump" annotation (Placement(transformation(
            extent={{-10,10},{10,-10}},
            rotation=90,
            origin={160,120})));
      Buildings.Fluid.Movers.FlowControlled_m_flow pumCWWSE(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCW_flow_nominal/2,
        dp(start=33000 + 1444 + 200),
        use_inputFilter=false,
        energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
        dpMax=60000)
        "Condenser water pump" annotation (Placement(transformation(
            extent={{10,10},{-10,-10}},
            rotation=-90,
            origin={40,142})));
      Buildings.Fluid.Actuators.Valves.ThreeWayLinear val(
        redeclare package Medium = Buildings.Media.Water,
        portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
        portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
        use_inputFilter=false,
        riseTime=30,
        m_flow_nominal=mCW_flow_nominal/2,
        dpValve_nominal=6000,
        fraK=0.7)
                "Chiller head pressure bypass valve"      annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={300,140})));
      BaseClasses.Controls.CondenserWater condenserWater(
        mCW_flow_nominal=mCW_flow_nominal,
        chiFloDivWseFlo=0.5,
        PLRMinUnl=chi.per.PLRMinUnl,
        heaPreCon(reverseActing=true)) "Condenser water controller"
        annotation (Placement(transformation(extent={{-80,200},{-40,240}})));
      Modelica.Blocks.Sources.RealExpression PWSEWatPum1(y=PWSEWatPum)
        "WSE water pump power consumption" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}}, origin={-510,20})));
      Modelica.Blocks.Continuous.Integrator PWSEWatPumAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0)
        "Condensed water pump power consumption meter for the WSE loop"
        annotation (Placement(transformation(extent={{-460,20},{-440,40}})));
      Buildings.Fluid.FixedResistances.Junction spl(
        redeclare package Medium = Buildings.Media.Water,
        from_dp=true,
        portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
        portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        m_flow_nominal={1.1*mCW_flow_nominal,-1*mCW_flow_nominal,-0.1*
            mCW_flow_nominal},
        dp_nominal=200*{1,-1,-1})                   "Splits flow"
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={300,200})));
      Buildings.Fluid.FixedResistances.Junction mix(
        redeclare package Medium = Buildings.Media.Water,
        portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
        portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
        m_flow_nominal={1.1*mCW_flow_nominal,-1*mCW_flow_nominal,0.1*
            mCW_flow_nominal},
        dp_nominal=200*{1,-1,1})                    "Joins two flows"
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=90,
            origin={100,200})));
      Buildings.Fluid.Movers.FlowControlled_m_flow pumCT(
        redeclare package Medium = Buildings.Media.Water,
        m_flow_nominal=1.1*mCW_flow_nominal,
        dp(start=15000 + 2887),
        use_inputFilter=false,
        energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial)
        "Cooling tower loop pump" annotation (Placement(transformation(
            extent={{-10,10},{10,-10}},
            rotation=0,
            origin={126,240})));
      Buildings.Fluid.Sources.Boundary_pT expVesWSE(redeclare package Medium =
            MediumW,
        p=100000,    nPorts=1) "Represents an expansion vessel"
        annotation (Placement(transformation(extent={{50,111},{70,131}})));
      Modelica.Blocks.Sources.RealExpression PCTWatPum(y=PCooTowWatPum)
        "Cooling tower water pump power consumption" annotation (Placement(
            transformation(extent={{-10,-10},{10,10}}, origin={-510,-20})));
      Modelica.Blocks.Continuous.Integrator PCooTowWatPumAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0) "Cooling tower pump power consumption meter for the WSE loop"
        annotation (Placement(transformation(extent={{-460,-20},{-440,0}})));
      Buildings.Fluid.Actuators.Valves.TwoWayLinear val4(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCW_flow_nominal,
        dpValve_nominal=200,
        dpFixed_nominal=1244,
        y_start=0,
        use_inputFilter=false)
        "Control valve for condenser water loop of economizer" annotation (
          Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={120,120})));
      Modelica.Blocks.Sources.RealExpression realExpression(y=chi.PLR2)
        annotation (Placement(transformation(extent={{-146,194},{-126,214}})));
      Modelica.Blocks.Math.Add add
        annotation (Placement(transformation(extent={{212,60},{224,72}})));
      Modelica.Blocks.Math.Add add1
        annotation (Placement(transformation(extent={{120,-14},{108,-2}})));
      Modelica.Blocks.Sources.Constant const1(k=0)
        annotation (Placement(transformation(extent={{150,-18},{140,-8}})));
      Modelica.Blocks.Math.Max max1
        annotation (Placement(transformation(extent={{334,130},{314,150}})));
      Modelica.Blocks.Math.Add add2
        annotation (Placement(transformation(extent={{264,218},{252,230}})));
      Modelica.Blocks.Sources.Constant const3(k=0)
        annotation (Placement(transformation(extent={{284,208},{274,218}})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TCWWseLea(redeclare package
        Medium =
            MediumW, m_flow_nominal=mCW_flow_nominal)
        "Temperature of condenser water leaving the cooling tower" annotation (
          Placement(transformation(
            extent={{-10,-10},{10,10}},
            origin={40,175},
            rotation=90)));
      Buildings.Fluid.Sensors.TemperatureTwoPort TCWChiLea(redeclare package
        Medium =
            MediumW, m_flow_nominal=mCW_flow_nominal)
        "Temperature of condenser water leaving the cooling tower" annotation (
          Placement(transformation(
            extent={{-10,-10},{10,10}},
            origin={140,157},
            rotation=90)));
      Buildings.Fluid.Sensors.TemperatureTwoPort TCWEnt(redeclare package
        Medium =
            MediumW, m_flow_nominal=mCW_flow_nominal)
        "Temperature of condenser water leaving the cooling tower" annotation (
          Placement(transformation(
            extent={{10,-10},{-10,10}},
            origin={166,235},
            rotation=180)));
      Buildings.Fluid.Sensors.TemperatureTwoPort TCHWOut(redeclare package
        Medium =
            MediumW, m_flow_nominal=mCHW_flow_nominal)
        "Temperature of chilled water entering chiller" annotation (Placement(
            transformation(
            extent={{-10,10},{10,-10}},
            rotation=270,
            origin={302,-64})));
    Buildings.Utilities.IO.SignalExchange.Overwrite oveChiTset(final u,
        description="The set temperature of the chiller")
      "Overwirte the set temperature of the chiller"
      annotation (Placement(transformation(extent={{134,46},{154,66}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite oveVal6(final u,
        description="on / off of the value 6 in the chiller output pipe")
      "Overwirte on/off of the value 6"
      annotation (Placement(transformation(extent={{254,30},{274,50}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite oveValByp(final u,
        description="on / off of the Value bypass of the chiller")
      "Overwirte on/off of the value bypass"
      annotation (Placement(transformation(extent={{192,28},{212,48}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite oveVal1(final u,
        description="on/off of the value 1 ( the bypass value of WSE) ")
      "Overwirte on/off of the value 1"
      annotation (Placement(transformation(extent={{114,-50},{134,-30}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite oveVal3(final u,
        description="on/off of the value 3 ( the input pipe of wse ) ")
      "Overwirte on/off of the value3"
      annotation (Placement(transformation(extent={{22,-28},{42,-8}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite ovepumCHW(final u,
        description="the inset dp of the pump in the chiller water ")
      "Overwirte the dp of the pumCHW"
      annotation (Placement(transformation(extent={{102,-130},{122,-110}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite ovemFanFlo(final u,
        description="the mass flow rate of fan ")
      "Overwirte the mass flow rate of fan"
      annotation (Placement(transformation(extent={{264,-210},{284,-190}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite ovepumCWWSE(final u,
        description="mass flow of the wse condenser water pump ")
      "Overwirte condenser water pump of wse"
      annotation (Placement(transformation(extent={{-2,132},{18,152}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite ovepumCW(final u,
        description="mass flow of the chiller condenser water pump ")
      "Overwirte  condenser water pump of chiller" annotation (Placement(
          transformation(
          extent={{-10,10},{10,-10}},
          rotation=180,
          origin={196,120})));
    Buildings.Utilities.IO.SignalExchange.Overwrite ovepumCT(final u,
        description="mass flow of the cooling tower loop pump ")
      "Overwirte cooling tower loop pump"
      annotation (Placement(transformation(extent={{44,232},{64,252}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite oveVal4(final u,
        description="on / off of the Value4 in the wse condenser pipe")
      "Overwirte on/off of the value 4"
      annotation (Placement(transformation(extent={{102,72},{122,92}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite oveval(final u, description
        ="on/off of the chiller head pressure bypass valve ")
      "Overwirte chiller head pressure bypass valve"
      annotation (Placement(transformation(extent={{318,168},{338,188}})));
    parameter Modelica.Blocks.Interfaces.RealInput u
      "Connector of Real input signal";
    Buildings.Utilities.IO.SignalExchange.Read readTAirSup(
      y,
      description="Supply air temperature to data center",
      KPIs=Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.AirZoneTemperature)
      "read Supply air temperature to data center"
      annotation (Placement(transformation(extent={{200,-224},{180,-204}})));
    Buildings.Utilities.IO.SignalExchange.Read readTCHWLeaCoi(
      y,
      description="Temperature of chilled water leaving the cooling coil",
      KPIs=Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.None)
      "read Temperature of chilled water leaving the cooling coil"
      annotation (Placement(transformation(extent={{120,-90},{100,-70}})));
    Buildings.Utilities.IO.SignalExchange.Read readTCHWEntChi(
      y,
      description="Temperature of chilled water entering chiller",
      KPIs=Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.None)
      "read Temperature of chilled water entering chiller"
      annotation (Placement(transformation(extent={{88,-18},{68,2}})));
    Buildings.Utilities.IO.SignalExchange.Read readTCWLeaTow(
      y,
      description="Temperature of condenser water leaving the cooling tower",
      KPIs=Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.None)
      "read Temperature of condenser water leaving the cooling tower"
      annotation (Placement(transformation(extent={{200,284},{180,304}})));
    Buildings.Utilities.IO.SignalExchange.Read readPAllAgg(
      y,
      description="Meters total power consumption",
      KPIs=Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.None)
      "Meters total power consumption"
      annotation (Placement(transformation(extent={{-526,246},{-506,266}})));
    Buildings.Utilities.IO.SignalExchange.Read readCO2(
      y,
      description="Concetration of CO2",
      KPIs=Buildings.Utilities.IO.SignalExchange.SignalTypes.SignalsForKPIs.CO2Concentration)
      "Concetration of CO2"
      annotation (Placement(transformation(extent={{-546,-228},{-526,-208}})));
      Modelica.Blocks.Sources.RealExpression conCO2(y=250)
      "Concetration of CO2" annotation (Placement(transformation(extent={{-10,-10},
              {10,10}}, origin={-580,-218})));
    Buildings.Utilities.IO.SignalExchange.Overwrite fauChiTset(final u,
        description="The falut temperature of the chiller")
      "Overwirte the fault temperature of the chiller"
      annotation (Placement(transformation(extent={{186,62},{198,74}})));
    Modelica.Blocks.Sources.Pulse pulse(
      amplitude=-5,
      width=3.3,
      period(displayUnit="d") = 2592000,
      nperiod=12,
      offset=0,
      startTime(displayUnit="d") = 1296000)
      annotation (Placement(transformation(extent={{164,66},{172,74}})));
    Modelica.Blocks.Sources.Pulse pulse1(
      amplitude=1,
      width=3.3,
      period(displayUnit="d") = 2592000,
      nperiod=12,
      offset=0,
      startTime(displayUnit="d") = 864000)
      annotation (Placement(transformation(extent={{412,106},{390,128}})));
    Buildings.Utilities.IO.SignalExchange.Overwrite fauval(final u, description
        ="The falut Chiller head pressure bypass valve")
      "Overwirte the fault Chiller head pressure bypass valve 0/1"
      annotation (Placement(transformation(extent={{376,106},{354,128}})));
    equation
      PSupFan = fan.P;
      PChiWatPum = pumCHW.P;
      PConWatPum = pumCW.P;
      PWSEWatPum = pumCWWSE.P;
      PCooTowWatPum = pumCT.P;
      PCooTowFan = cooTow.PFan;
      PChi = chi.P;
      QRooIntGai_flow = roo.QSou.Q_flow;
      mConWat_flow = pumCW.m_flow_actual;
      mChiWat_flow = pumCHW.VMachine_flow * rho_default;

      connect(weaBus.TWetBul, cooTow.TAir) annotation (Line(
          points={{-329.95,-89.95},{-260,-89.95},{-260,260},{170,260},{170,243},{
              197,243}},
          color={255,204,51},
          thickness=0.5,
          pattern=LinePattern.Dash),
                          Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}},
          horizontalAlignment=TextAlignment.Right));

      connect(weaBus.TWetBul, waterSideEconomizerOnOff.TWetBul) annotation (Line(
          points={{-329.95,-89.95},{-260,-89.95},{-260,100},{-164,100}},
          color={255,204,51},
          thickness=0.5,
          pattern=LinePattern.Dash), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}},
          horizontalAlignment=TextAlignment.Right));
      connect(chillerOnOff.yChi, chi.on) annotation (Line(
          points={{-116,34},{-100,34},{-100,78},{236,78},{236,96},{218,96}},
          color={255,0,255},
          pattern=LinePattern.Dot));
      connect(plantOnOff.yChiWatPlaRes, chilledWaterReset.uChiWatPlaRes)
        annotation (Line(points={{-176,-120},{-170,-120},{-170,-40},{-164,-40}},
            color={0,0,127},
          pattern=LinePattern.DashDot));
      connect(chilledWaterReset.TChiWatSupSet, chillerOnOff.TChiWatSupSet)
        annotation (Line(
          points={{-116,-28},{-100,-28},{-100,-10},{-180,-10},{-180,6},{-164,6}},
          color={0,0,127},
          pattern=LinePattern.DashDot));
      connect(chi.port_b1, pumCW.port_a) annotation (Line(
          points={{196,99},{196,100},{160,100},{160,110}},
          color={28,108,200},
          thickness=0.5));
      connect(waterSideEconomizerOnOff.ySta,
        condenserWater.uWSE) annotation (Line(
          points={{-116,88},{-108,88},{-108,236},{-84,236}},
          color={255,0,255},
          pattern=LinePattern.DashDot));
      connect(chillerOnOff.yChi, condenserWater.uChi)
        annotation (Line(
          points={{-116,34},{-100,34},{-100,220},{-84,220}},
          color={255,0,255},
          pattern=LinePattern.DashDot));

      connect(condenserWater.yTowFanSpeSet, cooTow.y)
        annotation (Line(
          points={{-36,236},{-8,236},{-8,270},{194,270},{194,247},{197,247}},
          color={0,0,127},
          pattern=LinePattern.Dot));

      connect(PWSEWatPum1.y, PWSEWatPumAgg.u) annotation (Line(
          points={{-499,20},{-480,20},{-480,30},{-462,30}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(val.port_2, chi.port_a1) annotation (Line(points={{300,130},{300,99},{
              216,99}},                     color={0,128,255},
          thickness=0.5));
      connect(TCWLeaTow.port_b, spl.port_1)
        annotation (Line(points={{300,217},{300,210}}, color={0,127,255},
          thickness=0.5));
      connect(mix.port_3, spl.port_3)
        annotation (Line(points={{110,200},{290,200}}, color={0,127,255}));
      connect(wse.port_a1, expVesWSE.ports[1]) annotation (Line(points={{68,99},{80,
              99},{80,121},{70,121}},color={0,127,255}));
      connect(PCTWatPum.y, PCooTowWatPumAgg.u) annotation (Line(
          points={{-499,-20},{-480,-20},{-480,-10},{-462,-10}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(wse.port_b1, pumCWWSE.port_a)
        annotation (Line(points={{48,99},{44,99},{44,100},{40,100},{40,132}},
                                                            color={0,127,255},
          thickness=0.5));
      connect(mix.port_2, pumCT.port_a) annotation (Line(points={{100,210},{100,240},
              {116,240}},           color={0,127,255},
          thickness=0.5));
      connect(cooTow.port_b, TCWLeaTow.port_a) annotation (Line(points={{219,239},{260,
              239},{260,240},{300,240},{300,237}},
                                             color={0,127,255},
          thickness=0.5));
      connect(roo.airPorts[2], cooCoi.port_a2) annotation (Line(
          points={{190.45,-229.3},{188,-229.3},{188,-226},{160,-226},{160,-176},{
              222,-176}},
          color={0,127,255},
          thickness=0.5));
      connect(pumCW.port_b, val.port_3) annotation (Line(points={{160,130},{160,140},
              {290,140}}, color={0,127,255}));
      connect(val4.port_b, wse.port_a1)
        annotation (Line(points={{120,110},{120,99},{68,99}}, color={0,127,255}));
      connect(spl.port_2, val.port_1)
        annotation (Line(points={{300,190},{300,150}}, color={0,127,255}));
      connect(spl.port_2, val4.port_a) annotation (Line(points={{300,190},{300,160},
              {120,160},{120,130}}, color={0,127,255}));
      connect(condenserWater.uChiPLR, realExpression.y)
        annotation (Line(points={{-84,204},{-125,204}}, color={0,0,127}));
      connect(TCHWEntChi.T, add1.u1) annotation (Line(points={{149,2.05391e-15},{
              136,2.05391e-15},{136,-4.4},{121.2,-4.4}}, color={238,46,47}));
      connect(const1.y, add1.u2) annotation (Line(points={{139.5,-13},{130,-13},{
              130,-11.6},{121.2,-11.6}}, color={238,46,47}));
      connect(val.y, max1.y) annotation (Line(points={{312,140},{312,139},{313,139},
              {313,140}}, color={0,0,127}));
      connect(TCWLeaTow.T, add2.u1) annotation (Line(points={{289,227},{277.1,227},
              {277.1,227.6},{265.2,227.6}}, color={255,0,0}));
      connect(add2.u2, const3.y) annotation (Line(points={{265.2,220.4},{265.2,213},
              {273.5,213}}, color={255,0,0}));
      connect(pumCWWSE.port_b, TCWWseLea.port_a)
        annotation (Line(points={{40,152},{40,165}}, color={0,127,255}));
      connect(TCWWseLea.port_b, mix.port_1) annotation (Line(points={{40,185},{40,
              188},{100,188},{100,190}}, color={0,127,255}));
      connect(pumCW.port_b, TCWChiLea.port_a) annotation (Line(points={{160,130},{
              152,130},{152,147},{140,147}}, color={0,127,255}));
      connect(TCWChiLea.port_b, mix.port_1) annotation (Line(points={{140,167},{120,
              167},{120,180},{100,180},{100,190}}, color={0,127,255}));
      connect(pumCT.port_b, TCWEnt.port_a) annotation (Line(points={{136,240},{146,
              240},{146,235},{156,235}}, color={0,127,255}));
      connect(cooTow.port_a, TCWEnt.port_b) annotation (Line(points={{199,239},{188,
              239},{188,235},{176,235}}, color={0,127,255}));
      connect(val6.port_b, TCHWOut.port_a)
        annotation (Line(points={{300,30},{300,-54},{302,-54}},
                                                      color={0,127,255}));
      connect(cooCoi.port_a1, TCHWOut.port_b) annotation (Line(points={{242,
            -164},{268,-164},{268,-160},{302,-160},{302,-74}},
                                                          color={0,127,255}));
    connect(chilledWaterReset.TChiWatSupSet, oveChiTset.u) annotation (Line(
          points={{-116,-28},{-76,-28},{-76,56},{132,56}}, color={0,0,127}));
    connect(oveChiTset.y, add.u2) annotation (Line(points={{155,56},{200,56},{
            200,62.4},{210.8,62.4}}, color={0,0,127}));
    connect(chillerOnOff.yOn, oveVal6.u) annotation (Line(points={{-116,20},{68,
            20},{68,40},{252,40}}, color={0,0,127}));
    connect(val6.y, oveVal6.y)
      annotation (Line(points={{288,40},{275,40}}, color={0,0,127}));
    connect(valByp.y, oveValByp.y) annotation (Line(points={{230,32},{222,32},{
            222,38},{213,38}}, color={0,0,127}));
    connect(chillerOnOff.yOff, oveValByp.u) annotation (Line(points={{-116,6},{
            -38,6},{-38,12},{126,12},{126,30},{190,30},{190,38}}, color={0,0,
            127}));
    connect(waterSideEconomizerOnOff.yOff, oveVal1.u) annotation (Line(points={
            {-116,100},{-60,100},{-60,-40},{112,-40}}, color={0,0,127}));
    connect(oveVal1.y, val1.y)
      annotation (Line(points={{135,-40},{148,-40}}, color={0,0,127}));
    connect(waterSideEconomizerOnOff.yOn, oveVal3.u) annotation (Line(points={{
            -116,112},{2,112},{2,-18},{20,-18}}, color={0,0,127}));
    connect(oveVal3.y, val3.y)
      annotation (Line(points={{43,-18},{60,-18},{60,-48}}, color={0,0,127}));
    connect(chilledWaterReset.dpChiWatPumSet, ovepumCHW.u) annotation (Line(
          points={{-116,-52},{-20,-52},{-20,-120},{100,-120}}, color={0,0,127}));
    connect(ovepumCHW.y, pumCHW.dp_in)
      annotation (Line(points={{123,-120},{148,-120}}, color={0,0,127}));
    connect(mFanFlo.y, ovemFanFlo.u)
      annotation (Line(points={{261,-200},{262,-200}}, color={0,0,127}));
    connect(ovemFanFlo.y, fan.m_flow_in) annotation (Line(points={{285,-200},{
            288,-200},{288,-213},{280,-213}}, color={0,0,127}));
    connect(condenserWater.mWSEConWatPumSet_flow, ovepumCWWSE.u) annotation (
        Line(points={{-36,220},{-10,220},{-10,142},{-4,142}}, color={0,0,127}));
    connect(ovepumCWWSE.y, pumCWWSE.m_flow_in)
      annotation (Line(points={{19,142},{28,142}}, color={0,0,127}));
    connect(condenserWater.mChiConWatPumSet_flow, ovepumCW.u) annotation (Line(
          points={{-36,228},{80,228},{80,146},{216,146},{216,120},{208,120}},
          color={0,0,127}));
    connect(ovepumCW.y, pumCW.m_flow_in)
      annotation (Line(points={{185,120},{172,120}}, color={0,0,127}));
    connect(condenserWater.mCTConWatPumSet, ovepumCT.u) annotation (Line(points
          ={{-36,212},{-8,212},{-8,232},{40,232},{40,242},{42,242}}, color={0,0,
            127}));
    connect(ovepumCT.y, pumCT.m_flow_in) annotation (Line(points={{65,242},{96,
            242},{96,228},{126,228}}, color={0,0,127}));
    connect(waterSideEconomizerOnOff.yOn, oveVal4.u) annotation (Line(points={{
            -116,112},{0,112},{0,82},{100,82}}, color={0,0,127}));
    connect(oveVal4.y, val4.y) annotation (Line(points={{123,82},{140,82},{140,
            120},{132,120}}, color={0,0,127}));
    connect(condenserWater.yChiConMix, oveval.u) annotation (Line(points={{-36,
            204},{24,204},{24,178},{316,178}}, color={0,0,127}));
    connect(oveval.y, max1.u1) annotation (Line(points={{339,178},{348,178},{
            348,146},{336,146}}, color={0,0,127}));
    connect(plantOnOff.TZonSup, readTAirSup.y) annotation (Line(points={{-224,
            -120},{-248,-120},{-248,-214},{179,-214}}, color={0,0,127}));
    connect(readTAirSup.u, TAirSup.T)
      annotation (Line(points={{202,-214},{230,-214}}, color={0,0,127}));
    connect(TCHWLeaCoi.T, readTCHWLeaCoi.u)
      annotation (Line(points={{149,-80},{122,-80}}, color={0,0,127}));
    connect(readTCHWLeaCoi.y, waterSideEconomizerOnOff.TChiWatRet) annotation (
        Line(points={{99,-80},{-200,-80},{-200,112},{-164,112}}, color={0,0,127}));
    connect(chillerOnOff.TChiWatRetDow, readTCHWEntChi.y) annotation (Line(
          points={{-164,34},{-192,34},{-192,-8},{67,-8}}, color={0,0,127}));
    connect(readTCHWEntChi.u, add1.y)
      annotation (Line(points={{90,-8},{107.4,-8}}, color={0,0,127}));
    connect(waterSideEconomizerOnOff.TConWatSup, readTCWLeaTow.y) annotation (
        Line(points={{-164,86},{-180,86},{-180,294},{179,294}}, color={0,0,127}));
    connect(readTCWLeaTow.u, add2.y) annotation (Line(points={{202,294},{238,
            294},{238,224},{251.4,224}}, color={0,0,127}));
    connect(PAllAgg.y, readPAllAgg.u) annotation (Line(points={{-539,240},{-536,
            240},{-536,256},{-528,256}}, color={0,0,127}));
    connect(readCO2.u, conCO2.y)
      annotation (Line(points={{-548,-218},{-569,-218}}, color={0,0,127}));
    connect(add.u1, fauChiTset.y) annotation (Line(points={{210.8,69.6},{206,
            69.6},{206,68},{198.6,68}}, color={0,0,127}));
    connect(chi.TSet, add.y) annotation (Line(points={{218,90},{230,90},{230,66},
            {224.6,66}}, color={0,0,127}));
    connect(fauChiTset.u, pulse.y) annotation (Line(points={{184.8,68},{180,68},
            {180,70},{172.4,70}}, color={0,0,127}));
    connect(max1.u2, fauval.y) annotation (Line(points={{336,134},{336,128},{
            352.9,128},{352.9,117}}, color={0,0,127}));
    connect(pulse1.y, fauval.u)
      annotation (Line(points={{388.9,117},{378.2,117}}, color={0,0,127}));
      annotation (
        __Dymola_Commands(file=
              "/home/milicag/repos/obc/examples/case_study_2/scripts/ClosedLoopBase/OneDeviceWithWSE.mos"
            "Simulate and plot"), Documentation(info="<html>
<p>
This model is the chilled water plant with continuous time control.
The trim and respond logic is approximated by a PI controller which
significantly reduces computing time. The model is described at
<a href=\"Buildings.Examples.ChillerPlant\">
Buildings.Examples.ChillerPlant</a>.
</p>
<p>
See
<a href=\"Buildings.Examples.ChillerPlant.DataCenterContinuousTimeControl\">
Buildings.Examples.ChillerPlant.DataCenterContinuousTimeControl</a>
for an implementation with the discrete time trim and respond logic.
</p>
</html>",     revisions="<html>
<ul>
<li>
July xx, 2021, by Milica Grahovac:<br/>
Revised pressure drops, packaged sub-controllers, and added metering panel.
</li>
<li>
January 13, 2015, by Michael Wetter:<br/>
Moved base model to
<a href=\"Buildings.Examples.ChillerPlant.BaseClasses.DataCenter\">
Buildings.Examples.ChillerPlant.BaseClasses.DataCenter</a>.
</li>
<li>
December 5, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Diagram(coordinateSystem(extent={{-660,-300},{400,320}}), graphics={
            Text(
              extent={{-226,-142},{-168,-162}},
              textColor={238,46,47},
              textString="PI未调谐"),
            Text(
              extent={{174,4},{242,-38}},
              textColor={238,46,47},
              textString="chi回水温度"),
            Text(
              extent={{300,98},{422,58}},
              textColor={238,46,47},
              textString="阀门卡住
（这个模型只有1/0）"),
            Text(
              extent={{314,238},{402,192}},
              textColor={238,46,47},
              textString="冷却塔出水温度"),
            Text(
              extent={{232,90},{300,48}},
              textColor={238,46,47},
              textString="chi出水温度"),
            Text(
              extent={{-608,-172},{-502,-200}},
              lineColor={28,108,200},
            textString="con CO2 数值需更改")}),
        experiment(
          StopTime=31536000,
          Tolerance=0.001,
          __Dymola_Algorithm="Cvode"),
        Icon(coordinateSystem(extent={{-660,-300},{400,320}})));
    end OneDeviceWithWSE;

    package BaseClasses
    "Package with base classes for Buildings.Examples.ChillerPlant"
    extends Modelica.Icons.BasesPackage;

      package Controls
      "Package with control components for Buildings.Examples.ChillerPlant"
      extends Modelica.Icons.VariantsPackage;

        model ChilledWaterReset "Chilled water reset"
          Buildings.Controls.OBC.CDL.Interfaces.RealInput uChiWatPlaRes(
            final min = 0,
            final max = 1,
            final unit="1")
            "Chilled water plant reset control signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Buildings.Examples.ChillerPlant.BaseClasses.Controls.LinearPiecewiseTwo
            linPieTwo(
            x0=0,
            x2=1,
            x1=0.5,
            y11=1,
            y21=273.15 + 5.56,
            y10=0.2,
            y20=273.15 + 22) "Translate the control signal for chiller setpoint reset"
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
          Buildings.Controls.OBC.CDL.Reals.MultiplyByParameter gain(k=20*6485)
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput dpChiWatPumSet(final unit=
                "Pa", final quantity="PressureDifference")
            "Chilled water pump differential static pressure setpoint"
            annotation (Placement(transformation(extent={{100,-90},{140,-50}}),
              iconTransformation(extent={{100,-80},{140,-40}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput TChiWatSupSet(
            final unit="K",
            displayUnit="degC",
            final quantity="ThermodynamicTemperature")
            "Chilled water supply temperature"
            annotation (Placement(transformation(extent={{100,50},{140,90}}),
              iconTransformation(extent={{100,40},{140,80}})));
        equation
          connect(linPieTwo.y[1], gain.u) annotation (Line(points={{-19,-0.7},{-18,-0.7},
                  {-18,0},{18,0}}, color={0,0,127}));
          connect(linPieTwo.y[2], TChiWatSupSet) annotation (Line(points={{-19,0.3},{0,
                  0.3},{0,70},{120,70}}, color={0,0,127}));
          connect(gain.y, dpChiWatPumSet) annotation (Line(points={{42,0},{60,0},{60,
                  -70},{120,-70}}, color={0,0,127}));
          connect(uChiWatPlaRes, linPieTwo.u)
            annotation (Line(points={{-120,0},{-42,0}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={28,108,200}),
                  Text(
                  extent={{-54,34},{44,-28}},
                  lineColor={28,108,200},
                  textString="CHW
Reset")}),      Diagram(coordinateSystem(preserveAspectRatio=false)));
        end ChilledWaterReset;

        model ChillerOnOff "Chiller status"

          parameter Real dTChi(
            final unit="K",
            final quantity="TemperatureDifference",
            displayUnit="degC")=2.2
            "Deadband to avoid chiller short-cycling"
            annotation(Dialog(group="Design parameters"));

          Buildings.Examples.ChillerPlant.BaseClasses.Controls.ChillerSwitch chiSwi(
            deaBan = dTChi)
            annotation (Placement(transformation(extent={{-20,0},{0,20}})));
          Buildings.Controls.OBC.CDL.Conversions.BooleanToReal invCon(realTrue=0,
              realFalse=1) "Boolean to real conversion that inverts input signal"
            annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealInput TChiWatRetDow
            "Chilled water return temperature downstream of WSE"
            annotation (Placement(transformation(extent={{-140,50},{-100,90}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealInput TChiWatSupSet
            "Chilled water supply temperature set-point"
            annotation (Placement(transformation(extent={{-140,-90},{-100,-50}})));
          Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yChi "Chiller status"
            annotation (Placement(transformation(extent={{100,50},{140,90}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOn
            "1 if chiller is commanded ON, 0 otherwise"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOff
            "1 if chiller is commanded OFF, 0 otherwise"
            annotation (Placement(transformation(extent={{100,-90},{140,-50}})));
          Buildings.Controls.OBC.CDL.Conversions.BooleanToReal con1(realTrue=1,
              realFalse=0) "Boolean to real conversion of input signal"
            annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
        equation
          connect(TChiWatRetDow, chiSwi.chiCHWST) annotation (Line(points={{-120,70},{-70,
                  70},{-70,17},{-21,17}}, color={0,0,127}));
          connect(TChiWatSupSet, chiSwi.TSet) annotation (Line(points={{-120,-70},{-70,-70},
                  {-70,5},{-21,5}}, color={0,0,127}));
          connect(chiSwi.y, yChi) annotation (Line(points={{1,9.4},{20,9.4},{20,70},{120,
                  70}}, color={255,0,255}));
          connect(chiSwi.y, con1.u) annotation (Line(points={{1,9.4},{1,10},{20,10},{20,
                  -30},{38,-30}}, color={255,0,255}));
          connect(chiSwi.y, invCon.u) annotation (Line(points={{1,9.4},{2,9.4},{2,10},{20,
                  10},{20,-70},{38,-70}}, color={255,0,255}));
          connect(con1.y, yOn) annotation (Line(points={{62,-30},{80,-30},{80,0},{120,0}},
                color={0,0,127}));
          connect(invCon.y, yOff)
            annotation (Line(points={{62,-70},{120,-70}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={28,108,200}),
                  Text(
                  extent={{-56,50},{54,-44}},
                  lineColor={28,108,200},
                  textString="Chiller
On/Off")}),     Diagram(coordinateSystem(preserveAspectRatio=false)));
        end ChillerOnOff;

        model CondenserWater
          "Constant tower fan and pump speed controls with mixing valve controller"

          parameter Modelica.Units.SI.MassFlowRate mCW_flow_nominal=1
            "Nominal condenser water mass flow rate for the WSE loop";

          parameter Real chiFloDivWseFlo = 0.5
           "Ratio of CW flow rates: chiller loop nominal flow divided by the WSE loop nominal flow";

          parameter Real PLRMinUnl = 0.3
           "Minimum chiller unloading part load ratio";

          Buildings.Controls.OBC.CDL.Logical.Or or2 "Logical or"
            annotation (Placement(transformation(extent={{-60,70},{-40,90}})));
          Buildings.Controls.OBC.CDL.Conversions.BooleanToReal mCWFlo(
            final realTrue=mCW_flow_nominal)
            "Mass flow rate of condenser loop"
            annotation (Placement(transformation(extent={{-20,30},{0,50}})));
          Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uWSE
            "Status of water side economizer: true = ON, false = OFF"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
          Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uChi
            "Chiller status: true = ON, false = OFF"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}}),
                iconTransformation(extent={{-140,-20},{-100,20}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput yTowFanSpeSet
            "Cooling tower fan speed set-point"
            annotation (Placement(transformation(extent={{100,60},{140,100}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput mWSEConWatPumSet_flow
            "Condenser water pump mass flow set-point for the WSE loop"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
          Buildings.Controls.OBC.CDL.Conversions.BooleanToReal mCWFlo1(final realTrue=1)
            "Mass flow rate of condenser loop"
            annotation (Placement(transformation(extent={{-20,70},{0,90}})));
          Buildings.Controls.OBC.CDL.Reals.MultiplyByParameter gai(k=chiFloDivWseFlo)
            "Flow multiplier"
            annotation (Placement(transformation(extent={{20,30},{40,50}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput mChiConWatPumSet_flow
            "Condenser water pump mass flow set-point for the chiller condenser loop"
            annotation (Placement(transformation(extent={{100,20},{140,60}})));
          Buildings.Controls.OBC.CDL.Conversions.BooleanToReal mCWFlo2(final realTrue=
                mCW_flow_nominal)
            "Mass flow rate of condenser loop"
            annotation (Placement(transformation(extent={{-20,-20},{0,0}})));
          Buildings.Controls.OBC.CDL.Reals.MultiplyByParameter gai1(k=chiFloDivWseFlo)
            "Flow multiplier"
            annotation (Placement(transformation(extent={{20,-20},{40,0}})));
          Buildings.Controls.OBC.CDL.Reals.Sources.Constant set(k=PLRMinUnl) "Constant"
            annotation (Placement(transformation(extent={{-60,-90},{-40,-70}})));
          Buildings.Controls.OBC.CDL.Reals.PIDWithReset heaPreCon(
            final controllerType=Buildings.Controls.OBC.CDL.Types.SimpleController.PI,
            final k=100,
            final Ti=0.1,
            final Td=120,
            final r=PLRMinUnl,
            final yMax=1,
            final yMin=0,
            reverseActing=true)
            "Controls the recirculation valve to maintain the CW supply temperature sufficiently above the evaporator side one"
            annotation (Placement(transformation(extent={{-20,-90},{0,-70}})));
          Buildings.Obsolete.Controls.OBC.CDL.Continuous.Add addFlo
            "Adds WSE and chiller condenser side flow "
            annotation (Placement(transformation(extent={{60,-50},{80,-30}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput mCTConWatPumSet
            "Condenser water pump mass flow set-point for the cooling tower loop"
            annotation (Placement(transformation(extent={{100,-60},{140,-20}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput yChiConMix
            "Chiller condenser supply temperature regulation valve "
            annotation (Placement(transformation(extent={{100,-100},{140,-60}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealInput uChiPLR
            "Measured chiller part load ratio" annotation (Placement(transformation(
                  extent={{-140,-80},{-100,-40}}), iconTransformation(extent={{-140,-100},
                    {-100,-60}})));
          Buildings.Obsolete.Controls.OBC.CDL.Continuous.AddParameter addPar(p=1, k=-1)
            annotation (Placement(transformation(extent={{40,-90},{60,-70}})));
        equation
          connect(uWSE, or2.u1) annotation (Line(points={{-120,80},{-62,80}},
                           color={255,0,255}));
          connect(uChi, or2.u2) annotation (Line(points={{-120,0},{-80,0},{-80,72},{-62,
                  72}},      color={255,0,255}));
          connect(mWSEConWatPumSet_flow, mWSEConWatPumSet_flow)
            annotation (Line(points={{120,0},{120,0}},     color={0,0,127}));
          connect(or2.y, mCWFlo1.u) annotation (Line(points={{-38,80},{-22,80}},
                        color={255,0,255}));
          connect(mCWFlo1.y, yTowFanSpeSet)
            annotation (Line(points={{2,80},{120,80}},  color={0,0,127}));
          connect(uChi, mCWFlo.u) annotation (Line(points={{-120,0},{-72,0},{-72,40},{
                  -22,40}},  color={255,0,255}));
          connect(uWSE, mCWFlo2.u) annotation (Line(points={{-120,80},{-88,80},{-88,-10},
                  {-22,-10}},color={255,0,255}));
          connect(mCWFlo.y, gai.u)
            annotation (Line(points={{2,40},{18,40}},    color={0,0,127}));
          connect(gai.y, mChiConWatPumSet_flow)
            annotation (Line(points={{42,40},{120,40}},   color={0,0,127}));
          connect(mCWFlo2.y, gai1.u)
            annotation (Line(points={{2,-10},{18,-10}}, color={0,0,127}));
          connect(gai1.y, mWSEConWatPumSet_flow) annotation (Line(points={{42,-10},{60,-10},
                  {60,0},{120,0}},          color={0,0,127}));
          connect(set.y,heaPreCon. u_s)
            annotation (Line(points={{-38,-80},{-22,-80}}, color={0,0,127},
              pattern=LinePattern.DashDot));
          connect(gai.y, addFlo.u1) annotation (Line(points={{42,40},{50,40},{50,-34},{58,
                  -34}}, color={0,0,127}));
          connect(gai1.y, addFlo.u2) annotation (Line(points={{42,-10},{48,-10},{48,-46},
                  {58,-46}}, color={0,0,127}));
          connect(addFlo.y, mCTConWatPumSet)
            annotation (Line(points={{82,-40},{120,-40}}, color={0,0,127}));
          connect(yChiConMix, yChiConMix)
            annotation (Line(points={{120,-80},{120,-80}}, color={0,0,127}));
          connect(uChi, heaPreCon.trigger) annotation (Line(points={{-120,0},{-80,0},{
                  -80,-96},{-16,-96},{-16,-92}},  color={255,0,255}));
          connect(uChiPLR, heaPreCon.u_m) annotation (Line(points={{-120,-60},{-90,-60},
                  {-90,-98},{-10,-98},{-10,-92}}, color={0,0,127}));
          connect(heaPreCon.y, addPar.u)
            annotation (Line(points={{2,-80},{38,-80}}, color={0,0,127}));
          connect(addPar.y, yChiConMix)
            annotation (Line(points={{62,-80},{120,-80}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={28,108,200}),
                  Text(
                  extent={{-48,42},{48,-36}},
                  lineColor={28,108,200},
                  textString="CW")}),
                Diagram(coordinateSystem(preserveAspectRatio=false)));
        end CondenserWater;

        model PlantOnOffWithAnalogueTrimAndRespond "Plant status"

          // control parameters used in both base and 1711 cases
          parameter Real TZonSupSet(
            final unit="K",
            final quantity="Temperature",
            displayUnit="degC")=273.15 + 27
            "Zone supply air temperature setpoint"
            annotation(Dialog(group="Design parameters"));

          Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonSup
            "Measured zone air supply temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Buildings.Controls.OBC.CDL.Interfaces.RealOutput yChiWatPlaRes
            "Chilled water plant reset signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          Buildings.Controls.OBC.CDL.Reals.Sources.Constant TAirSet(final k=TZonSupSet)
            "Set temperature for air supply to the room" annotation (Placement(
                transformation(extent={{-10,-10},{10,10}}, origin={-30,-30})));

          Buildings.Obsolete.Controls.OBC.CDL.Continuous.Feedback feedback
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

          Buildings.Examples.ChillerPlant.BaseClasses.Controls.TrimAndRespondContinuousTimeApproximation
            triAndRes1 annotation (Placement(transformation(extent={{40,-10},{60,10}})));

        equation
          connect(TAirSet.y,feedback. u2) annotation (Line(
              points={{-18,-30},{0,-30},{0,-12}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(feedback.y, triAndRes1.u)
            annotation (Line(points={{12,0},{38,0}},  color={0,0,127}));
          connect(TZonSup, feedback.u1) annotation (Line(points={{-120,0},{-12,0}},
                                color={0,0,127}));
          connect(triAndRes1.y, yChiWatPlaRes) annotation (Line(points={{61,0},{120,0}},
                                   color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={28,108,200}),
                  Text(
                  extent={{-60,62},{62,-56}},
                  lineColor={28,108,200},
                  textString="Plant
On/Off")}),     Diagram(coordinateSystem(preserveAspectRatio=false)));
        end PlantOnOffWithAnalogueTrimAndRespond;

        model WaterSideEconomizerOnOff "Water-side economizer status"

          parameter Real cooTowAppDes(
            final unit="K",
            final quantity="TemperatureDifference",
            displayUnit="degC")=6
            "Design cooling tower approach"
            annotation(Dialog(group="Design parameters"));

          WaterSideEconomizerStateMachine waterSideEconomizerBase
            annotation (Placement(transformation(extent={{-10,-20},{10,20}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealInput TChiWatRet
            "Chilled water return temperature upstream of WSE"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealInput TWetBul
            "Outdoor air wetbulb temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealInput TConWatSup
            "Condenser water supply temperature"
            annotation (Placement(transformation(extent={{-140,-90},{-100,-50}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOn
            "1 if WSE is commanded on, 0 otherwise"
            annotation (Placement(transformation(extent={{100,40},{140,80}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOff
            "1 if WSE is commanded off, 0 otherwise"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
          Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput ySta
            "Water-side economizer status"
            annotation (Placement(transformation(extent={{100,-80},{140,-40}})));
          Buildings.Controls.OBC.CDL.Reals.Sources.Constant con(final k=cooTowAppDes)
            annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
        equation
          connect(con.y, waterSideEconomizerBase.towTApp) annotation (Line(points={{-58,
                  -30},{-30,-30},{-30,-5.88235},{-12,-5.88235}}, color={0,0,127}));
          connect(TChiWatRet, waterSideEconomizerBase.wseCHWST) annotation (Line(points={{-120,60},
                  {-40,60},{-40,12.9412},{-12,12.9412}},           color={0,0,127}));
          connect(TWetBul, waterSideEconomizerBase.TWetBul) annotation (Line(points={{-120,
                  0},{-40,0},{-40,1.17647},{-12,1.17647}}, color={0,0,127}));
          connect(TConWatSup, waterSideEconomizerBase.wseCWST) annotation (Line(points={{-120,
                  -70},{-20,-70},{-20,-15.0588},{-12,-15.0588}},       color={0,0,127}));
          connect(waterSideEconomizerBase.y1, yOn) annotation (Line(points={{11,3.52941},
                  {60,3.52941},{60,60},{120,60}}, color={0,0,127}));
          connect(waterSideEconomizerBase.y2, yOff) annotation (Line(points={{11,-5.88235},
                  {60,-5.88235},{60,0},{120,0}}, color={0,0,127}));
          connect(waterSideEconomizerBase.ySta, ySta) annotation (Line(points={{12,
                  -12.9412},{60,-12.9412},{60,-60},{120,-60}},
                                                     color={255,0,255}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={28,108,200}),
                  Text(
                  extent={{-88,86},{84,-74}},
                  lineColor={28,108,200},
                  textString="WSE
On/Off")}),     Diagram(coordinateSystem(preserveAspectRatio=false)));
        end WaterSideEconomizerOnOff;

        model WaterSideEconomizerStateMachine
          "Water-side economizer status state machine controller"
          extends
          Buildings.Examples.ChillerPlant.BaseClasses.Controls.WSEControl;

          Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput ySta
            "WSE status setpoint, ON = true, OFF = false" annotation (Placement(
                transformation(extent={{180,-120},{220,-80}}), iconTransformation(
                  extent={{180,-120},{220,-80}})));
          Buildings.Controls.OBC.CDL.Logical.Not not1
            annotation (Placement(transformation(extent={{140,-110},{160,-90}})));
        equation
          connect(ySta, not1.y)
            annotation (Line(points={{200,-100},{162,-100}}, color={255,0,255}));
          connect(off.active, not1.u) annotation (Line(points={{10,76.8},{10,-100},{138,
                  -100}}, color={255,0,255}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(extent={{-20,180},{180,-160}},  lineColor={28,108,200}),
                  Text(
                  extent={{-6,100},{160,-54}},
                  lineColor={28,108,200},
                  textString="WSE")}),
                Diagram(coordinateSystem(preserveAspectRatio=false), graphics={Text(
                  extent={{-74,148},{-8,144}},
                  lineColor={28,108,200},
                  textString="fixme: this input is effectivelly 
chilled water return temperature
upstream of WSE")}));
        end WaterSideEconomizerStateMachine;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models that are used to construct the control system in
<a href=\"modelica://Buildings.Examples.ChillerPlant\">Buildings.Examples.ChillerPlant</a>.
</p>
</html>"));
      end Controls;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Examples.ChillerPlant\">Buildings.Examples.ChillerPlant</a>.
</p>
</html>"));
    end BaseClasses;
  end ClosedLoopBase;

  package BaseClasses
  "Package with base classes for Buildings.Examples.ChillerPlant"
  extends Modelica.Icons.BasesPackage;

    partial model DataCenter
      "Primary only chiller plant system with water-side economizer without controls"

      //parameter Modelica.Media.Water.WaterIF97_base.ThermodynamicState sta_default=Medium.setState_pTX(
      //  T=Medium.T_default,
      //  p=Medium.p_default,
      //  X=Medium.X_default)
      //  "State of the medium at the medium default properties";

      //parameter Modelica.SIunits.Density rho_default=Medium.density(sta_default)
      //  "Density at the medium default properties";

      parameter Buildings.Media.Water.ThermodynamicState sta_default=Buildings.Media.Water.setState_pTX(
          T=Buildings.Media.Water.T_default,
          p=Buildings.Media.Water.p_default,
          X=Buildings.Media.Water.X_default);

      parameter Modelica.Units.SI.Density rho_default=Buildings.Media.Water.density(
          sta_default) "Density, used to compute fluid volume";

      parameter Modelica.Units.SI.ThermodynamicTemperature TZonSupSet=273.15 + 27
        "Zone supply temperature setpoint";

      // control parameters
      parameter Modelica.Units.SI.TemperatureDifference cooTowAppDes=4
        "Design cooling tower approach"
        annotation (Dialog(group="Design parameters"));

      parameter Modelica.Units.SI.ThermodynamicTemperature TWetBulDes=273.15 + 22
        "Design wet bulb temperature" annotation (Dialog(group="Design parameters"));

      replaceable package MediumA = Buildings.Media.Air "Medium model";
      replaceable package MediumW = Buildings.Media.Water "Medium model";
      parameter Modelica.Units.SI.MassFlowRate mAir_flow_nominal=roo.QRoo_flow/(
          1005*15) "Nominal mass flow rate at fan";
      parameter Modelica.Units.SI.Power P_nominal=80E3
        "Nominal compressor power (at y=1)";
      parameter Modelica.Units.SI.TemperatureDifference dTEva_nominal=6
        "Temperature difference evaporator inlet-outlet";
      parameter Modelica.Units.SI.TemperatureDifference dTCon_nominal=6
        "Temperature difference condenser outlet-inlet";
      parameter Real COPc_nominal=5 "Chiller COP";
      parameter Modelica.Units.SI.MassFlowRate mCHW_flow_nominal=2*roo.QRoo_flow/(
          4200*20) "Nominal mass flow rate at chilled water";

      parameter Modelica.Units.SI.MassFlowRate mCW_flow_nominal=2*roo.QRoo_flow/(
          4200*6) "Nominal mass flow rate at condenser water";

      parameter Modelica.Units.SI.PressureDifference dp_nominal=200000
        "Nominal pressure difference";
      Buildings.Fluid.Movers.FlowControlled_m_flow fan(
        redeclare package Medium = MediumA,
        m_flow_nominal=mAir_flow_nominal,
        dp(start=249),
        m_flow(start=mAir_flow_nominal),
        use_inputFilter=false,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        T_start=293.15) "Fan for air flow through the data center"
        annotation (Placement(transformation(extent={{290,-235},{270,-215}})));
      Buildings.Fluid.HeatExchangers.DryCoilCounterFlow cooCoi(
        redeclare package Medium1 = MediumW,
        redeclare package Medium2 = MediumA,
        m2_flow_nominal=mAir_flow_nominal,
        m1_flow_nominal=mCHW_flow_nominal,
        m1_flow(start=mCHW_flow_nominal),
        m2_flow(start=mAir_flow_nominal),
        dp2_nominal=200,
        UA_nominal=mAir_flow_nominal*1006*5,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyStateInitial,
        dp1_nominal(displayUnit="Pa") = 24000)
        "Cooling coil"
        annotation (Placement(transformation(extent={{242,-180},{222,-160}})));
      Buildings.Examples.ChillerPlant.BaseClasses.SimplifiedRoom roo(
        redeclare package Medium = MediumA,
        nPorts=1,
        rooLen=50,
        rooWid=30,
        rooHei=3,
        m_flow_nominal=mAir_flow_nominal,
        QRoo_flow=500000) "Room model" annotation (Placement(transformation(extent={
                {-10,10},{10,-10}}, origin={190,-238})));
      Buildings.Fluid.Movers.FlowControlled_dp pumCHW(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCHW_flow_nominal,
        m_flow(start=mCHW_flow_nominal),
        dp(start=1000 + 12000 + 15000 + 3500 + 24000),
        use_inputFilter=false,
        energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial)
        "Chilled water pump" annotation (Placement(transformation(
            extent={{10,10},{-10,-10}},
            rotation=270,
            origin={160,-120})));
      Buildings.Fluid.Sources.Boundary_pT expVesCHW(redeclare package Medium =
            MediumW,
        p=100000,    nPorts=1) "Represents an expansion vessel"
        annotation (Placement(transformation(extent={{188,-149},{208,-129}})));
      Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc cooTow(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCW_flow_nominal,
        TAirInWB_nominal(displayUnit="degC") = 283.15,
        TApp_nominal=cooTowAppDes,
        dp_nominal=15000,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyStateInitial,
        PFan_nominal=6500)
        "Cooling tower"                                   annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            origin={209,239})));
      Buildings.Fluid.HeatExchangers.ConstantEffectiveness wse(
        redeclare package Medium1 = MediumW,
        redeclare package Medium2 = MediumW,
        m1_flow_nominal=mCW_flow_nominal/2,
        m2_flow_nominal=mCHW_flow_nominal,
        eps=0.8,
        dp2_nominal=15000,
        dp1_nominal=42000)
                       "Water side economizer (Heat exchanger)"
        annotation (Placement(transformation(extent={{68,83},{48,103}})));
      Buildings.Fluid.Actuators.Valves.TwoWayLinear val1(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCHW_flow_nominal,
        dpValve_nominal=20902,
        use_inputFilter=false)
        "Bypass control valve for economizer. 1: disable economizer, 0: enable economizer"
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={160,-40})));
      Buildings.Fluid.Chillers.ElectricEIR chi(
        redeclare package Medium1 = MediumW,
        redeclare package Medium2 = MediumW,
        m1_flow_nominal=mCW_flow_nominal/2,
        m2_flow_nominal=mCHW_flow_nominal,
        dp2_nominal=19000,
        dp1_nominal=42000,
        per=Buildings.Fluid.Chillers.Data.ElectricEIR.ElectricEIRChiller_McQuay_WSC_471kW_5_89COP_Vanes(),
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyStateInitial) "Chiller"
        annotation (Placement(transformation(extent={{216,83},{196,103}})));
      Buildings.Fluid.Actuators.Valves.TwoWayLinear val6(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCHW_flow_nominal,
        dpValve_nominal=20902,
        dpFixed_nominal=14930 + 89580,
        y_start=1,
        use_inputFilter=false,
        from_dp=true)
        "Control valve for chilled water leaving from chiller" annotation (
          Placement(transformation(
            extent={{-10,10},{10,-10}},
            rotation=270,
            origin={300,40})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TAirSup(redeclare package
        Medium =
            MediumA, m_flow_nominal=mAir_flow_nominal)
        "Supply air temperature to data center" annotation (Placement(
            transformation(
            extent={{10,-10},{-10,10}},
            origin={230,-225})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TCHWEntChi(redeclare package
        Medium =   MediumW, m_flow_nominal=mCHW_flow_nominal)
        "Temperature of chilled water entering chiller" annotation (Placement(
            transformation(
            extent={{10,10},{-10,-10}},
            rotation=270,
            origin={160,0})));
      Buildings.Fluid.Actuators.Valves.TwoWayLinear          valByp(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCHW_flow_nominal,
        dpValve_nominal=20902,
        riseTime=60,
        dpFixed_nominal=14930,
        y_start=0,
        use_inputFilter=false,
        from_dp=true)          "Bypass valve for chiller." annotation (Placement(
            transformation(extent={{-10,-10},{10,10}}, origin={230,20})));
      Buildings.Fluid.Actuators.Valves.TwoWayLinear val3(
        redeclare package Medium = MediumW,
        m_flow_nominal=mCHW_flow_nominal,
        dpValve_nominal=20902,
        dpFixed_nominal=59720 + 1000,
        use_inputFilter=false)
        "Control valve for economizer. 0: disable economizer, 1: enable economizer"
        annotation (Placement(transformation(extent={{10,-10},{-10,10}}, origin={60,-60})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TCHWLeaCoi(redeclare package
        Medium =   MediumW, m_flow_nominal=mCHW_flow_nominal)
        "Temperature of chilled water leaving the cooling coil"
                                                         annotation (Placement(
            transformation(
            extent={{10,10},{-10,-10}},
            rotation=270,
            origin={160,-80})));
      Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaData(filNam=
            "/home/milicag/repos/obc/examples/case_study_2/weatherdata/USA_CA_Sacramento.724835_TMY2.mos")
        annotation (Placement(transformation(extent={{-400,-100},{-380,-80}})));
      Buildings.BoundaryConditions.WeatherData.Bus weaBus
        annotation (Placement(transformation(extent={{-340,-100},{-320,-80}})));
      Modelica.Blocks.Sources.Constant mFanFlo(k=mAir_flow_nominal)
        "Mass flow rate of fan" annotation (Placement(transformation(extent={{240,
                -210},{260,-190}})));
    equation

      connect(cooCoi.port_b2, fan.port_a) annotation (Line(
          points={{242,-176},{301,-176},{301,-225},{290,-225}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));

      connect(wse.port_a2, val3.port_b) annotation (Line(
          points={{48,87},{40,87},{40,-60},{50,-60}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(TAirSup.port_a, fan.port_b) annotation (Line(
          points={{240,-225},{270,-225}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(roo.airPorts[1],TAirSup. port_b) annotation (Line(
          points={{190.45,-229.3},{190.45,-225},{220,-225}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(TCHWLeaCoi.port_a, pumCHW.port_b)
                                               annotation (Line(
          points={{160,-90},{160,-110}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(TCHWEntChi.port_b, valByp.port_a)
                                             annotation (Line(
          points={{160,10},{160,20},{220,20}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(TCHWEntChi.port_a, val1.port_b)
                                             annotation (Line(
          points={{160,-10},{160,-30}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(val1.port_a, TCHWLeaCoi.port_b)
                                             annotation (Line(
          points={{160,-50},{160,-70}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(val3.port_a, TCHWLeaCoi.port_b)
                                             annotation (Line(
          points={{70,-60},{160,-60},{160,-70}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(weaData.weaBus, weaBus) annotation (Line(
          points={{-380,-90},{-328,-90},{-328,-88},{-330,-88},{-330,-90}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          textString="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(TCHWEntChi.port_a, wse.port_b2)
                                             annotation (Line(
          points={{160,-10},{160,-20},{80,-20},{80,87},{68,87}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(valByp.port_b, val6.port_b)
                                        annotation (Line(
          points={{240,20},{300,20},{300,30}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(TCHWEntChi.port_b, chi.port_a2)
                                             annotation (Line(
          points={{160,10},{160,88},{196,88},{196,87}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));

      connect(pumCHW.port_a, cooCoi.port_b1) annotation (Line(
          points={{160,-130},{160,-164},{222,-164}},
          color={0,127,255},
          smooth=Smooth.None,
          thickness=0.5));
      connect(expVesCHW.ports[1], cooCoi.port_b1) annotation (Line(
          points={{208,-139},{208,-140},{220,-140},{220,-164},{222,-164}},
          color={0,127,255},
          thickness=0.5));
      connect(chi.port_b2, val6.port_a) annotation (Line(points={{216,87},{248,87},
              {248,86},{300,86},{300,50}}, color={0,127,255}));
      annotation (
        Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-360,-300},{360,
                300}})),
    Documentation(info="<HTML>
<p>
This model is the chilled water plant with discrete time control and
trim and respond logic for a data center. The model is described at
<a href=\"Buildings.Examples.ChillerPlant\">
Buildings.Examples.ChillerPlant</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
July xx, 2021, by Milica Grahovac:<br/>
Revised pressure drops, removed elements per OBC data center chiller plant case study needs.
</li>
<li>
September 21, 2017, by Michael Wetter:<br/>
Set <code>from_dp = true</code> in <code>val6</code> and in <code>valByp</code>
which is needed for Dymola 2018FD01 beta 2 for
<a href=\"modelica://Buildings.Examples.ChillerPlant.DataCenterDiscreteTimeControl\">
Buildings.Examples.ChillerPlant.DataCenterDiscreteTimeControl</a>
to converge.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
January 13, 2015 by Michael Wetter:<br/>
Moved model to <code>BaseClasses</code> because the continuous and discrete time
implementation of the trim and respond logic do not extend from a common class,
and hence the <code>constrainedby</code> operator is not applicable.
Moving the model here allows to implement both controllers without using a
<code>replaceable</code> class.
</li>
<li>
January 12, 2015 by Michael Wetter:<br/>
Made media instances replaceable, and used the same instance for both
water loops.
This was done to simplify the numerical benchmarks.
</li>
<li>
December 22, 2014 by Michael Wetter:<br/>
Removed <code>Modelica.Fluid.System</code>
to address issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/311\">#311</a>.
</li>
<li>
March 25, 2014, by Michael Wetter:<br/>
Updated model with new expansion vessel.
</li>
<li>
December 5, 2012, by Michael Wetter:<br/>
Removed the filtered speed calculation for the valves to reduce computing time by 25%.
</li>
<li>
October 16, 2012, by Wangda Zuo:<br/>
Reimplemented the controls.
</li>
<li>
July 20, 2011, by Wangda Zuo:<br/>
Added comments and merge to library.
</li>
<li>
January 18, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(extent={{-360,-300},{360,300}})));
    end DataCenter;

    partial model EnergyMonitoring "Energy monitoring system"

      Modelica.Units.SI.Power PSupFan;
      Modelica.Units.SI.Power PChiWatPum;
      Modelica.Units.SI.Power PConWatPum;
      Modelica.Units.SI.Power PCooTowFan;
      Modelica.Units.SI.Power PChi;

      Modelica.Units.SI.HeatFlowRate QRooIntGai_flow;

      Modelica.Units.SI.MassFlowRate mConWat_flow;
      Modelica.Units.SI.MassFlowRate mChiWat_flow;

      Modelica.Blocks.Sources.RealExpression PAll(y=PSupFan + PChiWatPum +
            PConWatPum + PCooTowFan + PChi)
        "Total power consumed by the data center chiller plant system" annotation (
          Placement(transformation(extent={{-10,-10},{10,10}}, origin={-610,232})));

      Modelica.Blocks.Sources.RealExpression QRooIntGai1_flow(y=QRooIntGai_flow)
        "Power consumed by IT" annotation (Placement(transformation(extent={{-10,-10},
                {10,10}}, origin={-610,-100})));

      Modelica.Blocks.Continuous.Integrator PAllAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0) "Meters total power consumption"
        annotation (Placement(transformation(extent={{-560,230},{-540,250}})));

      Modelica.Blocks.Continuous.Integrator QRooIntGaiAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0) "Energy consumed by IT"
        annotation (Placement(transformation(extent={{-560,-110},{-540,-90}})));

      Modelica.Blocks.Sources.RealExpression PCooTowFan1(y=PCooTowFan)
        "Cooling tower power consumption" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}}, origin={-610,92})));

      Modelica.Blocks.Continuous.Integrator PCooTowAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0) "Cooling tower power consumption meter"
        annotation (Placement(transformation(extent={{-560,90},{-540,110}})));

      Modelica.Blocks.Sources.RealExpression PChiWatPum1(y=PChiWatPum)
        "Chilled water pump power consumption" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}}, origin={-510,232})));

      Modelica.Blocks.Continuous.Integrator PChiWatPumAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0) "Chilled water pump power consumption meter"
        annotation (Placement(transformation(extent={{-460,230},{-440,250}})));

      Modelica.Blocks.Sources.RealExpression PConWatPum1(y=PConWatPum)
        "Condensed water pump power consumption" annotation (Placement(
            transformation(extent={{-10,-10},{10,10}}, origin={-510,160})));

      Modelica.Blocks.Continuous.Integrator PConWatPumAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0) "Condensed water pump power consumption meter"
        annotation (Placement(transformation(extent={{-460,160},{-440,180}})));

      Modelica.Blocks.Sources.RealExpression PChi1(y=PChi)
        "Chiller power consumption" annotation (Placement(transformation(extent={{-10,
                -10},{10,10}}, origin={-610,160})));

      Modelica.Blocks.Continuous.Integrator PChiAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0) "Chiller power consumption meter"
        annotation (Placement(transformation(extent={{-560,160},{-540,180}})));

      Modelica.Blocks.Sources.RealExpression PSupFan1(y=PSupFan)
        "Supply air fan power consumption" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}}, origin={-510,90})));

      Modelica.Blocks.Continuous.Integrator PSupFanAgg(initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0) "Supply air fan power consumption meter"
        annotation (Placement(transformation(extent={{-460,90},{-440,110}})));

      Modelica.Blocks.Sources.RealExpression mConWat1_flow(y=mConWat_flow)
        "Flow in the condensed water loop" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}}, origin={-490,-100})));

      Modelica.Blocks.Sources.RealExpression mChiWat1_flow(y=mChiWat_flow)
      "Flow in the chilled water loop"   annotation (Placement(transformation(
              extent={{-10,-10},{10,10}}, origin={-490,-140})));

    equation

      connect(PAll.y, PAllAgg.u) annotation (Line(
          points={{-599,232},{-580,232},{-580,240},{-562,240}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(QRooIntGai1_flow.y, QRooIntGaiAgg.u) annotation (Line(
          points={{-599,-100},{-562,-100}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(PCooTowFan1.y, PCooTowAgg.u) annotation (Line(
          points={{-599,92},{-580,92},{-580,100},{-562,100}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(PChiWatPum1.y, PChiWatPumAgg.u) annotation (Line(
          points={{-499,232},{-480,232},{-480,240},{-462,240}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(PConWatPum1.y, PConWatPumAgg.u) annotation (Line(
          points={{-499,160},{-480,160},{-480,170},{-462,170}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(PChi1.y, PChiAgg.u) annotation (Line(
          points={{-599,160},{-580,160},{-580,170},{-562,170}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(PSupFan1.y, PSupFanAgg.u) annotation (Line(
          points={{-499,90},{-480,90},{-480,100},{-462,100}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation (
        Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-360,-300},{360,
                300}}), graphics={
            Text(
              extent={{-620,286},{-534,262}},
              lineColor={28,108,200},
              textString="Power meters"),
            Text(
              extent={{-620,-42},{-514,-70}},
              lineColor={28,108,200},
              textString="Heat flow meters"),
            Text(
              extent={{-502,-42},{-400,-72}},
              lineColor={28,108,200},
              textString="Fluid flow meters")}),
    Documentation(info="<HTML>
<p>
Energy metering panel.
</p>
</html>",     revisions="<html>
<ul>
<li>
April 18, 2021, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(extent={{-360,-300},{360,300}})));
    end EnergyMonitoring;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Examples.ChillerPlant\">Buildings.Examples.ChillerPlant</a>.
</p>
</html>"));
  end BaseClasses;
annotation (uses(Modelica(version="4.0.0"), Buildings(version="11.0.0")),
  version="3",
  conversion(noneFromVersion="", noneFromVersion="1",
      noneFromVersion="2"));
end ChillerPlant;
model ChillerPlant_ClosedLoopBase_OneDeviceWithWSE
 extends ChillerPlant.ClosedLoopBase.OneDeviceWithWSE;
  annotation(experiment(
  StopTime=31536000,
  Tolerance=0.001,
  __Dymola_Algorithm="Cvode"),uses(ChillerPlant(version="3")));
end ChillerPlant_ClosedLoopBase_OneDeviceWithWSE;
